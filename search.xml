<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>划分子网和构造超网</title>
      <link href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%88%92%E5%88%86%E5%AD%90%E7%BD%91%E5%92%8C%E6%9E%84%E9%80%A0%E8%B6%85%E7%BD%91/"/>
      <url>/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%88%92%E5%88%86%E5%AD%90%E7%BD%91%E5%92%8C%E6%9E%84%E9%80%A0%E8%B6%85%E7%BD%91/</url>
      
        <content type="html"><![CDATA[<h1 id="划分子网和构造超网">划分子网和构造超网</h1><h2 id="划分子网">划分子网</h2><h3 id="分类ip地址存在的问题">分类IP地址存在的问题</h3><ul><li>IP地址设计初衷：希望网络部分能唯一明确确定一个物理网络</li><li>早期的、分类的IP地址设计不够合理<ul><li>IP地址的利用率低<ul><li>一个A类网络可包含的主机数：<span class="math inline">\(2^{24}– 2=16,777,214\)</span></li><li>一个B类网络可包含的主机数：<span class="math inline">\(2^{16} – 2=65534\)</span></li><li>一个C类网络可包含的主机数：<span class="math inline">\(2^8 – 2=254\)</span></li></ul></li><li>无法根据网络规模灵活选择网络地址<ul><li>4个结点的网络使用一个完整的C类地址，浪费252个IP地址</li><li>1个10BaseT以太网最大结点数1024，得用一个B类地址，浪费6万多个IP地址</li></ul></li><li>分配的是网络号而不是40亿个独立的IP地址，耗尽的速度快<ul><li>126个 <span class="math inline">\((2^7 –2)\)</span>A类网络号分配完，就用尽了一半的IP地址，20亿</li><li>16,383个<span class="math inline">\((2^{14} –1)\)</span>B类网络号分配完，就用尽了1/4的IP地址，10亿</li></ul></li><li>网络号和主机号位数固定，导致网络规模不可调，造成分配的不合理</li><li>每个物理网络分配一个网络号使得路由表过大<ul><li>为每一个网络号增加一条目</li><li>大转发表增加路由器开销，增大路由查找延迟，减低路由器性能</li></ul></li><li>使用不灵活<ul><li>同一组织在不同地方开通新的物理网络，需要申请新的网络地址</li><li>不易于扩展、管理</li></ul></li></ul></li></ul><h3 id="基本思路">基本思路</h3><ul><li>二级的IP地址变成为三级：IP地址中又增加一个“子网号字段”<ul><li>从主机号借用若干个位作为子网号subnet-id，不改变原来的网络号net-id</li><li>IP地址 = 网络号 + 子网号 + 主机号</li></ul></li><li>实现多个物理网络共享一个网络号<ul><li>减少分配网络号总数</li><li>路由聚合 (aggregation)</li></ul></li><li>子网应当离得很近，从因特网其余部分看来，它们是一个单一网络，仅一个网络号<ul><li>划分子网纯属一个机构内部的事情，对外仍表现为未划分子网的网络</li><li>IP 数据报从其它网络到子网内某主机的路由<ul><li>仍然是根据 IP 数据报的目的网络号net-id，先找到连接在本单位网络上的路由器</li><li>然后，此路由器再按目的网络号 net-id 和子网号 subnet-id找到目的子网</li><li>最后将 IP 数据报直接交付目的主机</li></ul></li></ul></li><li>子网掩码<ul><li>子网的网络地址 = 三级IP地址 AND 子网掩码</li><li>默认子网掩码：为便于路由器处理，未划分子网的网络也使用子网掩码(即默认子网掩码)<ul><li>A类地址：255.0.0.0（8位网络号）</li><li>B类地址：255.255.0.0（16位网络号）</li><li>C类地址：255.255.255.0（24位网络号）</li></ul></li></ul></li><li>划分子网的借位原则<ul><li>RFC950规定子网号不能为全1和全0，因此至少借2位</li><li>最多借位数（至少留2位主机号）<ul><li>A类地址：22位</li><li>B类地址：14位</li><li>C类地址：6位</li></ul></li></ul></li><li>路由器FIB表的变化<ul><li>在不划分子网的两级 IP 地址下<ul><li>可从 IP 地址得出网络地址</li></ul></li><li>在划分子网的情况下<ul><li>从 IP地址不能唯一地得出网络地址来，网络地址取决于那个网络所采用的子网掩码，但数据报的首部并没有提供子网掩码的信息</li><li>在FIB表中添加子网掩码</li></ul></li></ul></li></ul><h4id="划分子网情况下路由器转发分组的算法">划分子网情况下路由器转发分组的算法</h4><ol type="1"><li>从数据报的首部提取目的主机的 IP 地址 D</li><li>用<strong>本结点</strong>的各个网络的子网掩码与D逐位相与，看是否与相应的网络地址匹配：匹配，则将分组直接交付；否则是间接交付，执行3</li><li>若路由表中有目的地址为 D的特定主机路由，则把数据报传送给路由表中所指明的下一跳路由器；否则，执行4</li><li>对路由表中的每一行的子网掩码和 D逐位相与，若其结果与该行的目的网络地址匹配，则将分组传送给该行指明的下一跳路由器；否则，执行5</li><li>若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器；否则，执行6</li><li>报告转发分组出错（ICMP，目的不可达）</li></ol><h4 id="例子">例子</h4><figure><imgsrc="https://raw.githubusercontent.com/JamesYuuu/Picbed/main/image-20231028200243639.png"alt="image-20231028200243639" /><figcaption aria-hidden="true">image-20231028200243639</figcaption></figure><ol type="1"><li>主机H1检查目标地址 128.30.33.138是否连接在本网络上<ul><li>是，则直接交付</li><li>否，交由路由器R1处理</li></ul></li><li>将目的地址与自己的子网掩码逐位相与<ul><li>128.30.33.128 AND 255.255.255.128 = 128.30.33.128</li><li>128.30.33.128 不在 128.30.33.0 子网中，因此交由路由器 R1处理</li></ul></li><li>路由器R1查询跳转表<ul><li>发现目标地址128.30.33.128 下一跳为接口1，直接交付</li></ul></li></ol><h3 id="子网划分的特点">子网划分的特点</h3><ul><li>本质上，允许将一些类别的地址在多个子网内分拆</li><li>实现多个物理网络共用一个网络地址<ul><li>减少地址空间的浪费</li></ul></li><li>互联网络不同部分看到不同的路由，远端只看到单一网络<ul><li>实现路由聚合</li></ul></li><li>子网划分在一个(逻辑)网络内部进行<ul><li>便于组织内部网络扩展与管理</li></ul></li></ul><h2 id="构造超网">构造超网</h2><h3 id="地址空间的效率和可扩展性问题">地址空间的效率和可扩展性问题</h3><blockquote><p>某公司网络由4064台主机构成</p></blockquote><ul><li>方案一：申请一个B类地址？<ul><li>一个B类地址空间可容纳65534个主机，使用率仅4064/65534 = 6.2%</li><li>子网划分？依然未解决地址浪费问题</li></ul></li><li>方案二：分配16个C类地址？<ul><li>保证了地址利用率</li><li>路由器超量存储<ul><li>若一个站点分配了16个C类网络号，则每个主干路由器需要增加16条记录才能将分组传送到该站点，尽管路径是相同的</li></ul></li><li>如果16个C类地址连续分配<ul><li>所有地址的高20位是相同的</li><li>将20位作为网络号，路由表中仅需要一个路由表项</li></ul></li></ul></li></ul><h3 id="无分类域间路由-cidr">无分类域间路由 CIDR</h3><ul><li>无分类域间路由 CIDR (Classless Inter-Domain Routing)<ul><li>打破地址分类的严格界线，网络号为可变长---更有效地分配 IPv4地址空间</li><li>仅仅使用转发表中的一条记录来指示如何到达多个不同网络 ----路由聚合</li></ul></li><li>从(使用子网掩码)三级编址 又回到了无分类的两级编址<ul><li>IP地址 = 网络前缀(network prefix) + 主机号<ul><li>使用各种长度的network-prefix来代替分类地址中的网络号和子网号</li></ul></li><li>使用“斜线记法”(slash notation)，又称为CIDR记法<ul><li>即在 IP地址后面加上一个斜线“/”，写上网络前缀所占的位数（这个数值对应于三级编址中子网掩码中1 的个数）</li></ul></li><li>把网络前缀都相同的连续的 IP 地址组成“CIDR 地址块”</li></ul></li></ul><h3 id="cidr地址块">CIDR地址块</h3><ul><li>193.14.32.0/20 表示的地址块共有 212 个地址<ul><li>网络前缀20位，主机号 12 位</li><li>地址块范围：193.14.32.0 ~ 193.14.47.255</li></ul></li></ul><h3 id="路由聚合构成超网">路由聚合，构成超网</h3><ul><li><p>路由聚合</p><ul><li><p>CIDR 地址块可以表示很多地址，这种地址的聚合称为路由聚合</p></li><li><p>使得路由表中的一个条目可以表示很多个(例如上千个)原来传统分类地址的路由</p></li></ul></li><li><p>构成超网（supernetting）</p><ul><li>如：前缀长度13<sub>15的CIDR地址块可能包含了多个B类或C类地址；前缀长度17</sub>23位的 CIDR 地址块都包含了多个 C 类地址<ul><li>这些地址合起来就构成了超网</li></ul></li><li>网络前缀越短，其地址块所包含的地址数就越多；而在三级结构的IP地址中，划分子网是使网络前缀变长<ul><li>超网是将多个网络聚合：使属于一个自治系统（AS）多个网络地址映射到一个地址</li><li>子网是将一个(逻辑)网络拆分：使多个物理网络共享一个网络地址</li></ul></li></ul></li></ul><h3 id="最长前缀匹配">最长前缀匹配</h3><ul><li>使用 CIDR ，在查找路由表时可能会得到不止一个匹配结果</li><li>解决方案：最长前缀匹配(longest-prefix matching)<ul><li>又称为最长匹配或最佳匹配</li><li>从匹配结果中选择具有最长网络前缀的路由<ul><li>网络前缀越长，其地址块就越小，因而路由就越具体(more specific)</li></ul></li></ul></li></ul><h4 id="最长前缀匹配的路由查找效率">最长前缀匹配的路由查找效率</h4><ul><li>最简单的查找算法：对所有可能的前缀进行循环查找<ul><li>对于目的地址D，对每个可能的前缀长度M (1~32, 32为特定主机路由 )<ul><li>提取D中的前M位，与路由表中的网络号匹配</li><li>最坏情况32次</li></ul></li><li>提高路由查找效率<ul><li>线速100Gb/s，分组平均长度2000bits<ul><li>路由器处理能力应达到5000万分组/秒(50Mpps)</li></ul></li><li>通过良好的数据结构、快速查找算法</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络协议IP</title>
      <link href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AEIP/"/>
      <url>/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AEIP/</url>
      
        <content type="html"><![CDATA[<h1 id="网络协议ip">网络协议IP</h1><h2 id="ip概述">IP概述</h2><h3 id="ip-设计思路">IP 设计思路</h3><ul><li>向上提供最基本的、简单的、灵活的数据报传输服务<ul><li>无连接<ul><li>网络发送分组时不需要先在源和目的结点间建立连接</li><li>每一个分组(IP 数据报) 独立发送，不进行编号，与其前后的分组无关</li></ul></li><li>尽最大努力交付 (best-effort delivery)<ul><li>网络层不提供服务质量的承诺</li><li>传送的分组可能出错、丢失、重复和乱序，也不保证分组传送的时限</li><li>如果主机 (即端系统)中的进程之间的通信需要可靠传输，由主机中的传输层负责(包括差错处理、流量控制等)，与网络结点(路由器)无关</li></ul></li><li>优点<ul><li>中间转发设备功能简单，成本低</li><li>协议设计简单，适应性强，扩展性强</li></ul></li></ul></li><li>可能的实现方法<ul><li>IP 数据报服务 : H1 发送给 H2 的分组可能沿着不同路径传送</li><li>虚电路(Virtual Circuit) : H1 发送给 H2的所有分组都沿着同一条虚电路传送<ul><li>可能的网络层技术，曾与IP竞争</li><li>面向连接的通信方式，源于电信网络的电路交换思想</li><li>建立虚电路(Virtual Circuit)，以保证双方通信所需的一切网络资源</li><li>网络保障可靠传输</li></ul></li></ul></li></ul><h3 id="互联网络">互联网络</h3><ul><li>互联网络 (internetwork or internet)<ul><li>提供各种主机--主机之间分组传输服务的、互连的网络的集合</li></ul></li><li>Internet--因特网，互联网<ul><li>专用名词，互联网络实例</li></ul></li><li>网络<ul><li>前边讨论过的直连网络或交换网络</li><li>如以太网、WiFi、4G/5G网络等</li></ul></li><li>子网<ul><li>所讨论网络中的一部分网络</li></ul></li></ul><h4 id="互联节点">互联节点</h4><ul><li>路由器/网关 (Router/Gateway)</li><li>IP的关键<ul><li>建立可扩展的异构互连机制</li><li>在所有结点(主机和路由器)上运行</li></ul></li></ul><h4 id="网络层功能">网络层功能</h4><ul><li>通过逐跳的分组转发实现源、目的结点间的数据传输，基于两种重要的网络层功能实现<ul><li>转发（动作、局部）<ul><li>分组到达路由器的一条输入链路时，路由器必须将该分组移动到适当的输出链路</li></ul></li><li>路由选择（决策、全局）<ul><li>分组从源结点(发送方)流向接收方(目的结点)时，网络层必须决定这些分组所采用的路由或路径，计算这些路径的算法称为路由选择算法(routingalgorithm)</li></ul></li></ul></li></ul><h2 id="ip及相关协议">IP及相关协议</h2><ul><li>网际协议 IP<ul><li>TCP/IP 体系中两个最主要的协议之一</li><li>编址规则、数据包格式、分组处理规则</li></ul></li><li>与之配套使用的协议<ul><li>路由选择协议<ul><li>路径选择</li></ul></li><li>地址解析协议 ARP (Address Resolution Protocol)<ul><li>实现IP地址与硬件地址的映射</li></ul></li><li>网际控制报文协议 ICMP (Internet Control Message Protocol)<ul><li>网络控制与诊断</li></ul></li><li>网际组管理协议 IGMP (Internet Group Management Protocol)<ul><li>IP多播</li></ul></li></ul></li></ul><figure><imgsrc="https://raw.githubusercontent.com/JamesYuuu/Picbed/main/image-20231028144750094.png"alt="image-20231028144750094" /><figcaption aria-hidden="true">image-20231028144750094</figcaption></figure><h2 id="分类的ip地址">分类的IP地址</h2><h3 id="ip地址及其表示方法">IP地址及其表示方法</h3><ul><li>IP地址 (IPv4) （位置/身份 合二为一）<ul><li>全球唯一的，32位，结点标识符<ul><li>32位地址空间，理论上可提供约40亿个主机地址</li></ul></li><li>由因特网名字与号码指派公司ICANN (Internet Corporation for AssignedNames and Numbers)进行分配</li></ul></li><li>表示方法<ul><li>每8位转化成10进制数，并在相邻两个数之间点分方便阅读</li></ul></li></ul><h3 id="ip地址的编址方法">IP地址的编址方法</h3><ul><li>分类的 IP 地址<ul><li>最基本的编址方法，相应的标准协议于1981年制定</li></ul></li><li>子网划分<ul><li>对基本编址方法的改进，其标准于 1985 年制定</li></ul></li><li>构成超网<ul><li>无类编址方法，其标准于1993 年提出</li></ul></li></ul><h3 id="ip地址的分类">IP地址的分类</h3><ul><li>层次结构：IP地址 = 网络号+主机号<ul><li>网络号(net-id)：指出结点 (主机或路由器)连在哪个网络上</li><li>所有连到同一网络上的结点，其IP地址的网络地址部分相同</li><li>网络号由ICANN分配</li></ul></li><li>主机号(host-id)：指出结点在网络内的标识<ul><li>主机号由网络管理员分配</li></ul></li></ul><h4 id="ip地址的详细分类">IP地址的详细分类</h4><ul><li>A类、B类、C类地址为单播地址 (Unicast)<ul><li>A 类地址：网络号为1 字节，第1位“0”；主机号3字节</li><li>B类地址：网络号为2 字节，前2位“10”；主机号2字节</li><li>C 类地址：网络号为3 字节，前3位“110”；主机号1字节</li></ul></li><li>D类为组播地址 (Multicast)</li><li>E类为保留地址以备特殊用途 (Reversed)</li></ul><figure><imgsrc="https://raw.githubusercontent.com/JamesYuuu/Picbed/main/image-20231028150632352.png"alt="image-20231028150632352" /><figcaption aria-hidden="true">image-20231028150632352</figcaption></figure><table><colgroup><col style="width: 6%" /><col style="width: 11%" /><col style="width: 23%" /><col style="width: 25%" /><col style="width: 14%" /><col style="width: 18%" /></colgroup><thead><tr class="header"><th style="text-align: center;">网络类别</th><th style="text-align: center;">最大网络数</th><th style="text-align: center;">第一个可用的网络号</th><th style="text-align: center;">最后一个可用的网络号</th><th style="text-align: center;">每个网络中最大的主机数</th><th style="text-align: center;">在整个IP地址空间的比率</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">A类</td><td style="text-align: center;">126 <br><span class="math inline">\((2^7– 2)\)</span></td><td style="text-align: center;">1. <br> （00000001. ）</td><td style="text-align: center;">126.<br> （01111110. ）</td><td style="text-align: center;">16,777,214 <br> $(2^{24} – 2) $</td><td style="text-align: center;">50% <br> $(2<sup>{31}/2</sup>{32})$</td></tr><tr class="even"><td style="text-align: center;">B类</td><td style="text-align: center;">16,383 <br>$ (2^{14} – 1)$</td><td style="text-align: center;">128.1. <br> （10000000.00000001. ）</td><td style="text-align: center;">191.255. <br> （10111111.11111111.）</td><td style="text-align: center;">65,534 <br>$ (2^{16} – 2) $</td><td style="text-align: center;">25% <br>$ (2<sup>{30}/2</sup>{32})$</td></tr><tr class="odd"><td style="text-align: center;">C类</td><td style="text-align: center;">2,097,151 <br>$ (2^{21} – 1) <spanclass="math inline">\(| 192.0.1.&lt;br&gt;（110000000.00000000.00000001.） | 223.255.255.&lt;br&gt;（11011111.11111111.11111111.） | 254 &lt;br&gt;\)</span> (2^8– 2)$</td><td style="text-align: center;">12.5% <br>$(2<sup>{29}/2</sup>{32})$</td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr></tbody></table><ul><li>私有地址（局域网地址）</li></ul><table><colgroup><col style="width: 13%" /><col style="width: 69%" /><col style="width: 16%" /></colgroup><thead><tr class="header"><th style="text-align: center;">网络类别</th><th style="text-align: center;">地址范围</th><th style="text-align: center;">所含网络数</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">A类</td><td style="text-align: center;">10.0.0.0 ~ 10.255.255.255 <br>(00001010.00000000.00000000.00000000 ~ 00001010.11111111. 11111111.11111111)</td><td style="text-align: center;">1</td></tr><tr class="even"><td style="text-align: center;">B类</td><td style="text-align: center;">172.16.0.0 ~ 172.31.255.255 <br>(10101100.00010000.00000000.00000000 ~10101100.00011111.11111111.11111111)</td><td style="text-align: center;">16 <br> <spanclass="math inline">\(（2^4）\)</span></td></tr><tr class="odd"><td style="text-align: center;">C类</td><td style="text-align: center;">192.168.0.0 ~ 192.168.255.255<br>(11000000.10101000.00000000.00000000 ~11000000.10101000.11111111.11111111)</td><td style="text-align: center;">256<br> <spanclass="math inline">\(（2^8）\)</span></td></tr></tbody></table><h3 id="ip地址的重要特点">IP地址的重要特点</h3><ol type="1"><li>特点一：IP 地址为两级的层次结构<ul><li>方便IP地址管理<ul><li>IP 地址管理机构在分配 IP地址时只分配网络号，而剩下的主机号则由得到该网络号的单位自行分配</li></ul></li><li>减小路由表存储空间<ul><li>路由器仅根据目的主机所连接的网络号来转发分组（而不考虑目的主机号），这样就可以使路由表中的项目数大幅度减少</li></ul></li></ul></li><li>特点二：IP 地址实际标识的是一个结点和一条链路的接口<ul><li>当一个结点 (主机或路由器)同时连接到两个网络上时，必须同时具有两个相应的 IP 地址，其网络号 net-id必须是不同的<ul><li>这种主机称为多归属主机(multihomed host)</li></ul></li><li>路由器至少应当有两个不同的 IP 地址<ul><li>因为其至少应同时连接到两个网络 ，才能将 IP数据包从一个网络转发到另一个网络</li></ul></li></ul></li><li>特点三：同一个网络上的结点的IP 地址的网络号必须一样<ul><li>用中继器或网桥连接起来的若干个局域网仍为一个网络，具有同样的网络号net-id</li></ul></li><li>特点四：所有分配到网络号 net-id 的网络都是平等的<ul><li>无论范围很小的局域网，还是可能覆盖很大地理范围的广域网</li></ul></li></ol><h3 id="ip地址与硬件地址的区别">IP地址与硬件地址的区别</h3><figure><imgsrc="https://raw.githubusercontent.com/JamesYuuu/Picbed/main/image-20231028152757372.png"alt="image-20231028152757372" /><figcaption aria-hidden="true">image-20231028152757372</figcaption></figure><h2 id="ip分组转发">IP分组转发</h2><ul><li>路由器将转发信息存储在转发表中<ul><li>Forwarding Information Base, FIB</li><li>FIB表中存储的是网络号与下一跳地址的映射关系<ul><li>若按目的主机号来制作路由表，则所得出的路由表就会过于庞大</li><li>比如：4个 B类网络通过3个路由器连接在一起，尽管每个网络上可能有上万个主机，按主机所在的网络地址来制作路由表，每个路由器中的路由表只需包含4 个条目</li></ul></li></ul></li><li>查找路由表，根据目的网络地址确定下一跳路由器<ul><li>IP 数据包最终可以到达目的主机所在的目的网络(可能通过多次间接交付)</li><li>分组到达目的网络后，最后一个路由器才试图根据目的主机号host-id，将数据包向目的主机进行直接交付</li></ul></li><li>特定主机路由<ul><li>这种路由是为特定的目的主机指明一个路由</li><li>采用特定主机路由可使网络管理人员能更方便地控制网络和测试网络，同时也可在需要考虑某种安全问题时采用这种特定主机路由</li></ul></li><li>默认路由（default route）<ul><li>当某地址在路由表中找不到匹配的地址时，采用此出口</li><li>对仅有一个网卡的主机，其缺省路由就是与网卡相连的那个路由器</li><li>默认路由可减少路由表所占用的空间和搜索路由表所用的时间，在一个网络只有很少的对外连接时是很有用的</li><li>如果一个主机连接在一个小网络上，而这个网络只用一个路由器和互联网连接，在这种情况下使用默认路由是非常合适</li></ul></li></ul><h3 id="分组转发规则">分组转发规则</h3><ol type="1"><li>从数据包的首部提取目的主机的 IP 地址 D, 得到目的网络地址为 N</li><li>若N是与此路由器直接相连的某个网络地址(N与自己某接口的网络地址相同)，则把数据包直接交付目的主机D；否则是间接交付，执行 3</li><li>若FIB表中有目的地址为 D的特定主机路由，则把数据包传送给路由表中所指明的下一跳路由器；否则，执行4</li><li>若FIB表中有到达网络 N的路由，则把数据包传送给路由表指明的下一跳路由器；否则，执行 5</li><li>若FIB表中有一个默认路由，则把数据包送给路由表中所指明的默认路由器；否则，执行6</li><li>报告转发分组出错（ICMP，目的不可达）</li></ol><h2 id="ip地址与硬件地址映射----地址解析协议arp">IP地址与硬件地址映射 --地址解析协议ARP</h2><blockquote><p>主机或路由器的物理接口硬件在转发数据时，只能理解特定网络的编址方案（硬件地址，如MAC地址 ）</p></blockquote><ul><li>地址解析：IP地址硬件地址<ul><li>IP数据报在逐跳转发过程中，每一个结点需要根据本次传输的目的结点IP找到对应的目的结点的硬件地址(仅仅是本跳传输的直接接收结点)</li><li>随后，网络适配器把IP数据包封装在目的地址为该硬件地址的帧中，发往本次传输的目的结点（可能是最终目的地，也可能是到达最终目的地的中间路由器）</li></ul></li></ul><h3 id="可能方法">可能方法</h3><ul><li>直接对应：将结点的硬件地址编码到IP地址的主机部分<ul><li>例如：硬件地址为00100001 01010001，对应IP地址为 128.96.33.81</li><li>限制：重复问题；主机号浪费；空间不匹配</li><li>C类网络中不超过8比特，以太网的硬件地址 48 比特</li></ul></li><li>每个结点保留一张对照表：IP地址 <spanclass="math inline">\(\to\)</span> 硬件地址<ul><li>地址解析协议 (Address Resolution Protocol, ARP)</li></ul></li></ul><h3 id="地址解析协议-address-resolution-protocol-arp">地址解析协议(Address Resolution Protocol, ARP)</h3><blockquote><p>ARP：根据目标主机的IP地址，查询其硬件地址</p></blockquote><ul><li>每个三层结点中都有一个ARP高速缓存（ARP Cache)<ul><li>存储结点所在局域网内各结点的 IP 地址到其硬件地址的映射表</li></ul></li><li>结点A向局域网内另一结点B发送IP报文<ul><li>在其 ARP Cache 中查看有无B的 IP地址，有则查出其对应的硬件地址，将此硬件地址写入 MAC 帧，通过局域网将该MAC 帧发往此硬件地址</li><li>否则，A向局域网内广播ARP请求，询问B的IP地址对应的硬件地址<ul><li>B收到该请求后，单播回复自己的硬件地址</li><li>A和B都会将对方地址的映射关系写入ARP Cache</li></ul></li></ul></li></ul><h4 id="需要注意的问题">需要注意的问题</h4><ul><li>ARP 实现同一局域网内结点IP 地址和硬件地址的映射<ul><li>若目的结点和源结点不在同一局域网内</li><li>通过 ARP找到本局域网内某路由器的硬件地址，把分组发送给该路由器，该路由器把分组转发给下一个网络</li></ul></li><li>IP地址到硬件地址的解析自动进行<ul><li>主机用户感知不到地址解析过程</li></ul></li><li>APR缓存中的条目有生命期<ul><li>超时会被删除，一般每15分钟一次</li></ul></li><li>ARP 分组不是IP 协议的一部分，不包括IP头<ul><li>ARP分组直接放在以太网帧的数据部分</li><li>以太网中将ARP请求和响应分组定义为0x0806 以太类型</li></ul></li></ul><h2 id="ip报文格式">IP报文格式</h2><ul><li>一个 IP 数据包由首部(header)和数据(data)两部分组成<ul><li>header的前面部分固定长度，20 字节；后面是可选字段，长度可变</li><li>分组格式几乎都设计成32 bits对齐，以简化软件对它们的处理</li></ul></li></ul><figure><imgsrc="https://raw.githubusercontent.com/JamesYuuu/Picbed/main/image-20231028183105978.png"alt="image-20231028183105978" /><figcaption aria-hidden="true">image-20231028183105978</figcaption></figure><ul><li><p>Version：版本，4bits，例如目前的IP协议版本号为4</p></li><li><p>HLen：首部长度，4bits，可表示的最大数值是 15 个单位(1个单位为 4字节)</p><ul><li>即首部最长60字节，最小为5，即20个字节（仅包含首部的固定部分）</li></ul></li><li><p>TOS：区分服务，8 位，用来获得更好的服务</p><ul><li>在旧标准中叫做服务类型，但实际上一直未被使用过，1998年这个字段改名为区分服务</li><li>只有在使用区分服务（DiffServ）时，这个字段才起作用，一般情况下不使用</li></ul></li><li><p>Length：总长度，16 位，指首部和数据之和的长度，单位为字节</p><ul><li>数据包的最大长度为 65535 字节</li><li>总长度必须不超过最大传送单元 MTU</li></ul></li><li><p>Identification标识、Flag标志、Offset片偏移：三个字段共32位，用于IP数据包分片</p></li><li><p>TTL：生存时间(Time To Live)，8位，数据报在网络中可通过的路由器跳数</p><ul><li>引入原因：数据分组单独寻径，从源到目的的延迟是随机变化的，可能路由器出错导致分组在网上无休止传输</li><li>理论最大值255，实际值一般不超过64；发送结点设置该值，分组每经过一个路由器时，将其值减1，TTL=0时丢弃该包</li></ul></li><li><p>Protocol：协议，8位，指出此数据报携带的数据是上层哪一个协议发来的</p><ul><li><table><thead><tr class="header"><th style="text-align: center;">ICMP</th><th style="text-align: center;">IGMP</th><th style="text-align: center;">IP</th><th style="text-align: center;">TCP</th><th style="text-align: center;">EGP</th><th style="text-align: center;">IGP</th><th style="text-align: center;">UDP</th><th style="text-align: center;">IPv6</th><th style="text-align: center;">OSPF</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">1</td><td style="text-align: center;">2</td><td style="text-align: center;">4</td><td style="text-align: center;">6</td><td style="text-align: center;">7</td><td style="text-align: center;">9</td><td style="text-align: center;">17</td><td style="text-align: center;">41</td><td style="text-align: center;">89</td></tr></tbody></table></li></ul></li><li><p>Checksum：首部校验和，16 位</p></li><li><p>只检验数据包的首部不检验数据部分</p></li><li><p>源、目的地址：各32位，传输中始终保持不变</p></li><li><p>Options：可变长，从 1 个字节到 40 个字节不等</p><ul><li>每种选项的第一字节为标识符，标识该选项的类型；若该选项的值是变长的，则还有一个字节表示长度，之后是该选项的值</li><li>主要用于测试和控制，为了增加 IP 数据包的功能，但同时也使得 IP数据包的首部长度可变，增加了每一个路由器处理数据包的开销</li></ul></li></ul><h2 id="ip-分片---连接异构网络">IP 分片-- 连接异构网络</h2><blockquote><p>不同 (异构) 网络拥有各自不同的最大传输单元长度（MTU）</p></blockquote><table><thead><tr class="header"><th style="text-align: center;">协议</th><th style="text-align: center;">MTU（字节）</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">超级通道（Hyperchannel）</td><td style="text-align: center;">65536</td></tr><tr class="even"><td style="text-align: center;">令牌环（16Mbps）</td><td style="text-align: center;">17194</td></tr><tr class="odd"><td style="text-align: center;">令牌环（4Mbps）</td><td style="text-align: center;">4464</td></tr><tr class="even"><td style="text-align: center;">FDDI</td><td style="text-align: center;">4352</td></tr><tr class="odd"><td style="text-align: center;">以太网</td><td style="text-align: center;">1500</td></tr><tr class="even"><td style="text-align: center;">X.25</td><td style="text-align: center;">576</td></tr><tr class="odd"><td style="text-align: center;">PPP</td><td style="text-align: center;">532</td></tr></tbody></table><h3 id="ip-分片fragmentation">IP 分片（Fragmentation）</h3><ul><li>分片<ul><li>当分组经历网络的MTU比分组长度小，路由器把该分组分成小的数据块（称为分片，fragment）后放进物理帧</li><li>每片的长度必须为8的倍数，最后一个可任意小</li><li>每个分段都含一个IP数据报头<ul><li>除报头中的长度(Length) 、标志(Flag)、片偏移(Offset)、校验和(Checksum)字段，其它字段与原始IP数据报头相同</li></ul></li></ul></li><li>重组<ul><li>分片的反过程，所有分片数据包到达目的主机后，目的主机负责还原原始IP报文</li></ul></li></ul><h4 id="ip头部有关分片的三个字段">IP头部有关分片的三个字段</h4><ul><li>标识（Identification）<ul><li>一个计数器，用来产生IP数据报的标识号</li><li>IP协议每发送一个数据报则该项加1，作为下一数据报的标识符</li><li>形成的数据报分片具有与原始数据报相同的源、目的地址和标识号</li><li>16位，保证重复使用一个分组标识符时，具有该标识符的上一分组的所有分段已从网上消失</li></ul></li><li>标志 (Flag)<ul><li>3 位，目前仅低2bit有用（未用 | DF | MF）</li><li>MF (More Fragment)：<ul><li>置1表示后面“还有分片”；</li><li>置0表示最后一个分片(没有分片也置0）</li></ul></li><li>DF (Don‘t Fragment)：<ul><li>置0才允许分片</li></ul></li></ul></li><li>片偏移(Offset)<ul><li>13位，指明分片在分组中的位置，采用8字节为偏移单位，分片必须是8字节的倍数<ul><li>因为Length是16bit，而offset是13bit</li></ul></li></ul></li></ul><h3 id="ip分片的缺点">IP分片的缺点</h3><ul><li>不能充分利用网络资源<ul><li>网络转发代价与包数目相关，与大小无关</li></ul></li><li>端到端性能很差<ul><li>当一个分片丢失时，接收端会丢弃同一报文的其他分片</li></ul></li><li>可被利用来生成DoS攻击<ul><li>攻击者向目标主机发送小片的流，没有一个片的Offset是0，重组数据时崩溃</li></ul></li><li>解决方案<ul><li>一般避免分段，使用路径MTU发现机制，IPv6废止了分片<ul><li>在数据传输过程中探测沿途网络的最小MTU，然后发方发送足够小的分组，使其能够在沿途不必分段</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>交换网络</title>
      <link href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BA%A4%E6%8D%A2%E7%BD%91%E7%BB%9C/"/>
      <url>/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BA%A4%E6%8D%A2%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="交换网络">交换网络</h1><h2 id="交换网络的由来">交换网络的由来</h2><h3 id="直连网络的可扩展性">直连网络的可扩展性</h3><ul><li>直连网络本质上是一种广播网络，共享链路，可扩展性很差<ul><li>结点数量、覆盖范围、性能受限</li></ul></li><li>解决办法<ul><li>分割网络，引入交换技术<ul><li>交换，是允许互联链路以形成更大规模网络的机制</li></ul></li><li>广播 <span class="math inline">\(\to\)</span> 单播，更强的扩展性<ul><li>通过交换机的互联，扩展结点数量、覆盖范围、性能</li></ul></li></ul></li></ul><h3 id="交换网络-1">交换网络</h3><ul><li>设计目标<ul><li>数据只朝向目的节点方向传送 (转发, Forward)，引入交换结点</li><li>转发规则是网络自己学习生成的，不需要外界参与</li></ul></li><li>交换网络的三个主要部分<ul><li>数据帧转发</li><li>学习结点位置</li><li>生成树协议</li></ul></li></ul><h2 id="网桥及数据帧转发">网桥及数据帧转发</h2><h3 id="网桥">网桥</h3><ul><li>在数据链路层扩展局域网<ul><li>解决共享介质的分组转发问题，扩展LAN的物理范围</li></ul></li><li>工作方式<ul><li>过滤（filtering）<ul><li>根据帧的目的地址决定一个帧应该转发到某个端口还是丢弃</li><li>目的结点处于接收端口所连接的网段，丢弃</li></ul></li><li>转发（forwarding）<ul><li>根据帧的目的地址决定该将其导向哪个接口，将帧发送出去</li></ul></li><li>基于转发表/转发数据库（FDB）实现</li></ul></li><li>网桥使各网段成为隔离开的碰撞域<ul><li>连接异质链路<ul><li>互连不同物理层、不同速率的局域网</li></ul></li><li>消除碰撞、增加网络带宽<ul><li>单个网段100Mbps，一个网桥能传输100n Mbsp (n为网桥端口数）</li></ul></li></ul></li></ul><h3 id="数据帧转发">数据帧转发</h3><ul><li>转发表/转发数据库(Forwarding DataBase, FDB)<ul><li>存储目的MAC地址到（出）端口的映射关系</li></ul></li><li>对每个数据帧，在FDB中查找目的MAC地址对应的端口号<ul><li>若存在对应端口号，且与接收端口一致，丢弃（避免数据环路）</li><li>若存在对应端口号，且不同于接收端口，从该端口将数据转发(单播)</li><li>如果FDB中不存在对应条目，将该数据包从所有端口转发 (广播)</li></ul></li></ul><h3 id="学习结点位置">学习结点位置</h3><blockquote><p>每收一个新的数据帧，记录其源MAC地址和输入端口，将该映射关系写入FDB表</p></blockquote><h3 id="生成树协议">生成树协议</h3><ul><li>网络中存在冗余链路（提升网络健壮性等）<ul><li>网络拓扑由树状结构变成图状结构</li><li>数据转发过程中，形成环路</li></ul></li><li>解决办法<ul><li>为网络中每对源目的节点分配唯一确定的一条路径</li><li>这些路径构成了一棵树 (生成树，Spanning Tree)<ul><li>覆盖所有顶点的无环子图</li></ul></li></ul></li></ul><h3 id="生成树算法">生成树算法</h3><ul><li>选择一个网桥作生成树的根<ul><li>如选一个最小序号的网桥</li><li>根网桥总在它所有端口上转发分组</li></ul></li><li>其它结点确定根端口<ul><li>每个网桥计算到根的最短路径，并记下路径经过它的哪个端口，将这个端口作为到根的优先路径</li></ul></li><li>为每个局域网选指派网桥<ul><li>指派网桥负责向根网桥转发帧（网桥之间通过算法确定）</li></ul></li><li>网桥彼此之间交换配置消息，包括三部分内容<ul><li>本网桥认定的根网桥的标识符</li><li>从本网桥到根网桥的距离，以跳数来衡量</li><li>正在发送信息的网桥的标识符</li></ul></li></ul><h4 id="具体逻辑">具体逻辑</h4><ol type="1"><li><p>初始时，每个网桥都认为自己是根，从每个端口发出配置信息</p><ul><li><p>B3 (B3, 0, B3 )</p></li><li><p>B5 (B5, 0, B5 )</p></li></ul></li><li><p>每个网桥收到配置消息时，确定是否优于自己的消息</p><ul><li>是，则保留，跳数加1，转发（向消息接收端口以外的其它所有端口）</li><li>否则，丢弃</li></ul></li><li><p>优于</p><ul><li>根的标识符更小</li><li>根相同，但有更小的距离 (跳数)<br /></li><li>根相同，跳数相同，发送者有更小的标识符</li></ul></li></ol><h3 id="网桥端口状态">网桥端口状态</h3><ul><li>Forwarding</li><li>Blocking<ul><li>由生成树算法阻断它，网中某个网桥有问题时，可以自动打开，重新开始生成树算法<ul><li>某网桥故障时，下游网桥将不能接收到配置消息，在等待一指定时间后，它们重新宣布自己是根，根据生成树算法选出新的根和指派网桥</li></ul></li></ul></li><li>Disabled<ul><li>软件上关掉</li></ul></li></ul><h3 id="多接口网桥以太网交换机">多接口网桥——以太网交换机</h3><ul><li>以太网交换机(switch)<ul><li>1990 年问世，可明显地提高局域网的性能</li><li>通常都有十几个接口，实质上是一个多接口的网桥</li><li>工作在数据链路层，常称为二层交换机</li><li>每个接口都直接与主机相连，并且一般都工作在全双工方式，主机独占带宽</li><li>能同时连通许多对的接口，使每一对相互通信的主机都能像独占通信媒体那样，进行无碰撞地传输数据</li><li>使用专用的交换结构芯片，其交换速率较高</li></ul></li></ul><h3 id="网桥的局限性">网桥的局限性</h3><ul><li>规模不能太大 (一般十几个LAN)<ul><li>生成树算法是线性扩展的，没有为扩展局域网提供分层结构</li><li>网桥转发所有广播帧，容易造成广播风暴(广播在LAN较小时实用)</li></ul></li><li>动态管理网络：限制广播范围、虚拟工作组、数据隔离…..<ul><li>虚拟局域网 (Virtual Lan, VLAN)</li></ul></li></ul><h2 id="虚拟局域网-virtual-lan-vlan">虚拟局域网 (Virtual Lan, VLAN)</h2><ul><li><p>VLAN 是由一些局域网网段构成的与物理位置无关的逻辑组</p><ul><li>这些网段具有某些共同的需求</li><li>每一个 VLAN的帧都有一个明确的标识符，指明发送这个帧的工作站是属于哪一个 VLAN</li></ul></li><li><p>VLAN只是局域网给用户提供的一种服务，而并不是一种新型局域网</p></li><li><p>在以太网的帧格式中插入VLAN 标记(tag)</p><ul><li>一个 4 字节的标识符，指明发送该帧的工作站属于哪一个VLAN</li></ul></li></ul><figure><imgsrc="https://raw.githubusercontent.com/JamesYuuu/Picbed/main/image-20231028143331826.png"alt="image-20231028143331826" /><figcaption aria-hidden="true">image-20231028143331826</figcaption></figure><h2 id="总结">总结</h2><ul><li>连接方式<ul><li>集线器 -&gt; 交换机</li></ul></li><li>数据传输方式<ul><li>广播 -&gt; 单播</li></ul></li><li>链路共享机制<ul><li>每个（全双工）链路只有两个节点，不需要CSMA/CD</li></ul></li><li>拓扑特征<ul><li>层次结构树</li><li>冗余链路的网络：生成树拓扑</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>以太网</title>
      <link href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BB%A5%E5%A4%AA%E7%BD%91/"/>
      <url>/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BB%A5%E5%A4%AA%E7%BD%91/</url>
      
        <content type="html"><![CDATA[<h1 id="以太网">以太网</h1><h2 id="两种链路类型">两种链路类型</h2><ul><li>点对点链路<ul><li>高级数据链路控制协议 (High-level Data Link Control, HDLC)</li><li>点对点协议(Point-to-Point Protocol, PPP)<br /></li></ul></li><li>广播链路<ul><li>以太网(Ethernet), IEEE 802.3</li><li>无线局域网(Wireless Lan, WLAN), IEEE 802.11</li></ul></li></ul><h2 id="网络分类">网络分类</h2><ul><li><p>广域网 WAN (Wide Area Network)</p></li><li><p>城域网 MAN (Metropolitan Area Network)</p></li><li><p>局域网 LAN (Local Area Network)</p><ul><li>特点<ul><li>覆盖范围小：房间、建筑物、园区，距离≤25km</li><li>高传输速率：10Mbps～1000Mbps</li><li>低误码率：10-8 ～ 10-10</li><li>拓扑：总线、星形、环形、树形</li><li>传输媒体：双绞线、同轴电缆、光纤</li></ul></li><li>典型技术<ul><li>以太网(Ethernet)</li><li>令牌环网 (Token Ring)</li><li>FDDI(Fiber Distributed Data Interface)</li></ul></li><li>IEEE 802标准体系（局域网、城域网标准）<ul><li>为使数据链路层更好地适应多种局域网标准，将其拆成两个子层<ul><li>逻辑链路控制 LLC (Logical Link Control)子层<ul><li>传输媒体与LLC 子层无关</li><li>采用何种协议的局域网对 LLC 子层都透明</li></ul></li><li>媒体接入控制 MAC (Medium Access Control)子层<ul><li>与接入到传输媒体有关的内容都放在 MAC子层</li></ul></li></ul></li></ul></li></ul><figure><imgsrc="https://raw.githubusercontent.com/JamesYuuu/Picbed/main/image-20231027221008918.png"alt="image-20231027221008918" /><figcaption aria-hidden="true">image-20231027221008918</figcaption></figure></li><li><p>个域网 PAN (Personal Area Network)</p></li></ul><h2 id="以太网的基本信息">以太网的基本信息</h2><h3 id="以太网发展历史">以太网发展历史</h3><ul><li>20世纪70年代中期<ul><li>诞生于美国施乐公司(Xerox)的帕洛阿尔托研究中心(PARC)</li><li>总线拓扑、同轴电缆、广播局域网、半双工</li></ul></li><li>20世纪90年代后期<ul><li>基于集线器的星形拓扑、双绞线、广播局域网、半双工</li><li>集线器(Hub)：物理层设备，作用于比特而不是帧</li></ul></li><li>本世纪初<ul><li>基于交换机的星形拓扑、双绞线、交换局域网、全双工</li><li>交换机(Switch)：二层设备</li></ul></li></ul><h3 id="以太网基本组成">以太网基本组成</h3><ul><li>传输介质(链路)<ul><li>同轴电缆</li><li>双绞线</li><li>光纤</li></ul></li><li>网络适配器</li><li>中继设备<ul><li>中继器(Repeater)</li><li>集线器(Hub)</li></ul></li><li>交换设备<ul><li>网桥 (Bridge)</li><li>交换机 (Switch)</li></ul></li></ul><h3 id="ieee-802.3-规范">IEEE 802.3 规范</h3><ul><li>传统以太网<ul><li>IEEE 802.3 —— 同轴电缆Ethernet</li><li>IEEE 802.3a ——细缆Ethernet</li><li>IEEE 802.3i —— 双绞线</li><li>IEEE 802.3j —— 光纤</li></ul></li><li>快速以太网FE<ul><li>IEEE 802.3u ——双绞线，光纤</li></ul></li><li>千兆以太网GE<ul><li>IEEE 802.3z —— 屏蔽短双绞线、光纤</li><li>IEEE 802.3ab —— 双绞线</li></ul></li></ul><h3 id="以太网传输介质标准">以太网传输介质标准</h3><blockquote><p>IEEE 802.3文档规定，由3部分组成</p></blockquote><p><img src="https://raw.githubusercontent.com/JamesYuuu/Picbed/main/image-20231027221915919.png" alt="image-20231027221915919" style="zoom:50%;" /></p><table><thead><tr class="header"><th style="text-align: center;">10Base5</th><th style="text-align: center;">粗同轴</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">10Base2</td><td style="text-align: center;">细同轴</td></tr><tr class="even"><td style="text-align: center;">10BaseT</td><td style="text-align: center;">双绞线</td></tr><tr class="odd"><td style="text-align: center;">10BaseF</td><td style="text-align: center;">多模光纤MMF</td></tr><tr class="even"><td style="text-align: center;">100BaseT</td><td style="text-align: center;">双绞线SMF</td></tr><tr class="odd"><td style="text-align: center;">100BaseF</td><td style="text-align: center;">多模/单模光纤</td></tr><tr class="even"><td style="text-align: center;">1000BaseX</td><td style="text-align: center;">屏蔽短双绞线/MMF/SMF</td></tr><tr class="odd"><td style="text-align: center;">1000BaseT</td><td style="text-align: center;">双绞线</td></tr></tbody></table><h4 id="总线型以太网">总线型以太网</h4><ul><li>10Base5，粗同轴电缆， IEEE 802.3a<ul><li>可靠性好，抗干扰能力强</li><li>插入式分接头，其触针插入到同轴电缆内芯<ul><li>收发器 : 发送/接收</li><li>AUI : 连接件单元接口</li></ul></li></ul></li><li>10Base2，细同轴电缆，IEEE 802.3a<ul><li>可靠性稍差</li><li>接头处采用工业标准的BNC连接器组成T型插座，使用灵活</li></ul></li></ul><h4 id="星形以太网">星形以太网</h4><ul><li>10BaseT，双绞线介质，IEEE 802.3i<ul><li>双绞线总是配合集线器使用</li><li>集线器(Hub)：物理层设备，简单转发比特</li><li>拓扑结构为星形，逻辑上仍是总线型网络，使用CSMA/CD</li><li>每个主机通过两对双绞线与Hub相连，发送/接收各1对</li><li>便宜，增添或移去站点(主机)变得十分简单，容易检测到电缆故障</li></ul></li></ul><h3 id="以太网帧结构">以太网帧结构</h3><figure><imgsrc="https://raw.githubusercontent.com/JamesYuuu/Picbed/main/image-20231027222228419.png"alt="image-20231027222228419" /><figcaption aria-hidden="true">image-20231027222228419</figcaption></figure><ul><li>帧前面插入8字节<ul><li>7 字节前同步码：用来实现 MAC 帧的比特同步</li><li>1个字节的帧开始定界符：表示后面的信息就是MAC 帧</li></ul></li><li>目标地址：6字节</li><li>源地址：6字节</li><li>类型：2字节<ul><li>用作多路分解，标志上一层使用的是什么协议，以把收到的 MAC帧的数据上交给上一层的这个协议</li></ul></li><li>数据字段：最小46字节<ul><li>最大 MTU 为 1500字节</li><li>最小帧 64字节 - 首尾共18字节</li><li>以太网采用CSMA/CD协议，为了避免碰撞检测，最小64字节</li></ul></li><li>CRC：4字节</li><li>帧尾部表示帧发送结束的方法<ul><li>对100M以太网<ul><li>物理层设备会自动在帧尾加上4B5B编码ESD字段（长度为两个5bits）</li></ul></li><li>对10M以太网<ul><li>会以一个特殊宽脉冲SOI来表示链路开始空闲</li></ul></li></ul></li></ul><h3 id="地址">地址</h3><ul><li>每个适配器有一个唯一的以太网地址，通常固化在ROM中<ul><li>称为硬件地址、网卡的物理地址、MAC 地址</li><li>严格地讲应当是每一个站的“名字”或标识符，而非地址</li></ul></li><li>以可读的方式显示(如ipconfig命令)，即由冒号分隔的6个数<ul><li>每个数对应于6字节地址的1个字节，由一对16进制数给出，每个16进制数对应4比特，而且去掉前导0</li><li>例，8:0:2b:e4:b1:2是可读的一个以太网地址，表示： 00001000 0000000000101011 11100100 10110001 00000010</li></ul></li><li>MAC地址分配<ul><li>IEEE 的注册管理机构 RA 负责向厂家分配地址字段的前3个字节(即高位 23位，其中第一字节的最低位表示单播/组播地址，单播“0”)</li><li>后3个字节(即低位 24位)由厂家自行指派，称为扩展标识符，必须保证生产出的适配器没有重复地址</li></ul></li></ul><h3 id="以太网主机接收数据方式">以太网主机接收数据方式</h3><ul><li>以太网适配器接收(receive)所有帧<ul><li>广播信道，所有主机在一个广播域</li></ul></li><li>但以太网适配器只接受(accept)<ul><li>编址到它自己地址的帧</li><li>编址到广播地址的帧</li><li>编址到多点播送地址的帧，如果适配器在监听那个地址</li><li>所有帧，如果适配器处于混杂模式</li></ul></li><li>以太网适配器只向主机传递它接受的帧</li></ul><h3 id="以太网不提供可靠传输">以太网不提供可靠传输</h3><ul><li>提供的服务是尽最大努力的交付，即不可靠的交付<ul><li>对发送的数据帧不进行编号，也不要求对方发回确认</li><li>当目的站收到有差错的数据帧时丢弃，差错的纠正由高层决定</li><li>如果高层进行重传，以太网并不知道这是重传帧，当作新的帧发送</li></ul></li><li>无效帧<ul><li>帧的长度不是整数个字节</li><li>用收到的帧检验序列 CRC查出有差错</li><li>数据字段的长度不在 46 ~ 1500 字节之间<ul><li>有效的 MAC 帧长度为 64 ~ 1518 字节之间</li></ul></li></ul></li></ul><h3 id="以太网的解决方案">以太网的解决方案</h3><ul><li>编码：曼彻斯特码、4B/5B</li><li>组帧：面向比特</li><li>差错检测：CRC</li><li>可靠传输：不提供，尽力交付</li><li>媒体共享：CSMA/CD</li></ul><h3 id="扩展以太网">扩展以太网</h3><ul><li>在物理层扩展<ul><li>光纤：扩展主机与Hub、Hub与Hub距离</li><li>多个Hub：扩展为覆盖范围更广、连接结点更多的多级星形结构 (树形)</li></ul></li><li>在数据链路层扩展<ul><li>网桥 (Bridge)、二层交换机 (Switch)</li><li>演变为交换网络，不再是广播域</li></ul></li></ul><h2 id="以太网评价">以太网评价</h2><ul><li>以太网基本上统治了有线局域网</li><li>以太网的优点<ul><li>便宜，高速，易于使用、管理和扩展</li></ul></li><li>总线型以太网的缺点<ul><li>数据包越小，传输单位数据的代价越大</li><li>用户数增加时，更容易发生碰撞</li><li>链路变长时，需要更长时间来检测碰撞</li><li>网络负载越大，传输性能越低</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>媒体共享</title>
      <link href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%AA%92%E4%BD%93%E5%85%B1%E4%BA%AB/"/>
      <url>/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%AA%92%E4%BD%93%E5%85%B1%E4%BA%AB/</url>
      
        <content type="html"><![CDATA[<h1 id="媒体共享">媒体共享</h1><h2 id="静态划分信道">静态划分信道</h2><blockquote><p>信道复用技术(Multiplexing)，为多个用户静态划分逻辑信道，相互不冲突</p></blockquote><h3 id="频分复用frequency-division-multiplexing-fdm">频分复用(FrequencyDivision Multiplexing, FDM)</h3><ul><li>用户分配到一定的频带后，在通信过程中自始至终都占用该频带<ul><li>所有用户在同样的时间占用各自的带宽资源</li></ul></li><li>应用：早期的有线电视网络、光纤通信网络、模拟电话系统等</li></ul><h3 id="时分复用time-division-multiplexing-tdm">时分复用(Time DivisionMultiplexing, TDM)</h3><ul><li>将时间划分为一段段等长的时分复用帧 (TDM 帧)<ul><li>每个用户在每个 TDM帧中占用固定序号的时隙，占用的时隙周期性地出现(周期为TDM 帧的长度)</li><li>所有用户在不同的时间占用同样的频带宽度</li></ul></li></ul><h3 id="统计时分复用statistic-tdm-stdm">统计时分复用(Statistic TDM,STDM)</h3><blockquote><p>计算机网络中，由于数据传输具有突发性，TDM总带宽利用率不高</p></blockquote><ul><li>按需动态分配时隙<ul><li>每个STDM帧中的时隙数小于用户数</li><li>用户所占时隙非周期性出现，又称异步时分复用；TDM称同步时分复用</li><li>每个时隙中必须有用户的地址信息</li></ul></li><li>动态媒体接入控制，多点接入(multiple access)<ul><li>信道不固定分配给用户，实际接入时动态接入，分布式算法<ul><li>随机接入：结点按需随机接入，需解决碰撞问题</li><li>受控接入：结点接入服从一定控制，如令牌环网</li></ul></li></ul></li></ul><h3id="波分复用wavelength-division-multiplexing-wdm">波分复用(WavelengthDivision Multiplexing, WDM)</h3><ul><li>光的频分复用<ul><li>光载波的频率很高，习惯用波长而非频率表示</li></ul></li></ul><h3 id="码分复用code-division-multiplexing-cdm">码分复用(Code DivisionMultiplexing, CDM)</h3><ul><li>码分多址 (Code Division Multiple Access, CDMA)<ul><li>基于扩频技术<ul><li>发送端：将需传送的具有一定信号带宽的信息数据，用一个带宽远大于信号带宽的高速伪随机码进行调制，使原数据信号的带宽被扩展，再经载波调制并发送出去</li><li>接收端使用完全相同的伪随机码，与接收的宽带信号作相关处理，把宽带信号换成原信息数据的窄带信号即解扩，以实现信息通信</li></ul></li></ul></li><li>每1个比特实际划分为m个短的间隔，称为码片(chip)</li><li>每个用户被指派一个唯一的m bit码片序列<ul><li>m一般取值 64 或 128</li><li>发送比特1，则发送自己的 m bit 码片序列</li><li>发送比特0，则发送该码片序列的二进制反码</li><li>扩频：假定S站要发送信息的数据率为b bit/s。由于每一个比特要转换成 m个比特的码片，因此S站实际上发送的数据率提高到 mbbit/s，同时S站所占用的频率宽度也提高到原来数值的m倍</li></ul></li><li>例如：S站的8bit码片序列是 00011011<ul><li>发送比特1时，就发送序列 00011011</li><li>发送比特0时，就发送序列 11100100</li><li>通常将码片种的0表示成-1，1表示成+1<ul><li>S站的码片即为（-1 -1 -1 +1 +1 -1 +1 +1）</li></ul></li></ul></li><li>如何实现信道复用？<ul><li>每个站分配的码片序列必须各不相同，并且还必须相互正交<ul><li>即令向量𝑺和𝑻分别表示两个站点的码片，即任意𝑺和𝑻的归一化内积为0</li><li>即$ S T = ^m_{i=1} S_i T_i = 0$</li></ul></li><li>显然有 $ S S =1<span class="math inline">\(；\)</span>S!S = -1<spanclass="math inline">\(；\)</span>S T = 0$</li></ul></li></ul><h2id="动态媒体接入控制多点接入multiple-access">动态媒体接入控制，多点接入(multipleaccess)</h2><h3 id="随机接入">随机接入</h3><ul><li>结点按需随机接入，接入后以信道的全部速率进行发送</li><li>发生碰撞时，相关结点反复重发，直到无碰撞成功发送<ul><li>冲突域(collision domain)、冲突/碰撞 (collide)</li></ul></li><li>各结点在重发前独立选择一个随机时延</li></ul><h4 id="aloha">ALOHA</h4><figure><imgsrc="https://raw.githubusercontent.com/JamesYuuu/Picbed/main/image-20231027201256445.png"alt="image-20231027201256445" /><figcaption aria-hidden="true">image-20231027201256445</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/JamesYuuu/Picbed/main/image-20231027201236341.png"alt="image-20231027201236341" /><figcaption aria-hidden="true">image-20231027201236341</figcaption></figure><h4 id="时隙-aloha">时隙 ALOHA</h4><figure><imgsrc="https://raw.githubusercontent.com/JamesYuuu/Picbed/main/image-20231027201316756.png"alt="image-20231027201316756" /><figcaption aria-hidden="true">image-20231027201316756</figcaption></figure><h4id="载波侦听多点接入carrier-sense-multiple-access-csma">载波侦听多点接入(CarrierSense Multiple Access, CSMA)</h4><figure><imgsrc="https://raw.githubusercontent.com/JamesYuuu/Picbed/main/image-20231027201433604.png"alt="image-20231027201433604" /><figcaption aria-hidden="true">image-20231027201433604</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/JamesYuuu/Picbed/main/image-20231027201453588.png"alt="image-20231027201453588" /><figcaption aria-hidden="true">image-20231027201453588</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/JamesYuuu/Picbed/main/image-20231027201502122.png"alt="image-20231027201502122" /><figcaption aria-hidden="true">image-20231027201502122</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/JamesYuuu/Picbed/main/image-20231027201604988.png"alt="image-20231027201604988" /><figcaption aria-hidden="true">image-20231027201604988</figcaption></figure><h4 id="带碰撞检测的csma-csmacd">带碰撞检测的CSMA (CSMA/CD)</h4><figure><imgsrc="https://raw.githubusercontent.com/JamesYuuu/Picbed/main/image-20231027201732994.png"alt="image-20231027201732994" /><figcaption aria-hidden="true">image-20231027201732994</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/JamesYuuu/Picbed/main/image-20231027201711481.png"alt="image-20231027201711481" /><figcaption aria-hidden="true">image-20231027201711481</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/JamesYuuu/Picbed/main/image-20231027201903012.png"alt="image-20231027201903012" /><figcaption aria-hidden="true">image-20231027201903012</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/JamesYuuu/Picbed/main/image-20231027201846730.png"alt="image-20231027201846730" /><figcaption aria-hidden="true">image-20231027201846730</figcaption></figure><h4 id="带碰撞避免的csma-csmaca">带碰撞避免的CSMA (CSMA/CA)</h4><figure><imgsrc="https://raw.githubusercontent.com/JamesYuuu/Picbed/main/image-20231027201945321.png"alt="image-20231027201945321" /><figcaption aria-hidden="true">image-20231027201945321</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/JamesYuuu/Picbed/main/image-20231027201957641.png"alt="image-20231027201957641" /><figcaption aria-hidden="true">image-20231027201957641</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/JamesYuuu/Picbed/main/image-20231027202010492.png"alt="image-20231027202010492" /><figcaption aria-hidden="true">image-20231027202010492</figcaption></figure><h3 id="受控接入">受控接入</h3><ul><li>用户接入服从一定控制，如令牌环网</li></ul><h2 id="两类媒体共享技术对比">两类媒体共享技术对比</h2><table><colgroup><col style="width: 65%" /><col style="width: 34%" /></colgroup><thead><tr class="header"><th style="text-align: center;">静态划分信道</th><th style="text-align: center;">动态媒体接入控制</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">FDM, TDM, WDM, CDM</td><td style="text-align: center;">ALOHA, CSMA/CD, CSMA/CA</td></tr><tr class="even"><td style="text-align: center;">使用控制器/仲裁器</td><td style="text-align: center;">不使用控制器/仲裁器</td></tr><tr class="odd"><td style="text-align: center;">使用已分配的固定带宽</td><td style="text-align: center;">使用的带宽是变动的</td></tr><tr class="even"><td style="text-align: center;">强调公平性</td><td style="text-align: center;">强调自组织和带宽利用率</td></tr><tr class="odd"><td style="text-align: center;">2G(GPRS, Edge), 3G(CDMA2000, WCDMA),4G+</td><td style="text-align: center;">Ethernet, WiFi</td></tr><tr class="even"><tdstyle="text-align: center;">多用于传统语音、视频系统，以及移动蜂窝网络（物理层）</td><td style="text-align: center;">用于互联网数据传输（MAC层）</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>可靠传输</title>
      <link href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93/"/>
      <url>/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93/</url>
      
        <content type="html"><![CDATA[<h1 id="可靠传输">可靠传输</h1><h2 id="可靠传输的概念">可靠传输的概念</h2><ul><li>差错检测技术只能做到无差错接受<ul><li>凡是接受的帧（即没有丢弃），我们能以非常接近于 1的概率认为这些帧在传输过程中没有产生差错</li></ul></li><li>错误帧呗接收方丢弃<ul><li>有些纠错码技术可以恢复轻微的误码，但实际计算开销太大</li></ul></li><li>可靠传输<ul><li>必须能以某种方式恢复被丢弃或丢失的帧</li><li>链路层、传输层、应用层都可以提供</li></ul></li><li>基本机制<ul><li>确认（ACK）：协议发给它的对等实体的消息，告知它已收到刚才的帧<ul><li>可以是一个控制帧，即无任何数据的头部</li><li>也可以将一个ACK捎带在一个恰好要发向对方的数据帧中</li></ul></li><li>超时（TIMEOUT）<ul><li>发送方收到一个确认，表明帧发送成功；如果在合理的一段时间后未收到确认，那么它重发(retransmit) 原始帧</li><li>等待一段合理时间的这个动作称为超时 (timeout)</li></ul></li><li>自动请求重发（ARQ）<ul><li>使用确认和超时实现可靠传输的策略</li></ul></li></ul></li></ul><h2 id="停等算法">停等算法</h2><h3 id="基本思想">基本思想</h3><ul><li>当发送方传输一帧后，在传输下一帧之前等待一个ACK；如果在某段时间之后ACK没有到达，则发送方超时，重发原始帧</li></ul><blockquote><p>重复帧问题：Sender超时重传，但是Receiver误以为是下一帧，重复接收</p></blockquote><ul><li>包含1比特序列号的停等算法<ul><li>序号值取0或1，每帧交替使用</li></ul></li></ul><h3 id="缺点">缺点</h3><ul><li>只允许链路上有一个未确认的帧，这可能远远低于链路的容量</li><li>例如：RTT=90ms的1.5Mbps链路<ul><li>链路带宽积 = $ 1.5Mbps * 90ms / 2 = 8KB $</li><li>每次只能发一帧，造成明显的浪费</li></ul></li></ul><h2 id="滑动窗口算法">滑动窗口算法</h2><h3 id="基本原理">基本原理</h3><ul><li>保持管道满载，提升传输速率的方法<ul><li>增加单位时间传输数据帧的数目</li></ul></li><li>并发传输数据<ul><li>允许多个在途传输 (未收到ACK) 的数据帧</li><li>通过窗口大小 (window) 限制在途传输的数据帧个数</li></ul></li><li>每个数据帧赋予一个序列号 (Sequence Number, SeqNum)<ul><li>匹配数据帧与对应的ACK，假设SeqNum能无限大</li></ul></li></ul><h3 id="发送方">发送方</h3><ul><li>维护三个状态变量<ul><li>发送窗口大小 (Send Window Size,SWS)：能够发送但未确认的帧数的上界</li><li>最近被确认过的帧的序号 (Last Acknowledgement Received, LAR)</li><li>最近发送的帧的序号 (Last Frame Sent, LFS)</li></ul></li><li>操作<ul><li>收到 ACK：更新 LAR（右移），若窗口运行，则发送新的帧，更新 LFS<ul><li>即保证 $ LFS - LAR SWS$</li></ul></li><li>为每帧设置定时器，若收到ACK前超时，重传该帧</li><li>必须能缓存SWS个帧</li></ul></li></ul><h3 id="接收方">接收方</h3><ul><li><p>维护三个状态变量</p><ul><li>接收窗口大小 (Receive Window Size,RWS)：能够接受的无序帧数目上界</li><li>最大的可接收帧的序号 (Largest Acceptable Frame, LAF)</li><li>最后确认接收的帧的序号 (Last Frame Received, LFR)</li></ul></li><li><p>操作</p><ul><li><p>收到帧：$ LFR SeqNum LAF$，帧在接收窗口内，接收；否则，丢弃</p></li><li><p>接受数据帧后，将收到的最大连续数据帧的SeqNum作为ACK回复</p></li></ul></li></ul><h3 id="当数据帧丢失时">当数据帧丢失时</h3><ul><li>方案一：回退N机制(Go-Back-N)恢复丢包<ul><li>接收方只对连续收到的数据帧回复ACK<ul><li>例如收到 2 3 4 6 7，则对帧4回复ACK</li></ul></li><li>发送方，由于接收不到新的ACK，超时后重传LAR+1与LFS之间的数据帧<ul><li>例如上例中重传 5 6 7</li></ul></li></ul></li><li>方案二：选择确认机制(Selective Acknowledgments) 回复丢包<ul><li>接收方准确地确认每个已接受的数据帧，发送方根据这些信息更快重传</li><li>传输效率更高，但实现更复杂</li></ul></li></ul><h3 id="窗口大小">窗口大小</h3><ul><li>发送方 SWS<ul><li>可根据一段给定时间内链路上有多少待确认的帧来选择</li><li>依据给定的延迟与带宽的乘积</li></ul></li><li>接收方 RWS<ul><li>RWS=1：接收方不缓存任何错序到达的帧</li><li>RWS = SWS：接收方能够缓存发送方传输的任何帧</li></ul></li><li>序号大小有限<ul><li>序列号在大小有限的首部字段中，如3bit可用序号0~7</li><li>序列号必须可重用，能回绕<ul><li>能够区别同一序列号的不同次发送</li><li>可用序列号的数目必须大于所允许的待确认的帧的数目<ul><li>例如停等算法中只允许一个待确认的帧，用2个序列号</li></ul></li></ul></li></ul></li><li>当 SWS = RWS时<ul><li>$ (SWS + RWS) MaxSeqNum$<ul><li><span class="math inline">\(MaxSeqNum =2^n\)</span>，n为使用的bit数</li></ul></li><li>即 $SWS = RWS ^{n-1} $<ul><li>发送窗口大小不能大于可用序列号数的一半</li></ul></li></ul></li></ul><h2 id="滑动窗口算法的优点">滑动窗口算法的优点</h2><blockquote><p>滑动窗口是一种高效的可靠传输机制</p></blockquote><ul><li>可靠传输<ul><li>基于确认和超时重传机制，在不可靠链路上可靠传输</li></ul></li><li>高效传输<ul><li>通过并发提升传输性能</li></ul></li><li>按序传送<ul><li>接收方将连续的数据交给上层，缓存不连续 (乱序到达)的数据</li></ul></li><li>流量控制 (flow control)<ul><li>接收方能够控制发送方使其降低速度的反馈机制</li><li>通信双方通过设定Window大小表达自己的发送/接收能力</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>差错检测</title>
      <link href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%B7%AE%E9%94%99%E6%A3%80%E6%B5%8B/"/>
      <url>/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%B7%AE%E9%94%99%E6%A3%80%E6%B5%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="差错检测">差错检测</h1><h2 id="基本概念">基本概念</h2><ul><li>数据在传输过程中可能会产生比特差错<ul><li>数据传输过程中，因电磁干扰等，比特位发生反转</li><li>传输错误的比特占传输比特总数的比率称为误码率(Bit Error Rate,BER)</li></ul></li><li>差错检测的基本思想<ul><li>在数据帧中加入冗余信息来确定是否存在差错</li></ul></li><li>当接收方检测到差错时，可以<ul><li>通知对方数据有差错，使其重传数据副本（重传机制）</li><li>通过加入的冗余信息，重新构造正确的数据（纠错码）</li></ul></li></ul><h2 id="奇偶校验">奇偶校验</h2><h3 id="单向奇偶校验单个位奇偶校验">单向奇偶校验/单个位奇偶校验</h3><ul><li>使用单个奇偶校验位</li><li>分为奇校验 和 偶校验，假设信息有 d 比特<ul><li>偶校验：d 比特信息和 1 比特校验位中 1 的总数为偶数</li><li>奇校验：d 比特信息和 1 比特校验位中 1 的总数为奇数</li></ul></li><li>出现奇数个比特差错可检测出；偶数个则无法检查<ul><li>测量表明，差错往往以突发方式聚集在一起，而非独立发生</li><li>突发差错下，该方案无法检测出差错的概率50%</li></ul></li></ul><h3 id="二维奇偶校验">二维奇偶校验</h3><ul><li>将 d 比特信息划分为i行j列，对每行和每列都计算奇偶值，产生 i+j+1个奇偶校验位</li></ul><h2 id="校验和">校验和</h2><h3 id="基本思想">基本思想</h3><ul><li><p>将传输的所有字加起来，相加的结果作为校验和，一起传输</p></li><li><p>接收端执行同样计算，结果与收到的校验和比较，若不同则判断出错</p></li><li><p>TCP/IP 协议中采用的变种</p></li><li><p>发送方：将所有数据分为许多16位字的序列，将所有16位字相加，对结果取反，即为校验和</p><ul><li>注意求和的时候，最高位的进位需要回卷到最低位</li></ul></li><li><p>接收方：将所有16比特字（包括校验和）相加，若结果为全1则认为无差错</p></li></ul><h3 id="差错检验能力">差错检验能力</h3><ul><li><p>冗余少，仅16比特，对任意长度数据进行检测，检测能力较弱</p><ul><li>例如一对单比特错，1个使某个字增加1，另一个使另一个字减少1，校验和不变</li></ul></li><li><p>易于软件实现，用于上层端到端协议，下层由链路层提供更强的检错能力</p></li></ul><h2 id="循环冗余检验crc">循环冗余检验（CRC）</h2><h3 id="差错检测算法设计目标">差错检测算法设计目标</h3><ul><li>使用最少的冗余比特检测最多的错误</li><li>CRC使用很强的数学算法实现<ul><li>二进制除法</li><li>非标准除法，用异或代替相减（无借位）</li></ul></li></ul><h3 id="crc的基本思想">CRC的基本思想</h3><ul><li><span class="math inline">\(n\)</span>次的多项式可以表示<spanclass="math inline">\(n+1\)</span>比特的信息<ul><li>1代表该指数存在，0代表不存在</li></ul></li><li>为计算CRC，收发双方商定一个k次幂的除数<spanclass="math inline">\(C(x)\)</span></li><li>对于<span class="math inline">\(n\)</span>比特消息<spanclass="math inline">\(M(x)\)</span>，实际发送加上<spanclass="math inline">\(k\)</span>比特冗余的消息<spanclass="math inline">\(P(x)\)</span>，使得<spanclass="math inline">\(P(x)\)</span>能被<spanclass="math inline">\(C(x)\)</span>整除；若接收方收到的消息不能被<spanclass="math inline">\(C(x)\)</span>整除，则判断出错</li><li>计算<span class="math inline">\(P(x)\)</span><ul><li><span class="math inline">\(x^k\)</span>乘<spanclass="math inline">\(M(x)\)</span>，即消息末尾加上<spanclass="math inline">\(k\)</span>个0，得到零扩展消息<spanclass="math inline">\(T(x)\)</span> //<code>T = M &lt;&lt; k</code></li><li><span class="math inline">\(C(x)\)</span>除<spanclass="math inline">\(T(x)\)</span>，得到余数<spanclass="math inline">\(S(x)\)</span> // <code>S = T % C</code></li><li>$P(x) = T(x) - S(x) $ // <code>P = T XOR S</code></li></ul></li></ul><h3 id="cx的选择">C(x)的选择</h3><ul><li><span class="math inline">\(x^k\)</span> 和 <spanclass="math inline">\(x^0\)</span>项的系数不为0，则可以检测所有单比特错</li><li><spanclass="math inline">\(C(x)\)</span>含有一个至少3项的因子，可检测所有双比特错</li><li><span class="math inline">\(C(x)\)</span>含有因子<spanclass="math inline">\(x+1\)</span>，可检验任意奇数个错</li></ul><h2 id="检错还是纠错">检错还是纠错</h2><ul><li>检错：发现错误，重传</li><li>纠错：发现错误，纠正<ul><li>纠错码的冗余位要比检错码长，编码效率低</li><li>使用纠错码的场景<ul><li>差错发生的可能性高：无线环境</li><li>重传代价高：卫星链路</li><li>无法重传：单工信道</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>组帧</title>
      <link href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BB%84%E5%B8%A7/"/>
      <url>/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BB%84%E5%B8%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="组帧">组帧</h1><h2 id="面向字节的组帧">面向字节的组帧</h2><ul><li>最早的组帧方法：把每一帧看成一个字节（字符）集<ul><li>源于终端与大型机的连接</li></ul></li></ul><h3 id="起止标识法">起止标识法</h3><ul><li>特定字符表示帧的开始与结束</li><li>实例：二进制同步通讯协议BISYNC</li><li>数据帧的透明传输<ul><li>任意比特组合的数据都能通过数据链路层</li><li>如果数据负载中也包含了特殊字符该如何处理<ul><li>字符填充法：通过转义符对数据传输中的该特殊符号进行转义</li></ul></li></ul></li></ul><h3 id="字节计数法">字节计数法</h3><ul><li>帧中的字节数放在首部的一个字段中</li><li>实例：数字数据通信消息协议DDCMP</li><li>缺点：若Count出错，可能会产生累计多个错误</li></ul><h2 id="面向比特的组帧">面向比特的组帧</h2><ul><li><p>特点</p><ul><li><p>不关心字节的边界，它只是把帧看成比特集</p></li><li><p>比特可能来自某个字符集，如ASCII码，或者可能是一幅图像中的像素值或一个可执行文件的指令和操作数</p></li></ul></li><li><p>实例</p><ul><li>由IBM开发的同步数据链路控制（SDLC）协议<ul><li>ISO将SDLC标准化为高级数据链路控制协议（HDLC）</li></ul></li><li>Beginning Sequence 和Ending Sequence：01111110（标志字段）</li><li>在链路空闲时，也发送这个序列，以保证发方、收方的时钟同步</li></ul></li><li><p>数据帧的透明传输</p><ul><li>任意比特组合的数据都能通过数据链路层</li><li>问题：01111110可能出现在帧的任何地方</li></ul></li><li><p>解决办法</p><ul><li>发送方：当一串比特流尚未加上标志字段时，先用硬件扫描整个帧（用软件也可实现，但要慢一些），只要发现5个连续的1，则立即填入一个0</li><li>接收方：先找到开始点01111110，然后再定结束点，在接收了连续的5个1之后，就可以根据下一位决定是填充位还是结束到达，下一位为：<ul><li>0，必为填充的0，丢弃此位；</li><li>1，再看下一位：若为0，则为帧结束；若为1，则出错（表示出现连续7个1）</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络构件</title>
      <link href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E6%9E%84%E4%BB%B6/"/>
      <url>/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E6%9E%84%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="网络构件">网络构件</h1><h2 id="网络结点">网络结点</h2><ul><li><p>被连接的计算机/其他硬件，分两类：</p><ul><li><p>主机（端系统）：传统PC、服务器、 智能手机、传感设备等</p></li><li><p>网络内部交换结点：二层交换机、AP、基站、路由器等</p></li></ul></li></ul><h3 id="网络适配器-网络接口卡">网络适配器 / 网络接口卡</h3><ul><li>将结点连接到链路上的硬件</li><li>实现大部分数据链层，以及物理层功能<ul><li>实现调制编码、组帧、错误检测、可靠传输、介质访问控制等功能</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/JamesYuuu/Picbed/main/image-20231026155435813.png" alt="image-20231026155435813" style="zoom: 67%;" /></p><h2 id="网络链路">网络链路</h2><ul><li>物理层之下的传输媒体，数据（信号）传输的物理通道<ul><li>信号实际上是以光速传播的电磁波</li></ul></li><li>重要属性<ul><li>频率和波长</li></ul></li></ul><h3 id="导引性传输媒体">导引性传输媒体</h3><ul><li>双绞线<ul><li>模拟、数字传输均可</li><li>通信距离几到几十公里，通过放大器、中继器等增大传输距离</li><li>导线越粗，传输距离越远</li><li>根据是否屏蔽<ul><li>屏蔽双绞线 STP (Shielded Twisted Pair)</li><li>无屏蔽双绞线 UTP (Unshielded Twisted Pair)</li></ul></li></ul></li><li>同轴电缆<ul><li>屏蔽性好，抗干扰强</li><li>局域网发展初期曾广泛使用，目前主要用于有线电视网</li></ul></li><li>光缆<ul><li>通过传递光脉冲信号进行通信，有脉冲为1，无脉冲为0，光线在纤芯中传输的方式是不断地全反射</li><li>优点<ul><li>传输损耗小，中继距离长，适合远距离传输</li><li>抗电磁干扰和抗雷电性好</li><li>无串音干扰，保密性好，不易被窃听和截取</li></ul></li><li>广泛应用于互联网、电信网、有线电视网的主干网络，高速局域网</li></ul></li><li>光纤<ul><li>多模光纤<ul><li>可能存在多条不同入射角的光线在一条光纤中传输</li><li>光脉冲传输时会逐渐展宽，失真</li></ul></li><li>单模光纤<ul><li>直径减小到只有一个光的波长，使得光线直线传播，不反射</li></ul></li></ul></li></ul><h3 id="非导引型传输媒体">非导引型传输媒体</h3><ul><li>无线介质<ul><li>发送和接收都通过天线实现的</li><li>发送时，天线将电磁能量发射到介质中（通常是空气）</li><li>接收时，天线从周围的介质中获得电磁波</li></ul></li><li>无线传输两种基本类型<ul><li>定向：发送天线将电磁波聚集成波束发射出去，因此，发送和接收前天线必须仔细校准</li><li>全向：发送信号沿所有方向传播，并能够被多数天线接收到</li></ul></li></ul><h3 id="两种链路类型">两种链路类型</h3><ul><li>点对点链路<ul><li>链路一端的单个发送方和另一端的单个接收方组成</li><li>许多链路层协议为点对点链路设计<ul><li>点对点协议(Point-to-Point Protocol, PPP)</li><li>高级数据链路控制协议 (High-level Data Link Control, HDLC)</li></ul></li></ul></li><li>广播链路（多路访问）<ul><li>能够让多个结点都连接到相同的、单一的、共享的广播信道</li><li>任何结点发送一帧时，所有结点都能接收到</li><li>需要解决媒体共享的问题 (介质接入控制)</li><li>以太网、无线局域网</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据通信的基本概念</title>
      <link href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
      <url>/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="数据通信的基本概念">数据通信的基本概念</h1><h2 id="常用术语">常用术语</h2><ul><li>信息：语音、文字、图像、视频等，通信目的即传送信息</li><li>数据：运送消息的载体，有意义的符号序列</li><li>信号：数据的电气或电磁的表现<ul><li>模拟信号：代表消息的参数的取值是连续的</li><li>数字信号：代表消息的参数的取值是离散的</li></ul></li><li>码元：在使用时域波形表示数字信号时，代表不同离散数值的基本波形<ul><li>如二进制编码常用两种码元，分别代表0状态和1状态</li></ul></li></ul><h2 id="信道相关概念">信道相关概念</h2><ul><li><p>单工通信</p><ul><li>通信双方设备中发送器与接收器分工明确，只能在由发送器向接收器的单一固定方向上传送数据，没有反向交互</li><li>如无线电广播</li></ul></li><li><p>半双工通信</p><ul><li>通信双方设备既是发送器，也是接收器，两台设备可以相互传送数据，但某一时刻则只能向一个方向传送数据</li><li>如总线型以太网、802.11WLAN</li></ul></li><li><p>全双工通信</p><ul><li><p>通信的双方可以同时发送和接收信息，通信双方设备既是发送器，也是接收器，两台设备可以同时在两个方向上传送数据</p></li><li><p>如电话、交换以太网</p></li></ul></li><li><p>基带信号</p><ul><li>来自信源的原始信号，未经过调制（频谱搬移和变换）<ul><li>其特点是频率较低、信号频谱从零频附近开始，具有低通形式</li></ul></li><li>基带信号分为数字基带信号和模拟基带信号</li><li>近距离范围内基带信号的衰减不大，可以采用基带传输<ul><li>计算机到监视器、打印机等外设</li><li>以太网等局域网</li></ul></li><li>长距离或无线信道中，无法直接传输基带信号，需要进行调制<ul><li>比如声音传送距离有限，调制为高频电磁信号，可以实现远距离的声音传送</li></ul></li></ul></li><li><p>编码</p><ul><li>发送端把二进制数据(比特)编码为数字基带信号，接收端再解码为比特</li></ul></li><li><p>调制</p><ul><li>使用载波，把基带信号的频率搬到高频，转换为模拟信号，称为带通调制/载波调制</li><li>目的：<ul><li>将信号变换为便于传送的形式<ul><li>无线传输时需要将信号搬到高频上才能在自由空间发送出去</li><li>数字电话中将连续信号变换为脉冲编码调制信号</li></ul></li><li>有效利用频带</li></ul></li></ul></li></ul><h2 id="编码">编码</h2><ul><li>数字基带信号码型种类繁多，根据码元幅度取值不同分为<ul><li>二元码<ul><li>最简单的波形为矩形，幅度取值只有两种电平</li></ul></li><li>三元码<ul><li>取值正、0、负，单极性变双极性，不是二进制变三进制，称准(伪)三元码</li></ul></li><li>多元码<ul><li>每个符号可以用来表示一个二进制组码，成倍提高带宽利用率</li><li><span class="math inline">\(n\)</span>位二进制组码，可用<spanclass="math inline">\(M=2^n\)</span>元码传输，信道利用率可以提高<spanclass="math inline">\(n\)</span>倍</li></ul></li></ul></li></ul><h3 id="码型设计原则">码型设计原则</h3><ul><li>码型变换过程对任何信源透明，与信源统计特性无关<ul><li>信源统计特性是指信源产生各种数字信息的概率分布</li></ul></li><li>从传输码型容易提取出时钟<ul><li>时钟恢复：编码和解码过程都由一个时钟来驱动，每个时钟周期，发送方发送一比特，接收方恢复一比特，为了使接收方能恢复发送方传送的比特，发送方和接收方的时钟必须精确同步</li></ul></li><li>具有自检能力，即码元间有相关性（冗余度）<ul><li>一旦有了自检性，各码元所含信息量不为最大</li></ul></li><li>误编码增值越小越好</li><li>编译码器简单方便</li><li>编码具有唯一可解性，可还原出原二进制序列</li></ul><h2 id="带通调制-载波调制">带通调制 / 载波调制</h2><ul><li>基本调制方法<ul><li>调幅(AM)：载波的振幅随调制信号而变化</li><li>调频(FM)：载波的频率随调制信号而变化</li><li>调相(PM)：载波的相位随调制信号而变化</li></ul></li><li>两种类型<ul><li>数字信号调制</li><li>模拟信号调制</li></ul></li></ul><h3 id="数字信号调制">数字信号调制</h3><ul><li>二进制数字调制<ul><li>幅度键控：载波的振幅随调制信号而变化（1通，0断）</li><li>频移键控：载波的频率随调制信号而变化（1对应载波<spanclass="math inline">\(f_1\)</span>，0对应载波<spanclass="math inline">\(f_2\)</span>）</li><li>相移键控：载波的相位随调制信号而变化（1对应相位0°，0对应相位180°）</li></ul></li></ul><h3 id="模拟型号调制">模拟型号调制</h3><ul><li>调幅：载波的振幅值随调制信号的大小做线性变化</li></ul><h2 id="信道容量与计算">信道容量与计算</h2><h3 id="实际传输通道">实际传输通道</h3><ul><li>非理想的，在传输信号时会产生各种失真以及带来多种干扰</li><li>码元传输的速率越高，或信号传输的距离越远，在信道的输出端的波形的失真就越严重</li></ul><h3 id="信道容量与香农公式">信道容量与香农公式</h3><ul><li>用信息论的理论推导出了带宽受限且有高斯白噪声干扰情况下信道极限，即无差错的信息传输速率(信道容量)上限</li><li>可应用于各种链路，无线、同轴电缆、光纤……</li></ul><p><span class="math display">\[C = Wlog_2(1+S/N)\]</span></p><ul><li>C：信道容量(bps)；W：信道带宽(Hz)；S：信号平均功率；N：高斯白噪声功率<ul><li>S/N：信噪比，通常表示为SNR(db或分贝)：<spanclass="math inline">\(SNR = 10 log_{10}(S/N)\)</span></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络体系结构</title>
      <link href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
      <url>/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络体系结构">计算机网络体系结构</h1><h2 id="分层的网络体系结构">分层的网络体系结构</h2><h3 id="分层的优点">分层的优点</h3><ul><li>各层互相独立<ul><li>将建造一个网络的问题分解为多个可处理的部分，一层解决一部分问题</li></ul></li><li>灵活性好<ul><li>任何层发生变化时，只要接口不变，上下层都不受影响</li></ul></li><li>结构上可分割开<ul><li>各层都可以采用最合适的技术实现</li></ul></li><li>易于实现和维护</li><li>能促进标准化工作</li></ul><h3 id="理论模型osi参考模型">理论模型（OSI参考模型）</h3><ul><li>20世纪70年代国际标准化组织(ISO)制定</li><li>按网络功能划分为7层</li></ul><figure><imgsrc="https://raw.githubusercontent.com/JamesYuuu/Picbed/main/image-20231026144506042.png"alt="image-20231026144506042" /><figcaption aria-hidden="true">image-20231026144506042</figcaption></figure><h3 id="实际架构tcpip-体系架构">实际架构（TCP/IP 体系架构）</h3><ul><li>ARPANET发展而来，有TCP和IP两个核心的协议</li><li>四层，但不严格的划分层，这样应用可以跨层使用网络</li></ul><p><img src="https://raw.githubusercontent.com/JamesYuuu/Picbed/main/image-20231026144827300.png" alt="image-20231026144827300" style="zoom: 67%;" /></p><ul><li>细腰结构是网络体系结构模型中最典型的特征<ul><li>IP 可应用在各式各样的网络上</li><li>各式各样的应用可以承载在IP 之上</li></ul></li><li>分层模型中的相关概念<ul><li>实体：任何可以发送或接受信息的硬件或软件进程</li><li>对等实体：位于不同系统中的同一层内相互交互的实体</li><li>网络协议：为进行网络中的数据交换建立的规则、标准或约定，控制两个对等实体进行通信的规则的集合</li><li>服务：由下层向上层通过层间接口提供</li><li>服务接口：同一系统内相邻两层的实体进行交互的地方，成为服务访问点（SAP）<imgsrc="https://raw.githubusercontent.com/JamesYuuu/Picbed/main/image-20231026145800273.png"alt="image-20231026145800273" /></li><li>数据传输通道<ul><li>数据发送都是由上层传到下层，接收则由下层传到上层</li><li>层间是虚通信，最下层是实际通信</li></ul></li><li>多路复用/多路分解<ul><li>发送端多个高层会话复用一条底层连接，在接收端再进行分解</li><li>逐层进行封装和解封</li></ul></li></ul></li></ul><figure><imgsrc="https://raw.githubusercontent.com/JamesYuuu/Picbed/main/image-20231026150432168.png"alt="image-20231026150432168" /><figcaption aria-hidden="true">image-20231026150432168</figcaption></figure>]]></content>
      
      
      <categories>
          
          <category> Study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络的性能</title>
      <link href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E6%80%A7%E8%83%BD/"/>
      <url>/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E6%80%A7%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络的性能">计算机网络的性能</h1><h2 id="速率比特率">速率/比特率</h2><ul><li>比特是计算机中数据量的单位<ul><li>1bit即1个二进制数字（0或1）</li></ul></li><li>网络技术中的数据率即数字信道上的传送数据的速率</li><li>单位（b/s）</li></ul><h2 id="带宽">带宽</h2><ul><li>计算机网络中，带宽即数字信道所能传送到的最高数据率</li><li>网络的带宽：在一段特定的时间内网络所能传送的比特数<ul><li>以特定带宽传送的比特可以看作有一定的宽度</li></ul></li></ul><h2 id="吞吐量">吞吐量</h2><ul><li><p>吞吐量即单位时间内通过某个网络（或信道、接口）的数据量</p></li><li><p>带宽和吞吐量</p><ul><li>带宽一般指链路上每秒能传输的比特数</li><li>吞吐量表示系统的测量性能，即每秒实际传输的比特</li></ul></li><li><p>计算：Throughput = Transfer_size / Transfer_time</p><ul><li>Transfer_time = RTT + (1/Bandwidth) * Transfer_size<ul><li>发请求并返回数据的时间 RTT</li><li>把数据传到网上的时间</li></ul></li><li>传输更大量的数据有助于提高吞吐量<ul><li>当数据量趋于无限大时，吞吐量将接近网络带宽 ## 时延/延迟</li></ul></li></ul></li><li><p>时延：数据从网络的一端传送到另一端所花费的时间</p></li><li><p>往返时间（RTT）：数据从网络的一端传到另一端并返回所花费的时间</p></li><li><p>时延由四部分组成</p><ul><li>发送时延：发送数据时，数据块从结点进入到传输介质所需要的时间<ul><li>发送时延 = 数据块长度 / 发送速率</li></ul></li><li>传播时延：电磁波在信道中需要传播一定的距离而花费的时间<ul><li>不同介质的信道中传播的速度不同（光纤 <spanclass="math inline">\(2\times10^8m/s\)</span>，电缆<spanclass="math inline">\(2.3\times10^8m/s\)</span></li><li>传播时延 = 信道长度 / 信号在信道上的传播速率</li></ul></li><li>处理时延：主机或路由器在收到分组时进行一些必要的处理所花费的时间<ul><li>比如分析分组首部、差错检验、查找路由</li></ul></li><li>排队时延：结点在队列中等待产生的时延</li></ul></li><li><p>注意：</p><ul><li><p>我们能提高的是数据的发送速率，而不是数据在链路中传输的速率</p></li><li><p>提高链路带宽可以降低数据的发送时延</p></li></ul></li></ul><h2 id="时延带宽积">时延带宽积</h2><ul><li>时延带宽积 = 时延 * 带宽，即以比特为单位的链路长度</li><li>代表了第一个比特到达终点时，发送端发出的尚未达到接收端的比特数</li></ul>]]></content>
      
      
      <categories>
          
          <category> Study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Internet的组成</title>
      <link href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Internet%E7%9A%84%E7%BB%84%E6%88%90/"/>
      <url>/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Internet%E7%9A%84%E7%BB%84%E6%88%90/</url>
      
        <content type="html"><![CDATA[<h1 id="internet的组成">Internet的组成</h1><h2 id="端系统">端系统</h2><h3 id="端系统的概念">端系统的概念</h3><ul><li>连接在因特网上的所有主机，运行应用程序</li><li>主机之间的通信，即主机A的某个进程（运行着的程序）和主机B上的另一个进程进行通信</li></ul><h3 id="端系统间的通信方式">端系统间的通信方式</h3><ul><li>客户-服务器方式（Client/Server）<ul><li>基本概念<ul><li>描述的是进程之间服务和被服务的关系</li><li>客户和服务器指通信中涉及的两个应用进程</li><li>客户是服务的请求方，服务器是服务的提供方</li></ul></li><li>客户端<ul><li>被用户调用后运行，打算通信时主动向远地服务器发起通信（请求服务），必须知道服务器程序的地址</li><li>不需要特殊的硬件和复杂的操作系统</li></ul></li><li>客户端<ul><li>专门用来提供某种服务的程序，可同时处理多个远地或本地客户的请求</li><li>系统启动后即自动调用并一直不断地运行着，被动地等待并接受来自各地的客户的通信请求，不需要知道客户程序的地址</li><li>一般需要强大的硬件和高级的操作系统支持</li></ul></li></ul></li><li>对等方式（P2P，Peer-to-Peer）<ul><li>两个主机通信时，不区分服务请求方，还是服务提供方，进行平等和对等的连接通信</li><li>本质上仍然是使用客户服务器方式，只是对等连接中的每一个主机既是服务器又是客户</li></ul></li></ul><h2 id="接入网">接入网</h2><ul><li>将端系统连接到边缘路由器的物理链路<ul><li>边缘路由器是端系统到任何其它远程系统的路径上的第一台路由器</li></ul></li><li>使用接入网的集中环境<ul><li>家庭接入<ul><li>数字用户线（基于电话线路）</li><li>电缆</li><li>光纤到户（FTTH）</li><li>拨号</li><li>卫星</li></ul></li><li>企业接入<ul><li>局域网 LAN 接入</li><li>无线局域网接入</li></ul></li><li>广域无线网络接入（4G/5G）</li></ul></li></ul><h2 id="网络核心">网络核心</h2><ul><li>Internet网络核心组成<ul><li>十多个第一层ISP和数十万个较低层ISP组成</li><li>内容提供商也创建自己的网络，直接在可能的地方与ISP互联</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络的起源与发展</title>
      <link href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E8%B5%B7%E6%BA%90%E5%92%8C%E5%8F%91%E5%B1%95/"/>
      <url>/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E8%B5%B7%E6%BA%90%E5%92%8C%E5%8F%91%E5%B1%95/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络的起源与发展">计算机网络的起源与发展</h1><h2 id="电路交换">电路交换</h2><blockquote><p>传统的电路交换的电信网生存性和容错性弱</p></blockquote><h3 id="电路交换的特点">电路交换的特点</h3><ul><li><p>面向连接</p></li><li><p>必须经过以下三个步骤</p><ul><li>建立连接（占用通信资源）</li><li>通话（始终占用通信资源）</li><li>释放连接（归还通信资源）</li></ul></li></ul><h3 id="电路交换的缺点">电路交换的缺点</h3><ul><li>电路交换方式传送计算机数据效率低<ul><li>计算机数据具有突发性<ul><li>传送数据的时间不到10%，甚至低于1%</li></ul></li><li>面向连接的方式进行传输导致资源浪费<ul><li>被占用的通信线路绝大部分时间都是空闲的</li></ul></li></ul></li></ul><h2 id="分组交换">分组交换</h2><h3 id="分组交换的原理">分组交换的原理</h3><ul><li>发送端<ul><li>把较长的报文划分成较短的、固定长度的数据段</li><li>每一个数据段前面添加上<strong>首部</strong>构成<strong>分组</strong><ul><li>分组是互联网中传送的数据单元</li><li>每个首部都包含地址等控制信息</li></ul></li><li>以此把各分组发送出去</li></ul></li><li>中间节点：通过存储转发的形式将分组逐跳转发至目的地<ul><li>中间结点即分组交换网中的分组交换机<ul><li>专门负责转发分组的计算机（路由器、二层交换机等）</li></ul></li><li>每个分组交换机根据收到的分组的首部中的地址信息，把分组转发到下一个交换机<ul><li>以存储转发的方式</li></ul></li><li>一个分组经历的一系列分组交换机和通信链路称为通过该网络的路径</li></ul></li><li>接收端<ul><li>收到分组之后剥去分组的首部，把数据恢复成为原来的报文</li></ul></li></ul><h3 id="分组交换的优点">分组交换的优点</h3><ul><li>高效<ul><li>动态分配传输带宽，对通信链路逐段占用，充分使用链路的带宽</li></ul></li><li>灵活<ul><li>以分组为单位，查找路由和传送</li></ul></li><li>迅速<ul><li>不必先建立连接就能向其他主机发送分组</li></ul></li><li>可靠<ul><li>自适应的路由选择，使网络有很好的生存性</li></ul></li></ul><h3 id="分组交换的缺点">分组交换的缺点</h3><ul><li>时延<ul><li>处理时延：逐跳决策，每个中间结点都需要进行路由查找</li><li>排队时延：分组在各结点存储转发时需要排队</li></ul></li><li>附加开销<ul><li>分组必须携带报头（首部），造成一定开销</li></ul></li></ul><h2 id="交换技术的比较">交换技术的比较</h2><h3 id="电路交换-1">电路交换</h3><ul><li>面向连接，报文的比特流连续地从源到终点，像在一个管道中传输</li></ul><h3 id="报文交换">报文交换</h3><ul><li>在电报通信是采用，同样是基于存储转发原理</li><li>整个报文先传送到相邻节点，全部存储下来后查找转发表，转发到下一个结点</li></ul><h3 id="分组交换-1">分组交换</h3><ul><li>单个分组（整个报文的一部分）传送到相邻结点，存储下来后查找转发表，转发到下一结点</li></ul><figure><imgsrc="https://raw.githubusercontent.com/JamesYuuu/Picbed/main/image-20231022162120896.png"alt="image-20231022162120896" /><figcaption aria-hidden="true">image-20231022162120896</figcaption></figure><h2 id="互联网概述">互联网概述</h2><h3 id="基本概念">基本概念</h3><ul><li>链路<ul><li>物理直连介质：同轴电缆、双绞线、光纤、无线电频谱等</li><li>网络连通有不同的层次，最底层的是一个或多个计算机通过物理介质直连</li></ul></li><li>结点<ul><li>被连接的计算机/其他硬件<ul><li>主机（端系统）：PC、服务器、智能手机、智能家电、传感器等</li><li>网络内部交换结点：交换机、AP、基站、路由器等</li></ul></li></ul></li><li>云形图<ul><li>计算机网络中重要的图标，表示任意类型的网络</li><li>将网络的内部结点与使用网络的外部结点分开</li></ul></li><li>直连链路<ul><li>所有的结点都是直连的</li></ul></li><li>交换网络<ul><li>若干结点和链路组成，主机间接连通</li><li>主机：支持用户运行应用程序</li><li>交换结点：存储和转发分组</li></ul></li><li>互联网<ul><li>网络的网络，路由器将网络和网络互连</li><li>网络可以由网络的嵌套组成<ul><li>通过将云互联成更大的云，递归构建任意大的网络</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WAFL与系统安全</title>
      <link href="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/WAFL%E4%B8%8E%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8/"/>
      <url>/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/WAFL%E4%B8%8E%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="wafl-netapp的文件服务器">WAFL —— NetApp的文件服务器</h1><blockquote><p>WAFL：Write Anywhere File Layout —— NetApp 设计的企业级文件系统</p></blockquote><ol type="1"><li>设计目标<ul><li>请求服务速度快：吞吐率(op/s)更多，I/O带宽更高</li><li>支持大文件系统，且文件系统不断增长</li><li>高性能软件RAID</li><li>宕机后快速恢复</li></ul></li><li>独特之处<ul><li>磁盘布局受 LFS 启发</li><li>引入快照</li><li>使用 NVRAM 记录日志（写前日志）</li></ul></li></ol><h2 id="inode间址块和数据块">inode、间址块和数据块</h2><ol type="1"><li>WAFL 使用4KB块<ul><li>inode：借鉴 UNIX FS</li><li>16个指针（64B）用于文件块索引</li></ul></li><li>文件大小 &lt;= 64B<ul><li>文件数据直接存储在 inode中</li></ul></li><li>文件大小 &lt;= 64KB<ul><li>inode存储在16个指向数据块的指针</li></ul></li><li>文件大小 &lt;= 64MB<ul><li>inode存储在16个指向间址块的指针</li><li>每个间址块存储1024个指向数据块的指针</li></ul></li><li>文件大小 &gt; 64MB<ul><li>inode存储在16个指向二级间址块的指针</li></ul></li></ol><h2 id="wafl的磁盘布局">WAFL的磁盘布局</h2><ol type="1"><li>主要数据结构<ul><li>一个根 inode：整个FS的根，位于磁盘上固定位置</li><li>一个inode file：包含所有inode</li><li>一个block map file：指示所有空闲块</li><li>一个i-node map file：指示所有空闲inode</li></ul></li></ol><h3 id="为什么将元数据存储于文件中">为什么将元数据存储于文件中？</h3><ol type="1"><li>元数据块可以写在磁盘上任何位置<ul><li>这是"WAFL"名字的由来，Write Anywhere File Layout</li></ul></li><li>使得动态增加文件系统的大小变得容易<ul><li>增加一个磁盘会引发inode个数的增加</li><li>inode保存在文件，扩展inode文件大小即可</li></ul></li><li>能够通过 Copy-on-Write 来创建快照<ul><li>COW：未写前共享数据，写时拷贝</li><li>新的数据和元数据都可以COW写到磁盘上的新位置</li><li>固定元数据位置无法使用COW，否则无法定位元数据</li></ul></li></ol><h2 id="快照snapshot">快照（snapshot）</h2><ol type="1"><li>快照是文件系统的一个只读版本 – 1993 年提出<ul><li>成为文件服务器必备特性</li></ul></li><li>快照用法<ul><li>系统管理员配置快照的个数和频率</li><li>最初系统能支持 20 个快照</li><li>用快照可以恢复其中任何一个文件</li></ul></li></ol><h3 id="快照的实现">快照的实现</h3><blockquote><p>WAFL：所有的块构成一棵树</p></blockquote><ol type="1"><li>创建快照<ul><li>复制根 inode</li><li>新的根 inode 用于当前的 Active FS</li><li>旧的根 inode 指向快照</li></ul></li><li>创建快照之后<ul><li>第一次写一个块: 把从它到根的数据块都复制（COW）</li><li>Active FS 的根 inode 指向新数据块</li><li>写数据块</li><li>后续对这些数据块的写不再触发 COW</li></ul></li><li>每个快照都是一个一致状态的只读 FS</li></ol><h3 id="快照数据结构">快照数据结构</h3><blockquote><p>Block Map File —— 每个 4KB 磁盘块对应一个 32位的表项</p></blockquote><ol type="1"><li>表项值为0：该块为空闲块</li><li>第0位=1：该块属于活动文件系统</li><li>第1位=1：该块属于第一个快照</li><li>第2位=1：该块属于第二个快照</li></ol><p>...</p><h3 id="快照创建">快照创建</h3><ol type="1"><li>问题<ul><li>创建快照时，除了拷贝根inode，需要把缓存的文件块写回磁盘</li><li>此时，可能仍然有很多文件写请求到来</li><li>若这些写请求都不处理，会导致文件系统长时间挂起</li></ul></li><li>WAFL的解决方案<ul><li>在创建快照前，将块缓存中的脏块标记为"in-snapshot"，表示要写回磁盘</li><li>所有对"in-snapshot"缓存块的修改请求被挂起</li><li>没有标记为"in-snapshot"的缓存数据可以修改（即处理写请求），但不能写回磁盘</li><li>本质：区分需要被写回的脏块和其他块，减少挂起的写请求数量</li><li>步骤<ul><li>为所有"in-snapshot"的缓存块分配磁盘空间<ul><li>包括数据、inode</li></ul></li><li>更新 block map file<ul><li>对每个表项，将 Active FS位的值（即1）拷贝到新快照位</li></ul></li><li>刷回<ul><li>把所有的"in-snapshot"缓存块写到它们新的磁盘位置</li><li>每写回一个块，重启它上面被挂起文件请求</li></ul></li><li>复制根inode</li></ul></li><li>性能较快</li></ul></li></ol><h3 id="快照删除">快照删除</h3><ol type="1"><li>删除快照的根inode</li><li>清除block map file中的位<ul><li>对于block map file的每一个表项，清除与该快照对应的位</li></ul></li></ol><h2 id="文件系统一致性">文件系统一致性</h2><ol type="1"><li>定期创建一致点<ul><li>一致点：存储控制器中使用 NVRAM缓存的数据被刷回磁盘，并更新了文件系统中相应的指针</li><li>每10秒创建一个一致点</li><li>特殊的内部快照，用户不可见</li></ul></li><li>在一致点之间的多个请求<ul><li>第i个一致点</li><li>若干写操作</li><li>第 i+1 个一致点（自动增长）</li><li>若干写操作</li><li>...</li></ul></li><li>宕机恢复<ul><li>将文件系统恢复到最后一个一致点</li><li>最后一个一致点之后到宕机前的写操作：靠日志进行恢复</li></ul></li></ol><h2 id="非易失ramnon-volatile-ram">非易失RAM（Non-Volatile RAM）</h2><ol type="1"><li>NVRAM<ul><li>闪存：写比较慢 vs NVRAM</li><li>带电池的 DRAM：快<ul><li>电池容量有限，持续时间不长</li><li>DRAM容量有限</li></ul></li></ul></li><li>日志写入 NVRAM<ul><li>记录自上一个一致点以来的所有写请求</li><li>正常关机：先停止 NFS 服务，再创建一个快照，然后关闭 NVRAM</li><li>宕机恢复：用 NVRAM 中的日志来恢复从最后一个一致点以后的修改</li></ul></li><li>使用两个日志<ul><li>一个日志写回磁盘时，另一个日志写入 NVRAM 中缓冲</li><li>可以避免写日志时，无法处理新的写请求</li></ul></li></ol><h1 id="安全保护">安全保护</h1><h2 id="安全与保护">安全与保护</h2><ol type="1"><li>数据机密性：未经许可，不能看到数据<ul><li>任何用户不能读写其他用户的文件</li></ul></li><li>数据完整性：未经许可，不能修改或删除数据<ul><li>数据在网络传输过程中被拦截和修改，可以采用加密</li></ul></li><li>系统可用性：干扰系统使得它不可用<ul><li>给一个服务器发送大量的请求</li></ul></li></ol><h2 id="保护策略与机制">保护：策略与机制</h2><ol type="1"><li>安全策略：定义目标，即要达到的效果<ul><li>通常是一组规则，定义可接受的行为和不可接受的行为</li><li>例子<ul><li>/etc/password 文件只有 root 能写</li><li>每个用户最多只能用 50GB 的磁盘空间</li><li>任何用户都不允许读其他用户的 mail 文件</li></ul></li></ul></li><li>机制：用什么样的方法来达到目标</li></ol><h2 id="保护机制">保护机制</h2><ol type="1"><li>Authentication（身份认证）<ul><li>验明身份<ul><li>UNIX：密码/口令</li><li>类比机场：身份证或护照</li></ul></li></ul></li><li>Authorization（授权）<ul><li>决定"A是不是准许做某件事"</li><li>通常使用角色（role）定义授予的操作权限，使用简单的数据库保存角色定义</li></ul></li><li>Admission Control（访问控制）<ul><li>做出“访问是否准许”的决定</li><li>有时和系统承载压力相关联，系统负载高时，进行访问控制</li></ul></li></ol><h3 id="身份认证">身份认证</h3><ol type="1"><li>通常是用密码来验证<ul><li>一串字符（字母 + 数字）</li><li>用户必须记住密码</li></ul></li><li>密码是以加密形式存储<ul><li>使用一种单向的“安全Hash”算法</li></ul></li><li>缺点<ul><li>每个用户都要记很多密码</li><li>弱密码风险，"dictionary attack"</li></ul></li></ol><h3 id="访问控制表acl">访问控制表（ACL）</h3><ol type="1"><li>每个对象有一个 ACL 表<ul><li>定义每个用户的权限</li><li>每个表项为 &lt;user,privilege&gt;</li></ul></li><li>简单，大多数系统都采用<ul><li>UNIX 的 owner,group,other</li></ul></li><li>实现<ul><li>ACL 实现在内核中</li><li>在登录系统时进行身份验证</li><li>ACL 存储在每个文件中或文件元数据中</li><li>打开文件时检查 ACL</li></ul></li></ol><h3 id="capabilities">Capabilities</h3><ol type="1"><li>超级用户具有特权，可以执行高权限操作<ul><li>例如passwd,chown,chmod等</li></ul></li><li>权能：将超级用户特权细分，分成不同的、细粒度权限<ul><li>CAP_CHOWN: 对文件 UIDs 和 GIDs 做修改</li><li>CAP_KILL: 绕过发送信号时的权限检查</li><li>CAP_NET_ADMIN: 执行多种网络有关的操作</li></ul></li><li>可以为每个线程独立设置权能</li><li>实现<ul><li>权能表保存在内核</li></ul></li></ol><h3 id="访问控制">访问控制</h3><ol type="1"><li>需要一个可信权威<ul><li>进行访问控制</li><li>ACL或权能表都需要保护</li></ul></li><li>内核是一个可信权威<ul><li>内核什么事可以做</li><li>如果有 bug ，整个系统都可能被破坏</li><li>它越小、越简单越好</li></ul></li><li>安全的强度由保护系统链上最薄弱的环节决定</li></ol><h3 id="一些简单的攻击">一些简单的攻击</h3><ol type="1"><li>滥用合法权利<ul><li>UNIX: root能做任何事情<ul><li>例如：读你的 mail 文件, 以你的身份发送email, 把你的邮箱删除,...</li></ul></li></ul></li><li>拒绝服务（DoS）<ul><li>耗尽系统所有资源</li><li>例如<ul><li>运行一个 shell脚本：<code>while (1) &#123;mkdir foo; cd foo;&#125;</code></li><li>运行一个 C程序：<code>while (1) &#123;fork(); malloc(1000)[40]=1;&#125;</code></li></ul></li></ul></li><li>偷听<ul><li>侦听网络上传输的包</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> Study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件系统可靠性</title>
      <link href="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%8F%AF%E9%9D%A0%E6%80%A7/"/>
      <url>/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%8F%AF%E9%9D%A0%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="数据备份">数据备份</h1><ol type="1"><li>FS要求<ul><li>FS给用户提供持久化的数据存储</li><li>文件一直要保存完好，除非用户显式删除它们</li></ul></li><li>威胁一：设备损坏<ul><li>磁盘块损坏</li><li>Superblock损坏：整个FS丢失</li><li>bitmap、inode table损坏：无法管理空间和inode</li><li>数据块损坏：目录、文件、间址块都无法读写</li></ul></li></ol><h2 id="备份与恢复">备份与恢复</h2><ol type="1"><li>物理备份与恢复：设备级<ul><li>将磁盘块逐一拷贝到另一个磁盘上（备份盘）</li><li>全复制：原始盘与备份盘在物理上一模一样</li><li>增量备份：只拷贝发生变化的块，与上次备份相比</li><li>例如：使用<code>dd</code>进行磁盘备份</li></ul></li><li>逻辑备份与恢复：文件系统级<ul><li>遍历文件系统目录树，从根目录开始</li><li>把指定的目录和文件拷贝到备份磁盘</li><li>在备份过程中验证文件系统结构</li><li>恢复时可以将指定的文件或目录树恢复出来</li><li>也有两种方式<ul><li>全备份：备份整个文件系统</li><li>增量备份：只备份发生变化的文件/目录</li></ul></li></ul></li></ol><h3 id="物理备份-vs-逻辑备份">物理备份 vs 逻辑备份</h3><ol type="1"><li>物理备份<ul><li>忽略文件和文件系统结构，处理过程简洁，备份性能高</li><li>文件修改时只用备份修改的数据块，不用备份整个文件</li><li>不受文件系统限制</li></ul></li><li>逻辑备份<ul><li>备份文件时，文件块可能分散在磁盘上，备份性能受影响</li><li>文件修改时需要备份整个文件</li><li>受文件系统限制，按文件粒度备份，保证完整性</li></ul></li></ol><h1 id="宕机一致性保证">宕机一致性保证</h1><ol type="1"><li>威胁二：宕机或掉电<ul><li>硬件掉电</li><li>软件bugs导致宕机：驱动或文件系统bug</li><li>导致文件缓存中的脏数据没有写回磁盘：目录块、inode、间址块、数据块</li></ul></li><li>挑战<ul><li>宕机可能发生在任意时刻</li><li>在性能与可靠性之间进行取舍<ul><li>宕机使得内存中的数据全部丢失</li><li>缓存越多的数据 -&gt; 性能越好</li><li>缓存越多的数据 -&gt; 宕机时丢失的数据越多</li></ul></li><li>一个文件写操作往往修改多个块<ul><li>磁盘只能保证原子写一个扇区</li><li>如何保证修改多个块的原子性？</li></ul></li></ul></li></ol><h2 id="宕机的影响">宕机的影响</h2><ol type="1"><li>创建文件：在当前目录 /home/xj 下创建文件 testfile<ul><li>需写回4个块，在磁盘不同位置<ul><li>inode bitmap</li><li>文件inode</li><li>目录块：含目录项&lt;"testfile", ino&gt;</li><li>目录inode：修改size，mtime等</li></ul></li><li>宕机时，没有全部写回 -&gt; FS不一致<ul><li>写回顺序可能是任意的</li><li>目录块没写回：有inode，没目录项</li><li>文件inode没写回：有目录项，没inode</li></ul></li></ul></li><li>写文件：在 /home/xj/testfile 末尾写入一个数据块（Append）<ul><li>需写回3个块，在磁盘的不同位置<ul><li>文件inode：修改size，mtime等</li><li>data-block bitmap</li><li>数据块本身</li></ul></li><li>宕机时，没有全部写回 -&gt; FS不一致 &amp; 数据与元数据不一致<ul><li>写回顺序可能是任意的</li><li>FS不一致：文件inode 和 data-block bitmap 中有一个没写回</li><li>数据与元数据不一致：文件inode 和 数据块没有都写回</li></ul></li></ul></li><li>写回方案一：先写元数据、后写数据（同上例）<ul><li>路径解析"/home/xj/testfile" || 宕机 -&gt; 数据与元数据一致</li><li>分配数据块，写bitmap || 宕机 -&gt;数据与元数据一致（FS不一致，有垃圾块）</li><li>写inode（直接指针、大小等） || 宕机 -&gt; 数据与元数据不一致</li><li>写数据块 || 宕机 -&gt; 数据与元数据一致</li></ul></li></ol><blockquote><p>先写元数据，宕机后可能出现数据与元数据不一致</p></blockquote><ol start="4" type="1"><li>写回方案二：先写数据、后写元数据（同上例）<ul><li>路径解析"/home/xj/testfile" || 宕机 -&gt; 数据与元数据一致</li><li>分配数据块，写bitmap || 宕机 -&gt;数据与元数据一致（FS不一致，有垃圾块）</li><li>写数据块 || 宕机 -&gt; 数据与元数据一致</li><li>写inode（直接指针、大小等） || 宕机 -&gt; 数据与元数据一致</li></ul></li></ol><blockquote><p>先写数据，宕机后可能i-node指向旧版本，但数据与元数据是一致的</p></blockquote><h2 id="宕机一致性保证-1">宕机一致性保证</h2><h3 id="宕机一致性的分类">宕机一致性的分类</h3><ol type="1"><li>FS一致性<ul><li>文件系统自身的数据结构（称为FS元数据）一致<ul><li>Superblock,bitmap(inode和data)，inode，目录项</li><li>可能导致FS不一致：修改多个元数据的操作<ul><li>创建/删除文件、创建/删除目录、重命名、硬链接、符号链接、...</li><li>写文件</li></ul></li></ul></li></ul></li><li>数据与元数据一致性<ul><li>文件元数据（inode和间址块）和文件块一致</li><li>数据与元数据不一致：写文件</li></ul></li><li>数据一致性<ul><li>一次写多个数据块</li><li>数据不一致：写文件</li></ul></li><li>宕机一致性保证<ul><li>一个操作包含多个修改：要么全部写到磁盘，要么都没写到磁盘</li></ul></li></ol><h3 id="宕机一致性的总结">宕机一致性的总结</h3><ol type="1"><li>通用方法：按自底向上顺序进行修改（Ordered Write）<ul><li>文件的数据块 -&gt; 文件的inode -&gt; 目录的数据块 -&gt; 目录的inode<ul><li>写回所有的数据块（有文件缓存）</li><li>修改文件的inode，并把它写回磁盘</li><li>修改目录块（目录项），并把它写回磁盘</li><li>修改目录的inode，并把它写回磁盘</li><li>沿路径向上，直到无修改的目录</li></ul></li></ul></li><li>不足<ul><li>宕机后仍然可能产生垃圾块（FS不一致），也可能有目录和文件不一致（文件修改了，目录没有改）</li><li>FS不一致可以通过运行一致性检查工具（例如fsck）清理垃圾块</li></ul></li><li>理想情况<ul><li>保证一致性的修改，而且不留下垃圾块</li><li>三个一致性保证</li></ul></li></ol><h3 id="fsckunix-fs一致性检查工具">fsck：Unix FS一致性检查工具</h3><ol type="1"><li>检查并试图恢复FS的一致性<ul><li>不能解决所有问题，比如数据与元数据不一致</li></ul></li><li>检查Superblock<ul><li>如果fs size &lt; 已分配块，认为它损坏，切换到另一个 Superblock副本</li></ul></li><li>检查块位图<ul><li>重构已使用块信息：扫描磁盘上所有的 inode 和间址块</li></ul></li><li>检查 inode 位图<ul><li>重构已使用 inode 信息：扫描磁盘上所有目录的目录项</li></ul></li><li>检查 inode<ul><li>通过 type 域的值（普通文件，目录，符号链接）来判断 inode是否损坏</li><li>如果损坏，则清除该 inode 及它对应的 bitmap 位</li></ul></li><li>检查 nlink 域<ul><li>遍历 FS的整个目录树，重新计算每个文件的链接数（即指向它的目录项个数）</li><li>没有目录项指向的 inode ，放到 lost+found 目录下</li></ul></li><li>检查数据块冲突<ul><li>是否有两个(或更多)的 inode 指向同一数据块</li><li>如果有 inode 损坏，则清理 inode，否则把该数据块复制一份</li></ul></li><li>检查数据块指针<ul><li>指针是否越界(&gt; 磁盘分区大小)</li><li>删除该指针</li></ul></li><li>不足<ul><li>恢复时间与 FS 大小成正比<ul><li>即使只修复几个块，也需要扫描整个磁盘和遍历 FS 目录树</li><li>会导致丢数据：inode 损坏、数据块或间址块损坏</li></ul></li></ul></li></ol><h1 id="事务和日志文件系统">事务和日志文件系统</h1><blockquote><p>事务：一组操作，需要具有原子性 ——要么所有操作都成功完成，要么一个操作也不曾执行过</p></blockquote><h2 id="事务的应用-write-ahead-log写前日志">事务的应用 —— Write-AheadLog（写前日志）</h2><ol type="1"><li>写前日志<ul><li>在实际进行写操作前，先把写操作记日志</li><li>记录日志时使用事务</li></ul></li><li>前提<ul><li>日志中记录的所有修改必须是幂等的</li><li>每个事务有唯一的编号 TID</li><li>必须有办法确认写磁盘完成<ul><li>TxB 和 日志记录可以同时发给磁盘，TxE最后发送，使用 WriteBarrier</li><li>使用 fsync 保证写盘完成</li></ul></li></ul></li></ol><h3 id="具体步骤">具体步骤</h3><ol type="1"><li>Begin Transaction（开始事务）<ul><li>开始一条日志项，写一个日志开始标记 TxB，标明一个事务开始</li></ul></li><li>事务中的修改<ul><li>所有修改都写日志</li><li>事务日志中需要标明事务编号 TID</li></ul></li><li>Commit（提交事务）<ul><li>写一个日志结束标记 TxE，标明一个事务成功完成</li></ul></li><li>Checkpoint（检查点）<ul><li>Commit 之后，把该事务中的修改全部写到磁盘上</li></ul></li><li>清除日志<ul><li>Checkpoint 写完后，清除相应的日志项</li></ul></li></ol><h3 id="宕机恢复replay">宕机恢复（Replay）</h3><ol type="1"><li>宕机后扫描写前日志中的日志项，对于每条日志项<ul><li>如果磁盘上只有日志开始标记 TxB，没有结束日志 TxE，则什么也不做</li><li>如果日志项是完整的（同时有 TxB 和 TxE），则按日志重做（RedoLog），然后再清除日志</li></ul></li><li>前提假设<ul><li>写到磁盘上的日志数据都是正确的</li><li>宕机后没有磁盘损坏</li></ul></li></ol><h2 id="日志文件系统journaling-file-system">日志文件系统（JournalingFile System）</h2><ol type="1"><li><p>用写前日志来记录所有写操作</p><ul><li>创建/删除文件、创建/删除目录、重命名、硬链接、符号链接...</li><li>写文件</li></ul></li><li><p>第一个日志文件系统：Cedar FS[1987]</p></li><li><p>很多商用文件系统都使用写前日志：NTFS、JFS、XFS、Linuxex2/3/4...</p></li><li><p>宕机恢复</p><ul><li>按日志重做一遍</li><li>简单、高效<ul><li>恢复时间与日志大小成正比</li></ul></li><li>日志必须是等幂的</li></ul></li></ol><h3id="日志文件系统数据日志data-journaling">日志文件系统：数据日志（datajournaling）</h3><ol type="1"><li>记录所有修改的日志：数据 &amp; 元数据</li><li>例如：在一个文件末尾追加一个数据块<ul><li>修改文件的inode，修改bitmap，写数据块</li></ul></li><li>流程<ul><li>写日志：TxB、inode日志、bitmap日志、数据块日志</li><li>提交日志 commit：写 TxE</li><li>Checkpoint：实际修改磁盘上的inode、bitmap、数据块</li><li>清除日志</li></ul></li><li>日志开销<ul><li>所有数据块写两次磁盘</li></ul></li></ol><h3id="日志文件系统元数据日志metadata-journaling">日志文件系统：元数据日志（metadatajournaling）</h3><ol type="1"><li>只记录元数据的修改的日志</li><li>例如：在一个文件末尾追加一个数据块<ul><li>修改文件的inode，修改bitmap，写数据块</li></ul></li><li>流程<ul><li>写数据块</li><li>写日志：TxB、inode日志、bitmap日志</li><li>提交日志 commit：写 TxE</li><li>Checkpoint：实际修改磁盘上的inode、bitmap</li><li>清除日志</li></ul></li><li>日志开销<ul><li>只有元数据写两次磁盘，所有数据块只写一次磁盘</li></ul></li></ol><h3 id="日志文件系统总结">日志文件系统总结</h3><ol type="1"><li>性能问题<ul><li>增加额外的写磁盘开销：每个日志都要同步写磁盘（fsync）</li><li>写放大<ul><li>即使只修改一个块中少量内容（十几字节），也需要写日志</li><li>Bitmap中一个bit修改，也要对bitmap block写日志</li></ul></li></ul></li><li>改进办法<ul><li>批量写日志：以牺牲可靠性换取性能<ul><li>宕机仍然可能丢数据，但不会损坏FS一致性</li><li>例如，再同一个目录下创建和写入多个文件</li></ul></li><li>用 NVRAM 来保存日志，实现快速同步写</li></ul></li><li>可靠性<ul><li>无法应对硬件故障，比如磁盘扇区坏</li></ul></li><li>日志管理<ul><li>需要多大的日志？<ul><li>日志只在宕机恢复时需要</li><li>日志过小，很快占满日志空间，无法接受新日志</li><li>日志过大，导致恢复时间长</li></ul></li><li>方法<ul><li>顺序地、Append-only 写，循环使用日志空间（Circular Log）</li><li>定期做 checkpoint ：把缓存里的修改内容刷回磁盘</li><li>checkpoint 之后，可以释放日志所占空间</li></ul></li></ul></li></ol><h1id="日志结构文件系统lfs-log-structured-file-system">日志结构文件系统（LFS—— Log-Structured File System）</h1><ol type="1"><li>思想<ul><li>想写日志那样顺序地写磁盘</li></ul></li><li>具体机制<ul><li>每次写文件块写到新位置（日志末尾）：out-of-place update（vs in-placeupdate）</li><li>不需要 bitmap 来管理空闲空间</li><li>文件块采用多级索引（同FFS）：文件块位置记录在 inode中</li><li>每次写文件采用一致性修改：先写文件块，再写inode</li></ul></li><li>大粒度顺序写<ul><li>起因：小粒度写不能发挥磁盘带宽</li><li>Segment：大粒度的内存 buffer<ul><li>缓存多个写，一次把整个 Segment 写回磁盘</li><li>写回时仍然遵循 先写文件块，再写inode 的原则</li></ul></li></ul></li></ol><h2 id="读inode">读inode</h2><ol type="1"><li>UFS 和 FFS<ul><li>通过ino来计算出inode的位置</li></ul></li><li>LFS<ul><li>每次写文件块，都要写 inode</li><li>每次会写到新的位置，即一个文件的 inode 在磁盘没有固定位置</li></ul></li></ol><h3 id="imap">imap</h3><ol type="1"><li>记录 ino-&gt;inode 磁盘地址，只记录最新的inode地址</li><li>怎么存<ul><li>磁盘上的固定位置</li><li>每次写文件，都要修改 imap</li><li>写日志与写imap需要长距离寻道，性能比 FFS 还差</li></ul></li><li>LFS的改进方法<ul><li>imap块随文件块和i-node一起写到日志中</li><li>CR(Change Region)：记录每个imap块的最新磁盘地址</li><li>CR位于磁盘上固定位置：有两个CR，分别位于磁盘的头和尾</li></ul></li></ol><blockquote><p>关于目录：目录采用与文件一样的方式来写</p></blockquote><h2 id="读文件">读文件</h2><ol type="1"><li>假设 LFS 刚挂载，内存里什么也没有<ul><li>先读 CR，把 CR 缓存在内存，以后就不用读了</li><li>根据 ino ，知道它所在的磁盘块</li><li>查 CR 得到 imp 块的磁盘地址</li><li>读 imap 块，得到 ino 对应的 inode 的磁盘地址</li><li>读 inode，查文件块索引，得到文件块的磁盘地址</li><li>读文件块</li></ul></li></ol><h2 id="修改文件">修改文件</h2><ol type="1"><li>修改 /home/os/foo 的第一块<ul><li>原来的数据块变为无效 -&gt; 垃圾</li></ul></li><li>在 /home/os/foo 末尾追加写一块<ul><li>原来的inode变为无效 -&gt; 垃圾</li></ul></li></ol><h3 id="垃圾回收">垃圾回收</h3><ol type="1"><li>原理<ul><li>后台进程cleaner周期性地检查一定数量的segment</li><li>把每个segment中的活块拷贝到新的segment中<ul><li>如何判断活块？<ul><li>segment summary block<ul><li>记录每个数据块的ino和文件内偏移</li><li>位于 segment 的头部</li></ul></li><li>通过查segment summary block、imap和文件索引可以得到当前块的地址</li></ul></li></ul></li><li>M个segment的活块占据N个新的segment</li></ul></li><li>何时回收<ul><li>周期性回收</li><li>空闲时：无访问或访问少</li><li>磁盘快满的时候</li></ul></li><li>回收什么样的segment<ul><li>热segment：块频繁被重写</li><li>冷segment：部分死块、部分稳定块（不重写）</li><li>优先回收冷segment，推迟回收热segment（直至该segment里的数据块都被重写过）</li></ul></li></ol><h2 id="宕机恢复">宕机恢复</h2><ol type="1"><li>LFS的最新修改在日志末尾</li><li>CR记录第一个 segment 和最后一个 segment 的磁盘地址<ul><li>每个segment指向下一个segment</li></ul></li><li>CR更新<ul><li>写CR的第一个块，带时间戳</li><li>写CR本身内容</li><li>写CR最后一个块，带时间戳</li><li>周期性地将CR刷盘（30s）</li><li>两个CR（磁盘头和尾）交替写，减少CR更新时宕机的影响</li></ul></li><li>CR一致性保证<ul><li>第一个块和最后一个块的时间戳一致</li></ul></li><li>恢复方式<ul><li>使用最后一次且一致的 Checkpoint Region<ul><li>时间戳最新的 &amp; 完整的CR</li><li>可以获得最后一次 Checkpoint 时的 CR 内容，包括 imap等数据结构的地址</li></ul></li><li>CR 周期性刷盘，此时 CR 内容可能已过时，即最后一次 Checkpoint后的磁盘写没有被恢复</li><li>恢复优化（回滚）<ul><li>使用最后一次修改的 CR（不一定是一致的）重构最新的文件修改<ul><li>根据 CR 找到日志末尾（有记录），检查后续写的 segment</li><li>将其中有效的更新恢复到文件系统，例如，将 segment summary block中记录的 inode 更新到 imap 中</li></ul></li></ul></li><li>恢复快<ul><li>无需fsck，无需扫描磁盘</li><li>秒级 vs 小时级</li></ul></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> Study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件系统实现</title>
      <link href="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0/"/>
      <url>/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="文件块索引结构">文件块索引结构</h1><h2 id="文件块索引连续分配">文件块索引：连续分配</h2><ol type="1"><li>分配连续的磁盘块给文件<ul><li>文件粒度分配</li><li>bitmap：找到N个连续的"0"</li><li>链表：找到 size&gt;=N 的区域</li></ul></li><li>文件元数据<ul><li>记录第一个块的地址</li><li>块的个数N</li></ul></li><li>优点<ul><li>顺序访问性能高</li><li>随机访问时定位数据块也较容易</li></ul></li><li>缺点<ul><li>不知道文件最终多大，无论创建时，还是写数据块的时候</li><li>文件难以变大</li><li>外部碎片化</li></ul></li></ol><h2 id="文件块索引链表结构">文件块索引：链表结构</h2><ol type="1"><li>分配不连续的磁盘块给文件<ul><li>块粒度分配</li></ul></li><li>文件元数据<ul><li>记录第一个块的地址</li><li>每个块指向下一个块的地址</li><li>最后一个块指向NULL</li></ul></li><li>优点<ul><li>无外部碎片，而且文件变大很容易</li><li>空闲空间链表：与文件块类似</li></ul></li><li>缺点<ul><li>随机方式性能极差：定位数据块需按指针顺序遍历链表</li><li>可靠性差：一个坏块意味着其余的数据全部丢失</li><li>块内要保存指向下一块的指针，有效数据大小不一定是2的幂次</li></ul></li></ol><h2 id="文件块索引文件分配表fat">文件块索引：文件分配表（FAT）</h2><ol type="1"><li>一张有N的项的表，假设磁盘有N块<ul><li>每个磁盘块有一个表项：要么为空，要么为该文件下一块的地址</li><li>位于磁盘分区的头部</li></ul></li><li>文件元数据<ul><li>记录第一块的地址：链表头指针</li><li>每个磁盘块全部存数据，无指针</li></ul></li><li>优点<ul><li>简单</li><li>文件块为2的幂次</li></ul></li><li>缺点<ul><li>随机访问性能不好<ul><li>定位数据需要查找FAT表</li></ul></li><li>浪费空间<ul><li>需要额外的空间存储FAT表</li></ul></li></ul></li></ol><h2 id="文件块索引单机索引">文件块索引：单机索引</h2><ol type="1"><li>文件元数据<ul><li>用户定义文件长度上限 max size</li><li>file header: 一个指针数组指向每个块的磁盘地址</li></ul></li><li>优点<ul><li>文件在限制内可变大</li><li>随机访问性能高：数据块直接定位</li></ul></li><li>缺点<ul><li>不灵活，文件长度难以事先知道</li></ul></li></ol><h2 id="文件块索引两级索引">文件块索引：两级索引</h2><ol type="1"><li>思路：<ul><li>采用可变段分配</li><li>段内的块连续分配，段间运行不连续</li></ul></li><li>文件元数据<ul><li>小文件有10个指针，指向10个可变长度段（base,size）</li><li>大文件有10个间接指针，每个指向可变长度的间址块</li></ul></li><li>优点<ul><li>支持文件变大</li></ul></li><li>缺点<ul><li>段间碎片</li></ul></li></ol><h2 id="文件块索引多级索引unix">文件块索引：多级索引（UNIX）</h2><ol type="1"><li>块粒度分配</li><li>文件元数据：13个指针<ul><li>10个直接指针</li><li>第11个指针：一级间接指针</li><li>第12个指针：二级间接指针</li><li>第13个指针：三级间接指针</li></ul></li><li>优点<ul><li>小文件访问方便</li><li>支持文件变大</li></ul></li><li>缺点<ul><li>文件有上限</li><li>存在大量寻道</li></ul></li></ol><h2 id="文件块索引extents">文件块索引：Extents</h2><ol type="1"><li>Extent是若干个连续磁盘块（长度不固定）<ul><li>同一Extent中的所有块：要么多少空闲块，要么都属于某个文件</li><li>Extent：&lt;starting block, length&gt;</li></ul></li><li>XFS提出的方法<ul><li>无论文件块还是空闲块都采用Extents来组织<ul><li>块大小为8KB</li><li>Extent的大小 &lt;= 2M个块</li></ul></li><li>文件块索引<ul><li>采用B+树，中间结点记录文件块号和子节点的磁盘块地址</li><li>叶节点记录文件快好和其所属的Extent</li></ul></li><li>文件元数据<ul><li>记录B+树的根结点地址</li></ul></li></ul></li></ol><h1 id="目录项的组织结构">目录项的组织结构</h1><h2 id="目录访问">目录访问</h2><ol type="1"><li>路径解析<ul><li>在目录里查找指定目录项：文件名</li></ul></li><li>修改目录<ul><li>创建/删除目录、创建/删除文件、硬链接、符号链接、重命名</li><li>在目录里添加/删除目录项</li></ul></li><li>读目录<ul><li>扫描目录内容</li></ul></li></ol><h3 id="目录项的组织结构-1">目录项的组织结构</h3><ol type="1"><li>线性表<ul><li>原理<ul><li>&lt;文件名,ino&gt; 线性存储<ul><li>每一项不定长：&lt;ino,名字长度，下一项起始偏移，名字&gt;</li></ul></li><li>创建文件<ul><li>先查看有没有重名文件</li><li>如果没有，在表末添加一个entry: &lt;ino,newfile&gt;</li></ul></li><li>删除文件<ul><li>用文件名查找</li><li>删除匹配的entry</li><li>紧缩：将之后的entry都向前移动</li></ul></li></ul></li><li>优点<ul><li>空间利用率高</li></ul></li><li>缺点<ul><li>大目录性能差：线性查找，目录项数据从磁盘读取，磁盘的I/O多</li><li>删除时的紧缩很耗时</li></ul></li></ul></li><li>B+树<ul><li>原理<ul><li>在磁盘上使用B树索引目录的数据块</li><li>用B树来存储&lt;文件名,ino&gt;，以文件名排序（字典序）</li><li>创建/删除/查找：通过B树实现</li></ul></li><li>优点<ul><li>大目录性高：B树的查找减少磁盘的I/O</li></ul></li><li>缺点<ul><li>小目录不高效</li><li>占用更多空间</li><li>实现复杂</li></ul></li></ul></li><li>使用哈希表索引<ul><li>原理<ul><li>在VFS中使用哈希表索引目录项</li><li>用哈希表将文件名映射到ino<ul><li>hash_func(filename) -&gt; hval -&gt; 哈希桶</li><li>在哈希桶中线性查找 filename</li></ul></li><li>创建/删除需要分配/回收空间</li></ul></li><li>优点<ul><li>简单</li><li>查找速度快</li></ul></li><li>缺点<ul><li>哈希表空间不好估计<ul><li>表较大浪费空间</li><li>表小容易产生大量哈希冲突</li></ul></li></ul></li></ul></li></ol><h3 id="创建文件或目录">创建文件或目录</h3><blockquote><p>例子：创建文件<code>/home/os22/fs02.ppt</code></p></blockquote><ol type="1"><li>解析父目录"/home/os22"，得到其ino，假设为100</li><li>读取其i-node，检查用户是否具有创建的权限</li><li>根据i-node，读取父目录的内容</li><li>查找是否已经存在名字为"fs02.ppt"的目录项</li><li>如果找到，同时flag为目录，则返回失败，否则转11</li><li>为"fs02.ppt"分配一个空闲的inode，假设其ino为116</li><li>填充inode的内容ino,size,uid,gid,ctime,mode...</li><li>在父目录的内容中添加一个目录项&lt;"fs02.ppt",116&gt;</li><li>修改父目录的inode:size,atime,mtime</li><li>把修改写到磁盘"fs02.ppt"的inode、父目录的inode、父目录内容</li><li>创建一个打开文件结构，指向"fs02.ppt"的inode</li><li>分配一个空闲的打开文件结构指针，指向打开文件结构</li><li>返回指针的数组下标</li></ol><h3 id="删除文件或目录">删除文件或目录</h3><blockquote><p>例子：删除文件<code>/home/os22/fs02.ppt</code></p></blockquote><ol type="1"><li>路径解析父目录"/home/os22"，得到其ino为100</li><li>读取其i-node，检查用户是否具有删除的权限</li><li>根据i-node，读取父目录的内容</li><li>查找是否已经存在名字为"fs02.ppt"的目录项</li><li>如果不存在，则返回失败</li><li>得到"fs02.ppt"的ino为116</li><li>如果nlink为1，则释放inode及文件块，否则nlink-1</li><li>在父目录的内容中删除目录项&lt;"fs02.ppt",116&gt;</li><li>修改父目录的inode:size,atime,mtime</li><li>把修改写到磁盘：inode、父目录inode、父目录内容、空闲块</li><li>返回</li></ol><h1 id="文件缓存">文件缓存</h1><blockquote><p>例如：解析路径"/home/foo"，并读/写，会产生大量I/O</p></blockquote><ol type="1"><li>读根目录的i-node和它的第一块</li><li>读home目录的i-node和它的第一块</li><li>读foo文件的i-node和它的第一块 / 创建文件foo并写其第一块</li></ol><h2 id="文件缓存file-buffer-cachepage-cache">文件缓存（File buffercache/page cache）</h2><ol type="1"><li>使用内核空间的一部分内存来缓存磁盘块</li><li>读操作read()：先检查该块是否在缓存中<ul><li>在：将缓冲块的内容拷贝到用户buffer</li><li>不在：<ul><li>分配一个缓存块（可能需要替换）</li><li>把磁盘块读到缓冲</li><li>再把缓存块拷贝到用户buffer</li></ul></li></ul></li><li>写操作write()：先检查该块是否在缓存中<ul><li>在：将用户buffer的内容拷贝到缓冲块</li><li>不在：<ul><li>分配一个缓存块（可能需要替换）</li><li>把用户buffer的内容拷贝到缓存块</li></ul></li><li>将该缓存块写回磁盘（根据缓存管理策略）</li></ul></li><li>缓存设计问题<ul><li>缓存什么、缓存大小、何时放进缓存、替换谁、写回策略</li></ul></li></ol><h3 id="缓存什么">缓存什么</h3><ol type="1"><li>不同类型的块<ul><li>i-nodes</li><li>间址块</li><li>目录</li><li>文件块</li></ul></li></ol><h3 id="缓存大小">缓存大小</h3><ol type="1"><li>文件缓存与进程使用的虚存竞争有限的内存空间</li><li>两种方法<ul><li>固定大小：用特权命令设置文件缓存大小</li><li>可变大小：<ul><li>文件缓存和VM都按需申请内存：页替换</li><li>文件缓存大小不可控</li></ul></li></ul></li></ol><h3 id="替换谁">替换谁</h3><ol type="1"><li>为什么缓存位于内核空间<ul><li>DMA<ul><li>DMA数据传输</li></ul></li><li>多用户进程<ul><li>共享缓存</li></ul></li></ul></li><li>通常的替换策略<ul><li>全局LRU</li><li>进程工作集</li></ul></li></ol><h3 id="何时放进缓存">何时放进缓存</h3><ol type="1"><li>何时放进缓存：按需取 vs 预取</li><li>文件访问具有局部性<ul><li>时间局部性</li><li>空间局部性</li></ul></li><li>最优<ul><li>在要用之前搞好预取进来</li></ul></li><li>通常的策略<ul><li>针对顺序访问的预取：访问第i块时，预取随后的k个块<ul><li>文件块尽量分配连续的磁盘块</li><li>Linux采用的方法</li></ul></li><li>针对inode的预取：在读取目录项时，同时读取对应的inodes</li></ul></li><li>高级策略<ul><li>预取同一目录下所有的小文件</li></ul></li></ol><h3 id="写回策略">写回策略</h3><ol type="1"><li>写操作<ul><li>数据必须写到磁盘才能持久化</li></ul></li><li>缓存中的数据何时写到磁盘上<ul><li>Write Through<ul><li>每个写操作，不仅更新缓存块，而且立即更新磁盘块</li><li>好处：简单&amp;可靠性高，最新数据都落盘</li><li>坏处：磁盘写没有减少</li></ul></li><li>Write Back<ul><li>每个写操作，只更新缓存块，并将其标记为脏块</li><li>之后再将它写到磁盘</li><li>写操作快 &amp; 减少磁盘写：缓存吸纳多次写，批量写磁盘</li></ul></li></ul></li><li>写回的复杂性<ul><li>丢数据<ul><li>宕机时，缓存中的“脏”数据将全部丢失</li><li>推迟写磁盘 -&gt; 更好的性能，但损失更大</li></ul></li><li>什么时候写回磁盘<ul><li>当一个块被替换出缓存时</li><li>当文件关闭时</li><li>当进程调用fsync时</li><li>固定的时间间隔（Unix是30s）</li></ul></li><li>问题<ul><li>执行写操作的进程并不知道数据什么时候落盘了<ul><li>通过fsync：用户显式写回数据</li></ul></li><li>不能保证不丢数据：宕机或掉电可能发生在任何时候</li></ul></li></ul></li></ol><h3 id="文件系统-vs-虚存">文件系统 vs 虚存</h3><ol type="1"><li>相似点<ul><li>位置透明性：用户不感知物理地址</li><li>大小无关性：固定粒度分配（块/页），不连续分配</li><li>保护：读/写/执行权限</li></ul></li><li>FS 比 VM 容易的地方<ul><li>FS的地址转换可以慢</li><li>文件比较稠密（空洞少），经常是顺序访问</li><li>进程地址空间非常稀疏，通常是随机访问</li></ul></li><li>FS 比 VM 难的地方<ul><li>路径解析可能引入多次I/O</li><li>文件缓存的空间（内存）总是不够的</li><li>文件大小差距大：很多不足10KB，有些又大于GB</li><li>FS的实现必须是可靠的</li></ul></li></ol><h4 id="虚存页表-vs-文件块索引">虚存页表 vs 文件块索引</h4><ol type="1"><li>页表<ul><li>维护进程地址空间与物理内存的映射关系</li><li>虚页号 -&gt; 物理页框号</li><li>查检访问权限、地址合法性</li><li>硬件实现地址转换，如果映射关系在TLB中，很快完成转换</li></ul></li><li>文件块索引<ul><li>维护文件块与磁盘块之间的映射关系</li><li>文件块号 -&gt; 磁盘逻辑块号</li><li>查检访问权限、地址合法性</li><li>软件（OS）实现地址转换，可能需要多次磁盘I/O</li></ul></li></ol><h1 id="ffsunix文件系统">FFS（Unix文件系统）</h1><h2 id="最初的-unix-fs">最初的 Unix FS</h2><ol type="1"><li>简单的磁盘布局<ul><li>文件块大小 = 扇区大小 = 512B</li><li>i-node区在前，数据区灾后</li><li>空闲块/inode链表：Superblock中记录头指针</li></ul></li><li>文件块索引采用三级间指，目录采用线性表</li><li>存在的问题<ul><li>带宽很低：顺序访问只有20KB/s，即2%的磁盘带宽</li></ul></li></ol><h3 id="导致带宽低的原因">导致带宽低的原因</h3><ol type="1"><li>数据块的存储位置<ul><li>数据块存储在内层的柱面</li><li>inode 存储在外层的柱面</li></ul></li><li>频繁长距离寻道<ul><li>inode 与其数据块离得很远</li><li>同一目录里的文件，其inode也离得很远</li><li>一个文件的数据块散布在磁盘上任意位置<ul><li>即使顺序读写文件 -&gt; 随机磁盘 I/O</li></ul></li></ul></li><li>未考虑给文件分配连续磁盘块<ul><li>空闲块采用链表组织</li><li>链表上相邻的块，其物理地址不连续</li></ul></li><li>小粒度访问多<ul><li>采用512B的小块</li><li>无法发挥磁盘带宽</li></ul></li></ol><h2 id="bsd-ffsfast-file-system">BSD FFS（Fast File System）</h2><ol type="1"><li>大文件块：4KB/8KB vs 512B<ul><li>数据块大小记录在Superblock中</li><li>空间利用率问题<ul><li>小文件</li><li>大文件的最末一块可能非常小</li></ul></li><li>FFS的解决办法<ul><li>数据块划分为若干更小的子块</li><li>子块为512B，每块8/16个子块</li></ul></li></ul></li><li>Bitmap：取代空闲块链表<ul><li>尽量连续分配</li><li>预留 10% 的磁盘空间</li></ul></li></ol><h3 id="ffs的磁盘布局">FFS的磁盘布局</h3><ol type="1"><li>柱面组（Cylinder Group）<ul><li>柱面：所有盘片上半径相同的磁道构成一个柱面。</li><li>CG：每N个连续的柱面为一个CG</li><li>把磁盘划分为若干柱面组，将文件和目录分散存储于每个柱面组</li><li>每个CG类似于一个 Sub FS<ul><li>包含Superblock，空闲inode bitmap，空闲块bitmap，inode表，数据块</li></ul></li></ul></li></ol><h3 id="ffs的放置策略">FFS的放置策略</h3><ol type="1"><li>减少长距离寻道<ul><li>原则：把相关的东西放在同一CG</li></ul></li><li>目录放置<ul><li>选择CG：目录个数少 &amp; 空闲inode个数多 &amp; 空闲块多</li></ul></li><li>文件放置<ul><li>文件inode选择其目录所在的CG</li><li>文件块选择其inode所在的CG<ul><li>inode与文件块一起读的概率是只读inode的4倍</li></ul></li></ul></li><li>大文件处理<ul><li>应避免它占满一个CG</li><li>inode所在CG：存放前10个磁盘块（直接指针指向）</li><li>每个间址块及其指向的块放在同一CG（4MB）</li><li>不同间址块及其指向的块放在不同CG</li></ul></li></ol><h3 id="ffs的效果">FFS的效果</h3><ol type="1"><li>性能提升<ul><li>读写性能和CPU利用率提升</li><li>小文件性能提升</li></ul></li><li>进一步的优化空间<ul><li>块粒度分配和多级索引，大文件访问不高效<ul><li>用 Extent 来描述连续的数据块</li></ul></li><li>元数据采用同步写，影响小文件性能<ul><li>异步写，并保证一定的顺序</li><li>日志</li></ul></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> Study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件系统基础</title>
      <link href="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"/>
      <url>/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="文件系统基础">文件系统基础</h1><ol type="1"><li>为什么我们需要文件系统<ul><li>持久化保存数据需求（Persistence）</li><li>进程结束、关机/关电、宕机/掉电</li><li>使用持久化存储设备：磁盘、SSD等</li></ul></li><li>FS 是对持久化数据存储的抽象<ul><li>给用户/程序开发者提供一个逻辑上的持久化存储<ul><li>文件、目录形式</li><li>简单、易理解、操作方便</li></ul></li><li>将复杂的、公共的管理功能从用户程序中移出<ul><li>存储设备管理，例如磁盘</li><li>数据管理，即程序持久化数据的组织和增删改查</li></ul></li></ul></li><li>对FS的基本需求<ul><li>能够保存大量（复杂多样）的信息 -&gt; 管理问题</li><li>多个进程同时访问 -&gt; 并发控制问题</li><li>多用户共享数据 &amp; 私有数据 -&gt; 安全保护问题</li></ul></li></ol><h2 id="文件系统的用户视图">文件系统的用户视图</h2><ol type="1"><li>文件：数据组织的单位<ul><li>文件是命名的字节数组</li><li>用户将数据组织成文件，根据文件名来访问对应的数据</li><li>FS不感知文件的内容：使用文件的进程负责解析内容</li></ul></li><li>目录：文件组织的单位<ul><li>一组文件和目录的命名集合</li><li>父目录、子目录</li><li>同一目录下没有重名的</li></ul></li><li>名字空间：树形层次结构<ul><li>文件系统的逻辑视图</li></ul></li></ol><h3 id="文件">文件</h3><ol type="1"><li>文件名：由字母、数字及某些特殊字符组成的字符串<ul><li>用户根据文件名来访问文件</li><li>文件扩展名：描述文件的用途</li></ul></li><li>文件属性<ul><li>文件大小、所有者、时间戳、访问权限</li><li>文件逻辑地址：0..fsize-1，指示数据在文件中的位置</li></ul></li><li>文件内容：无结构<ul><li>OS将文件视为无结构的字节数组</li><li>程序开发者可以定义任意结构的文件</li></ul></li><li>文件的类型<ul><li>常规文件、目录文件、设备文件、可执行文件</li></ul></li><li>文件的访问<ul><li>打开文件 &amp; 文件描述符</li><li>当前位置：文件内部的逻辑地址，范围是[0,fsize-1]</li><li>访问方式（Access Mode）：读，写，执行</li></ul></li><li>文件的访问模式（Access Pattern)<ul><li>顺序访问<ul><li>从头到尾依次访问每个文件块</li><li>顺序访问文件 不等于 磁盘上顺序访问扇区</li></ul></li><li>随机访问<ul><li>每次随机访问一个文件块</li></ul></li><li>按关键字访问<ul><li>查找包含关键字的文件及段落</li><li>文件系统本身不提供此功能，需要借助应用程序完成</li><li>与之相比，数据库自身可以实现按关键字查找记录</li></ul></li></ul></li></ol><h3 id="目录">目录</h3><ol type="1"><li>路径<ul><li>根目录 &amp; 当前工作目录</li><li>. : 当前目录</li><li>.. : 根目录</li><li>绝对路径 vs 相对路径</li></ul></li><li>目录：一种特殊的文件<ul><li>命中 &amp; 属性</li><li>目录和文件用相同的数据结构（inode）<ul><li>通过一个标志（i_mode）来区分文件和目录</li></ul></li><li>目录内容：描述它所包含的目录和文件集合<ul><li>有结构：逻辑上是一张表</li><li>目录项：每个成员一项</li><li>不同的FS采用不同的结构</li><li>由FS负责维护和解析目录内容</li><li>访问目录 vs 访问文件：通过不同的syscall实现</li></ul></li></ul></li></ol><h3 id="链接">链接</h3><ol type="1"><li>硬链接<ul><li>为文件共享提供的一种手段<ul><li>为文件创建一个新名字，无数据拷贝</li><li>多个名字可以指向同一个文件</li><li>一个文件可以同时拥有多个名字，甚至位于多个目录中</li></ul></li><li>限制<ul><li>不能跨文件系统</li><li>不能链接目录</li></ul></li></ul></li><li>符号链接<ul><li>另一种文件共享的手段<ul><li>创造一个普通文件，内容为目标地址的路径（绝对路径/相对路径）</li></ul></li></ul></li></ol><h1 id="文件系统内部结构">文件系统内部结构</h1><h2 id="虚拟文件系统-和-物理文件系统">虚拟文件系统 和 物理文件系统</h2><ol type="1"><li>虚拟文件系统<ul><li>同时挂载不同类型的FS<ul><li>SUNFS访问本地的磁盘</li><li>SUN NFS访问远端服务器的FS</li></ul></li><li>实现FS接口和通用功能</li></ul></li><li>物理文件系统<ul><li>磁盘布局、数据结构、磁盘空间管理、名字空间管理等</li></ul></li><li>虚拟文件系统开关表<ul><li>用于物理文件系统的挂载与卸载</li><li>每一种类型的文件系统有一个表项<ul><li>文件系统类型的名字</li><li>初始化函数指针，用于 mount</li><li>清除函数指针，用于 umount</li></ul></li><li>例子: <code>mount -t ext4 /dev/sdb /home/os</code><ul><li>前提：<ul><li>文件系统类型ext4必须事先加载进内核</li><li>挂载目录 /home/os 必须要已经创建好</li></ul></li><li>步骤<ul><li>根据文件系统类型，查VFS开关表，找到该ext4类型FS的初始化函数，即<code>ext4_mount()</code></li><li>调用<code>ext4_mount</code><ul><li>读取<code>superblock</code></li><li>读取根目录<code>i-node</code></li></ul></li><li>初始化一些内存数据结构</li></ul></li></ul></li></ul></li></ol><h2 id="文件系统主要数据结构">文件系统主要数据结构</h2><h3 id="i-node">i-node</h3><blockquote><p>inode：描述文件/目录，也成为文件元数据</p></blockquote><ol type="1"><li>每个文件用一个i-node来描述</li><li>文件元数据<ul><li>mode: 文件类型和访问权限</li><li>size: 文件大小</li><li>nlinks: 硬链接数</li><li>uid: 所有者的user id</li><li>gid: 所有者的group id</li><li>ctime: 文件创建的时间戳</li><li>atime: 上一次访问文件的时间戳</li><li>mtime: 上一次修改文件的时间戳</li></ul></li><li>ino：inode number，即i-node的ID，唯一标识一个文件（在一个FS内）</li><li>文件块的索引信息：文件块的磁盘位置信息<ul><li>&lt;offset,count&gt; -&gt; 磁盘上的位置 （文件块# -&gt; 磁盘逻辑块#LBN）</li><li>不同的FS采取不同的索引机制</li></ul></li></ol><h3 id="目录项dentry">目录项（dentry）</h3><blockquote><p>dentry: 目录项，记录文件和inode的对应关系</p></blockquote><ol type="1"><li>目录内容为它所包含的所有子目录和文件的名字及其ino<ul><li>不包含子目录的内容</li></ul></li><li>逻辑上，目录是一张映射表<ul><li>目录项(dentry): 文件名 -&gt; ino</li></ul></li><li>物理上，目录项是一个字节数组<ul><li>文件名不等长，数组每一项不等长</li></ul></li><li>路径解析<ul><li>根据路径名，获得其ino</li><li>逐级目录查找</li><li>例子: <code>/home/os/fs01.ppt</code><ul><li>从根目录开始，查找<code>/home</code>的ino</li><li>在<code>home</code>目录下查找<code>os</code>的ino</li><li>再<code>os</code>目录下查找<code>fs01.ppt</code>的ino</li><li>根据<code>fs01.ppt</code>的ino，找到其数据块，进行读写操作</li></ul></li></ul></li></ol><h3 id="打开文件表open-file-table">打开文件表（Open-file table）</h3><blockquote><p>打开文件表：记录进程打开的文件信息</p></blockquote><ol type="1"><li>打开文件，通过 <code>fd = open(path,flags,mode)</code>实现</li><li>打开文件表: Open-file table<ul><li>通过打开文件表（在内存中）把进程与文件的i-node进行关联</li><li>路径名解析和权限检查，得到path的ino，读出它的inode（保存在磁盘上）</li><li>将磁盘i-node拷贝到一个内存i-node结构中，在打开文件表中增加一项，包含以下内容<ul><li>文件的Reference Count</li><li>当前文件的偏移量</li><li>文件的访问模式</li><li>内存inode结构的指针</li></ul></li></ul></li></ol><blockquote><p>文件描述符表：File Descriptor Table</p></blockquote><ol type="1"><li>每个进程有一个文件描述符表<ul><li>指针数组，每个指针指向打开文件表中的一项，表示一个打开文件</li><li>该指针在文件描述符表中的下表，即文件描述符fd</li></ul></li></ol><h3 id="超级块superblock">超级块（superblock）</h3><blockquote><p>superblock: 描述文件系统基本信息</p></blockquote><ol type="1"><li>定义一个文件系统<ul><li>数据块的大小</li><li>i-node的大小</li><li>数据块总数</li><li>i-node总数</li><li>根目录ino</li><li>i-node表的起始地址</li><li>Block Bitmap的起始地址</li><li>i-node Bitmap的起始地址</li></ul></li><li>当前状态<ul><li>数据块的使用状态：已使用的块数、预留的块数、剩余的块数...</li><li>i-node的使用状态：已使用的i-node数、预留的i-node数、剩余的i-node数...</li></ul></li></ol><h3 id="文件系统的磁盘布局">文件系统的磁盘布局</h3><blockquote><p>Boot Block | Superblock | Block Bitmap | i-node Bitmap | I-node Array| Data Blocks</p></blockquote><ol type="1"><li>引导块<ul><li>启动OS的代码</li></ul></li><li>Superblock：定义一个FS<ul><li>FS的相关信息</li></ul></li><li>空闲空间管理相关的信息<ul><li>Block Bitmap</li><li>i-node Bitmap</li></ul></li><li>i-node表<ul><li>每个i-node描述一个文件或目录</li></ul></li><li>数据块<ul><li>文件块或目录块</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> Study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSD</title>
      <link href="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/SSD/"/>
      <url>/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/SSD/</url>
      
        <content type="html"><![CDATA[<h1 id="固态硬盘ssdsolid-state-drive">固态硬盘SSD（Solid StateDrive）</h1><h2 id="闪存组织">闪存组织</h2><ol type="1"><li>闪存（Flash Memory）<ul><li>1984：NOR flash</li><li>1987：NAND flash</li><li>1992：SSD</li></ul></li><li>NOR flash vs NAND flash<ul><li>NOR是字节寻址，NAND是页寻址</li><li>NOR读延迟比NAND低100x</li><li>NOR擦除时间比NAND高300x</li><li>NOR用于取代ROM，存可执行代码</li><li>NAND用于大量持久化存储设备</li></ul></li><li>信息存储方式<ul><li>SLC：1 bit/cell 2个值 0/1</li><li>MLC：2 bit/cell 4个值 00/01/10/11</li><li>TLC：3 bit/cell 8个值</li><li>QLC：4 bit/cell 16个值</li></ul></li></ol><h3 id="nand闪存组织">NAND闪存组织</h3><ol type="1"><li>Flash package<ul><li>多个 die</li></ul></li><li>Die<ul><li>多个 Plane/Bank</li></ul></li><li>Plane/Bank<ul><li>很多块（擦除块）</li><li>一些寄存器</li></ul></li><li>块（Block/Erase Block）<ul><li>很多页</li></ul></li><li>页（Page）<ul><li>由数据区与OOB(Out of Band)区构成</li><li>数据区用于存储实际数据</li><li>OOB区用于记录<ul><li>ECC</li><li>状态信息：Erased/Valid/Invalid</li><li>Logic Page Number</li></ul></li><li>页大小<ul><li>SLC通常为2KB<sub>8KB，TLC通常为4KB</sub>16KB</li></ul></li><li>块大小<ul><li>SLC通常为128KB、256KB...</li><li>TLC通常为2MB、4MB...</li></ul></li></ul></li></ol><h3 id="闪存的操作接口">闪存的操作接口</h3><ol type="1"><li>读：Read a page<ul><li>读的粒度是页</li><li>读很快，读延迟在几十微秒</li><li>读延迟与位置无关，也与上一次读的位置无关（和磁盘不同）</li></ul></li><li>擦除：Erase a block<ul><li>把整个块写成全1</li><li>擦除的粒度是块，必须整块擦除</li><li>很慢：擦除时间为几个毫秒</li><li>需软件把块内有效数据拷贝到其它地方</li></ul></li><li>写：Program a page<ul><li>擦除后才能写，因为写只能把1变成0</li><li>写的粒度是页</li><li>写比读慢，比擦除快，写延迟在几百微秒</li></ul></li></ol><h3 id="页的状态">页的状态</h3><ol type="1"><li>初始状态为Invalid</li><li>读时，不改变页的状态</li><li>擦除时，块内所有页的状态变为Erased</li><li>写时，只能写状态为Erased的页，写后页状态变为Valid</li></ol><h3 id="闪存的性能和可靠性">闪存的性能和可靠性</h3><ol type="1"><li>性能<ul><li>写延迟比读高10倍以上</li><li>写延迟波动幅度大</li><li>擦除很慢：约为磁盘定位延迟</li><li>延迟随密度增加而增长</li></ul></li><li>可靠性<ul><li>磨损：擦写次数有上限，随密度增加而减少</li><li>干扰：读写一个页，相邻页中一些位的值发生翻转</li></ul></li><li>闪存特性<ul><li>读延迟很低：随机读的性能远优于磁盘</li><li>写慢：必须先擦除再写，约为磁盘写（ms级）</li><li>磨损：每个块擦写次数有上限</li></ul></li></ol><h3 id="基于闪存的ssd">基于闪存的SSD</h3><ol type="1"><li>用很多闪存芯片来构成一个持久化存储设备SSD</li><li>多个闪存芯片：并行I/O，提高I/O性能</li><li>与主机的接口：提供标准块设备接口</li><li>数据缓存和缓冲：SRAM/DRAM</li><li>闪存控制器（硬件）和FTL（固件）：控制逻辑<ul><li>主机命令转换成闪存命令（Read/Erase/Program）</li><li>逻辑块地址转换成闪存的物理地址（页/块）</li><li>缓存替换</li></ul></li></ol><h2 id="ftl">FTL</h2><h3 id="最简单的ftl直接映射">最简单的FTL：直接映射</h3><ol type="1"><li>Direct Mapping<ul><li>逻辑块的第N块直接映射到物理的第N页(假设逻辑块与物理页都为4KB）</li></ul></li><li>读操作容易：读逻辑第k页<ul><li>读物理第k页</li></ul></li><li>写操作麻烦：写逻辑第k页<ul><li>第k页所在闪存块（记为B0）</li><li>把B0整个块读出来</li><li>把B0整个块擦除</li><li>B0中的旧页和新的第k页：以顺序方式一页一页再写入B0</li></ul></li><li>缺陷：写性能极差<ul><li>每写一个页，要读整个块、擦除整个块、写整个块</li><li>写放大</li></ul></li></ol><h4 id="ftl改进异地更新">FTL改进：异地更新</h4><ol type="1"><li>核心思想：异地更新（out-of-place update）<ul><li>不再执行原地更新</li><li>每次写页，写到一个新位置（新的物理页地址）</li></ul></li><li>页级映射<ul><li>页级映射表：LPN -&gt; 物理页地址PPN<ul><li>整个放在内存中</li><li>持久化：利用页的OOB区来保存映射表</li><li>随着写页而被写到闪存</li><li>掉电或重启，扫描OOB区来恢复映射表</li></ul></li><li>优点：<ul><li>性能好：减少写放大</li><li>可靠性好：映射关系被自动写入闪存</li></ul></li><li>问题：<ul><li>重写产生垃圾页<ul><li>每次写到新位置，导致原先页的内容无效</li></ul></li><li>内存开销大<ul><li>映射表全部放内存</li><li>映射表的大小与SSD容量成正比</li></ul></li></ul></li></ul></li><li>写一个逻辑页k<ul><li>寻找一个空闲页p（例如当前擦除块中下一个空闲页p）</li><li>在映射表中记录：逻辑页k -&gt; 物理页p</li></ul></li><li>读一个逻辑页k<ul><li>查映射表，获得逻辑页k对应的物理页地址p</li><li>读物理页p</li></ul></li></ol><h4 id="垃圾回收">垃圾回收</h4><ol type="1"><li>思想<ul><li>选择一个含垃圾页的块</li><li>把其中的有效页拷贝到其他块中（先读再重写）</li><li>回收整个块，并把它擦除</li></ul></li><li>如何判断有效页？<ul><li>每个物理页记录它对应的逻辑页地址（OOB区）</li><li>查映射表，如果映射表记录的 PPN=该页，是有效页</li></ul></li><li>问题：开销非常大<ul><li>有效页需要拷贝：先读再重写</li><li>开销与有效页所占的比例成正比</li></ul></li><li>解决办法：超配（over-provisioning）<ul><li>实际物理空间比用户所见空间更大：多15%~45%<ul><li>例如，用户看到100GB的SSD，实际上内部是120GB</li><li>GC时将数据写入 over-provisioning space，减少对性能的影响</li></ul></li><li>GC一般在SSD后台执行，尽量再设备不忙时执行，但是受限于空闲页的数量<ul><li>空闲页不足的时候，即使设备忙也需要开始执行GC</li></ul></li></ul></li></ol><h3 id="块级映射block-level-mapping">块级映射（Block-LevelMapping）</h3><ol type="1"><li>块级映射<ul><li>逻辑地址空间划分为chunk，chunk size = 擦除块（物理块）size</li><li>映射表：chunk# -&gt; 擦除块（物理块）地址 PBN</li></ul></li><li>读一个逻辑页<ul><li>逻辑页地址 = chunk# || 偏移</li><li>用chunk#查映射表，获得相应的擦除块地址PBN</li><li>物理页地址 = PBN || 偏移</li></ul></li><li>问题：小规模写性能差<ul><li>写粒度小于擦除块：拷贝有效页（读 &amp; 写），导致写放大</li><li>小写很常见：擦除块通常较大（大于256KB）</li></ul></li></ol><h3 id="混合映射hybrid-mapping">混合映射（Hybrid Mapping）</h3><ol type="1"><li>思想<ul><li>将擦除块（物理块）划分为两类：数据块和日志块</li><li>写逻辑页时都写入日志块</li><li>数据块采用块级映射，数据映射表</li><li>日志块采用页级映射，日志映射表</li><li>适当的时候把日志块合并为数据块</li></ul></li><li>读一个逻辑页<ul><li>先查日志映射表，按页级映射的方法</li><li>如果没找到，再查数据映射表，按块级映射的方法</li></ul></li></ol><h4 id="合并方式">合并方式</h4><ol type="1"><li>Switch Merge<ul><li>直接把日志块转成数据块：前提是整个日志块的页序与原数据块中的页序一致</li><li>把原来的数据块回收擦除</li><li>优点：开销低，只修改映射表信息，无数据拷贝</li></ul></li><li>Partial Merge<ul><li>把数据块中有效页拷贝到日志块：日志块中页序与原数据块中的页序一致</li><li>把日志块转成数据块，把原来的数据块回收擦除</li><li>有数据拷贝开销</li></ul></li><li>Full Merge<ul><li>分配一个新的日志块，从数据块和日志块分别拷贝有效页到新日志块</li><li>把新日志块转成数据块</li><li>把原来的数据块和日志块都回收擦除</li><li>开销很大：需要拷贝整个物理块的数据（读 &amp; 写）</li></ul></li></ol><h3 id="磨损均衡">磨损均衡</h3><ol type="1"><li>目标<ul><li>让所有块被擦除的次数近似</li></ul></li><li>动态磨损均衡<ul><li>每次写时，选择擦除次数较少或最少的空闲块</li><li>局限性：不同数据的修改频率不同<ul><li>例子：只写一次的数据（static data），很少写的数据（cold data）</li></ul></li></ul></li><li>静态磨损均衡<ul><li>动态磨损均衡不考虑不会被回收的物理块，例如长时间不被修改的物理块（写冷块）</li><li>不再被写，不再有磨损</li><li>解决办法：FTL定期重写冷块，将其写入磨损较多的块</li></ul></li></ol><h3 id="总结">总结</h3><ol type="1"><li>SSD FTL的主要功能<ul><li>地址映射</li><li>垃圾回收</li><li>磨损均衡</li><li>请求调度</li><li>缓存管理</li><li>坏块管理</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> Study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>磁盘和RAID</title>
      <link href="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%A3%81%E7%9B%98%E5%92%8CRAID/"/>
      <url>/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%A3%81%E7%9B%98%E5%92%8CRAID/</url>
      
        <content type="html"><![CDATA[<h1 id="磁盘">磁盘</h1><ol type="1"><li>持久化的、大容量的、低成本的存储设备：机械、速度慢<ul><li>多种尺寸：3.5",2.5"</li><li>多种容量：100GB ~ 14TB</li><li>多种接口</li></ul></li><li>典型的磁盘控制器<ul><li>与主机的接口<ul><li>SATA,ATA: 面向对延迟、吞吐率要求不高，大容量的场景</li><li>SAS,SCSI/Ultra-SCSI: 面向低延迟，高吞吐率，高可靠场景</li><li>FC: Fiber Channel</li></ul></li><li>缓冲：缓冲数据</li><li>控制逻辑<ul><li>读写请求</li><li>请求调度</li><li>缓存替换</li><li>坏块检测和重映射</li></ul></li></ul></li><li>磁盘的结构<ul><li>盘片：一组<ul><li>按固定速率旋转</li></ul></li><li>磁道（Track）<ul><li>位于盘片表面的同心圆</li><li>用于记录数据的磁介质</li><li>bit沿着每条磁道顺序排列</li></ul></li><li>扇区（Sector）<ul><li>磁道划分为固定大小的单元，一般为512字节</li></ul></li><li>磁头：一组<ul><li>用于读写磁道上的数据</li></ul></li><li>磁臂：一组<ul><li>用于移动磁头（多个）</li></ul></li><li>柱面（Cylinder）<ul><li>由所有盘片上半径相同的磁道组成</li></ul></li><li>Zone<ul><li>不同磁道的扇区个数不同：外道多，内道少</li><li>所有柱面划分为Zone，同一个Zone中每条磁道的扇区数相同</li><li>1000-5000个柱面/Zone，其中几个为备用柱面（Spare Cylinder）</li></ul></li></ul></li></ol><h2 id="磁盘扇区sector">磁盘扇区（Sector）</h2><ol type="1"><li>扇区的创建<ul><li>磁盘格式化</li><li>逻辑块地址映射到物理块地址</li></ul></li><li>扇区的格式<ul><li>头部：ID，损坏标志位，...</li><li>数据区：实际用于存储数据的区域，典型大小为 512B</li><li>尾部：ECC校验码</li></ul></li><li>坏扇区<ul><li>发现坏扇区 -&gt; 先用ECC纠错</li><li>如果不能纠错，用备用扇区替代</li><li>坏的扇区不再使用</li></ul></li><li>磁盘容量<ul><li>格式化损耗20%左右：每个扇区的头部和尾部 + 坏扇区</li></ul></li><li>读写操作（读写某个柱面的某个扇区）<ul><li>定位柱面，移动磁臂使磁头对准柱面 -&gt; 寻道seek</li><li>等待扇区旋转到磁头下方 -&gt; 旋转 rotation</li><li>进行数据读写 -&gt; 数据传输 transfer</li></ul></li></ol><h2 id="磁盘性能">磁盘性能</h2><ol type="1"><li><p>有效带宽 = 数据量 / 耗时</p></li><li><p>耗时</p><ul><li>寻道时间（Seek Time）<ul><li>把磁头移动到目标柱面的时间</li><li>典型：3.5 ~ 9.5ms</li></ul></li><li>旋转延迟（Rotation Delay）<ul><li>等待目标扇区旋转到磁头下方的时间</li><li>典型：7200 ~ 15000 RPM</li></ul></li><li>数据传输时间（Data Transfer Time）<ul><li>典型传输带宽：70~250 MB/Sec</li></ul></li></ul></li><li><p>例如：假设磁盘的 BW = 100MB/s,seek=5ms,rotation=4ms</p><ul><li>访问 1KB 数据的总时间 = 5ms + 4ms + 1KB/(100MB/s) = 9.01ms</li><li>有效带宽 = 1KB / 9.01ms 远小于 100MB/s</li><li>一次传输多少数据有效带宽才能达到磁盘带宽的90%<ul><li>size = BW<em>(rotation + seek)</em>0.9/(1-0.9) = 8.1MB</li></ul></li><li>对于小粒度的访问，时间主要花在寻道时间和旋转时间上<ul><li>磁盘的传输带宽被浪费</li><li>缓存：每次读写邻近的多个扇区，而不是一个扇区</li><li>调度算法：减少寻道开销</li></ul></li></ul></li><li><p>磁盘缓存</p><ul><li>磁盘内通过少量 DRAM 来缓存最近访问的块<ul><li>典型大小为 64~256MB</li></ul></li><li>由控制器管理，OS无法控制</li><li>块替换策略：LRU</li><li>优点：如果访问具有局部性，则读性能受益</li><li>缺点：需要额外的机制来保障写的可靠性</li></ul></li></ol><h2 id="磁盘调度算法">磁盘调度算法</h2><h3 id="磁盘寻道算法fifofcfs">磁盘寻道算法FIFO(FCFS)</h3><ol type="1"><li>例子<ul><li>请求到达顺序：11 -&gt; 1 -&gt; 36 -&gt; 16 -&gt; 34 -&gt; 9 -&gt;12</li><li>FIFO服务顺序：11 -&gt; 1 -&gt; 36 -&gt; 16 -&gt; 34 -&gt; 9 -&gt;12</li><li>FIFO寻道总距离：10 + 35 + 20 + 18 + 25 + 3 = 111</li></ul></li><li>好处<ul><li>公平性</li><li>磁盘请求的服务顺序是应用可以续期的</li></ul></li><li>坏处<ul><li>请求到来的随机性，经常长距离地寻道</li><li>可能发送极端情况，比如需要横扫整个磁盘</li></ul></li></ol><h3 id="磁盘寻道算法ssfshortest-seek-first">磁盘寻道算法SSF(ShortestSeek First)</h3><ol type="1"><li>方法<ul><li>选择磁头移动距离最短的请求（需要缓冲一部分请求）</li><li>计入旋转时间</li></ul></li><li>例子<ul><li>请求到达顺序：11 -&gt; 1 -&gt; 36 -&gt; 16 -&gt; 34 -&gt; 9 -&gt;12</li><li>SSF服务顺序：11 -&gt; 12 -&gt; 9 -&gt; 16 -&gt; 1 -&gt; 34 -&gt;36</li><li>SSF寻道总距离：1 + 3 + 7 + 15 + 33 + 2 = 61</li></ul></li><li>好处<ul><li>减少寻道时间</li></ul></li><li>坏处<ul><li>可能产生饥饿</li></ul></li></ol><h3 id="电梯调度scanlook">电梯调度(SCAN/LOOK)</h3><ol type="1"><li>方法<ul><li>磁头按一个方向到另一端，再折回，按反方向回到这端，不断往返</li><li>只服务当前移动方向上寻道距离最近的请求</li><li>LOOK：如果磁盘移动方向上没有请求，就折回</li></ul></li><li>例子<ul><li>请求到达顺序：11 -&gt; 1 -&gt; 36 -&gt; 16 -&gt; 34 -&gt; 9 -&gt;12</li><li>SCAN服务顺序：11 -&gt; 12 -&gt; 16 -&gt; 34 -&gt; 36 -&gt; 9 -&gt;1</li><li>SCAN寻道总距离：1 + 4 + 18 + 2 + 27 + 8 = 60</li></ul></li><li>好处<ul><li>消除饥饿、请求的服务时间有上限</li></ul></li><li>坏处<ul><li>反方向的请求需等到更长时间</li></ul></li></ol><h3 id="环路电梯调度c-scanc-look">环路电梯调度(C-SCAN/C-LOOK)</h3><ol type="1"><li>方法<ul><li>将SCAN改为折回时不服务请求，立即回到磁盘最外层重新向内扫描</li><li>寻道类似连起来成一个环</li></ul></li><li>好处<ul><li>服务时间趋于一致</li></ul></li><li>坏处<ul><li>折回时不干事</li></ul></li></ol><h2 id="磁盘调度算法对比">磁盘调度算法对比</h2><ol type="1"><li>调度算法<ul><li>FIFO：实现简单，但寻道时间长</li><li>SSF：贪心算法，可能造成饥饿现象（距离初始磁头位置较远的请求长期得不到服务）</li><li>SCAN/LOOK：减少饥饿</li><li>C-SCAN/C-LOOK：减少SCAN算法返回时的扫描开销</li></ul></li><li>磁盘I/O请求缓冲<ul><li>把请求缓冲在控制器缓冲区</li><li>缓冲时间取决于缓冲区大小</li></ul></li><li>进一步的优化<ul><li>既寻道最短，又旋转延迟最短</li></ul></li></ol><h1 id="raidredundant-array-of-independent-disks">RAID(Redundant Arrayof Independent Disks)</h1><ol type="1"><li>主要思想<ul><li>由多个磁盘构成一个存储设备</li></ul></li><li>好处<ul><li>提高性能：多个磁盘并行工作</li><li>增加容量：聚合多个磁盘的空间</li><li>提高可靠性：数据冗余，有磁盘损坏时，数据不损坏</li></ul></li><li>坏处<ul><li>控制器变得复杂</li></ul></li><li>牵扯的问题<ul><li>多块盘做块映射：逻辑块LBN -&gt; &lt;磁盘#,块#&gt;</li><li>如何通过冗余机制保护数据可靠性</li></ul></li></ol><h2 id="raid-0">RAID-0</h2><h3 id="raid-level-0">RAID Level 0</h3><ol type="1"><li>以条带（Stripe）为粒度映射到N块磁盘（轮转方式），条带宽度为N，即有N个条（strip）组成</li><li>1个Strip=K个块，即1个条由K个块组成</li><li>容量<ul><li>N * 单个磁盘容量（无冗余）</li></ul></li><li>可靠性<ul><li>（单个磁盘可靠性）^ N</li></ul></li><li>性能：<ul><li>带宽：N * 单个磁盘带宽</li><li>延迟：单个磁盘延迟</li></ul></li></ol><h3 id="raid-level-1">RAID Level 1</h3><ol type="1"><li>以镜像的形式存储<ul><li>镜像级别R：数据保存R份</li></ul></li><li>通常与RAID-0结合使用<ul><li>RAID-01 或 RAID-10</li></ul></li><li>容量<ul><li>(N * 单个磁盘容量) / R</li></ul></li><li>可靠性<ul><li>容忍任何一个磁盘坏</li><li>特殊情况下可以容忍N/R的磁盘坏</li></ul></li><li>性能<ul><li>写带宽：(N * 单个磁盘带宽) / R</li><li>读带宽：N * 单个磁盘带宽</li><li>延迟：单个磁盘延迟</li></ul></li></ol><h3 id="raid-level-4">RAID Level 4</h3><ol type="1"><li>条带化 + 1个校验块<ul><li>所有校验块在同一块磁盘上（校验盘）</li><li>缺点：校验盘为写性能瓶颈，易损坏</li></ul></li><li>每次写数据都需要更新校验快<ul><li>方法一：读所有的数据盘<ul><li>并行读所有磁盘的对应块</li><li>计算新校验块</li><li>并行写新块和新校验块</li></ul></li><li>方法二：读一个数据盘和校验盘<ul><li>并行读旧块和旧校验块</li><li>计算新校验块<ul><li>Pnew = (Bold ^ Bnew) ^ Pold</li></ul></li><li>并行写新块和新校验块</li></ul></li></ul></li><li>容量<ul><li>(N - 1) * 单个磁盘容量</li></ul></li><li>可靠性<ul><li>容忍任何一块磁盘坏</li><li>用XOR重构坏盘数据</li></ul></li><li>延迟<ul><li>读延迟等于单个磁盘的延迟</li><li>写延迟约等于2倍单个磁盘的延迟</li></ul></li><li>带宽<ul><li>读带宽 = (N-1)*单个磁盘带宽</li><li>校验盘为写瓶颈，所有校验块串行写</li></ul></li></ol><h3 id="raid-level-5">RAID Level 5</h3><ol type="1"><li>条带粒度映射 + 1个校验块<ul><li>校验块分散在不同磁盘上</li><li>Rebuild：复杂 &amp; 速度慢</li></ul></li><li>写带宽<ul><li>写并行：校验块并行写</li><li>写带宽：(N*单个磁盘带宽) / 4</li></ul></li><li>读带宽<ul><li>正常状态：只读数据块</li><li>读带宽：N*单个磁盘带宽</li></ul></li></ol><h2 id="其他raid级别">其他RAID级别</h2><ol type="1"><li>RAID Level 2<ul><li>按位为粒度映射 + ECC</li><li>每4位 + 3位海明码</li><li>所有磁盘同步读写：寻道 + 旋转</li></ul></li><li>RAID Level 3<ul><li>按位为粒度映射 + Parity位</li><li>已知坏磁盘时，可纠错</li></ul></li><li>RAID Level 6<ul><li>条带粒度映射 + 2个校验块</li><li>能容忍两块磁盘同时坏</li></ul></li></ol><h2 id="卷管理volume-manager">卷管理（Volume Manager）</h2><ol type="1"><li>虚拟块设备<ul><li>在多个磁盘上创建一个或多个逻辑卷</li><li>逻辑卷：一个虚拟块设备</li><li>采用RAID技术将逻辑卷的块地址映射到物理设备</li></ul></li><li>好处<ul><li>提供虚拟的容量和性能</li><li>容错</li></ul></li><li>实现<ul><li>OS内核的逻辑卷管理<ul><li>Windows MacOS Linux等</li></ul></li><li>存储设备控制器（存储系统）<ul><li>EMC Hitachi HP IBM NetApp</li><li>接口：PCIe iSCSI FC等</li></ul></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> Study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IO设备</title>
      <link href="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/IO%E8%AE%BE%E5%A4%87/"/>
      <url>/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/IO%E8%AE%BE%E5%A4%87/</url>
      
        <content type="html"><![CDATA[<h1 id="io设备">IO设备</h1><h2 id="设备控制器">设备控制器</h2><ol type="1"><li>控制设备的部件<ul><li>解析主机发来的命令，控制设备进行操作</li></ul></li><li>组成<ul><li>与主机的接口：主机与设备间传递命令、状态、数据<ul><li>硬件接口：PCIe SATA USB</li></ul></li><li>控制寄存器：1个或多个，控制设备操作<ul><li>写控制寄存器，命令设备执行指定的操作</li><li>读控制寄存器，获得设备的状态</li></ul></li><li>数据缓存区（data buffer）<ul><li>缓冲数据</li><li>使用主机端和设备内的DRAM缓冲数据</li><li>如果该缓冲区可用服务读请求，也将其视作数据缓存区</li></ul></li></ul></li></ol><h2 id="寻址">寻址</h2><ol type="1"><li>控制寄存器和设备数据缓冲区<ul><li>I/O端口：I/O地址空间(Port Mapped IO,PMIO)<ul><li>端口号：8位或16位的数值</li><li>I/O专用指令in/out（例如x86）：特权指令</li><li>控制线：指示CPU发出的地址是内存空间还是I/O空间</li><li>内存地址空间和I/O设备地址空间隔离</li></ul></li><li>内存映射I/O（Memory Mapped IO,MMIO）<ul><li>统一地址空间，内存地址空间预留一部分给I/O设备内存和寄存器</li><li>使用常规的访存指令（例如RISC指令集）</li><li>内存地址与I/O地址无重叠</li><li>CPU发出的地址，内存模块和所有设备都要解析</li></ul></li><li>两者可用结合<ul><li>控制寄存器采用I/O端口寻址</li><li>数据缓冲区采用内存映射I/O</li></ul></li><li>好处<ul><li>编程方便</li><li>保护方便 &amp; 灵活：利用虚存的保护机制</li><li>高效：访问数据缓冲区不需要专用指令</li></ul></li></ul></li><li>内核缓冲区<ul><li>为什么需要内核缓冲区<ul><li>生产者（应用）和消费者（IO设备）直接速度不匹配</li><li>字符设备、块设备速度较慢，适配不同的数据传输速率</li></ul></li><li>用作数据读缓冲<ul><li>可以服务对同一数据的读请求</li><li>减少实际访问设备的I/O请求</li></ul></li></ul></li></ol><h1 id="数据传输">数据传输</h1><ol type="1"><li>设备数据传输<ul><li>启动设备 + 数据传输</li><li>启动时间（开销）<ul><li>CPU用于启动设备进行操作的时间</li></ul></li><li>带宽<ul><li>启动设备后数据传输的速率（Bytes/Sec）</li></ul></li><li>延迟<ul><li>传输1字节的时间（启动时间 + 将1字节传输到目的地的时间）</li></ul></li></ul></li><li>通用方法：不同的传输速率<ul><li>字符设备：对字节流传输的抽象，键盘、串口、打印机等<ul><li>字节粒度访问：以若干字节为传输粒度，顺序读写</li></ul></li><li>块设备：对块传输的抽象，磁盘、光盘等<ul><li>块粒度访问：以若干块为传输粒度和存储粒度，按块寻址，整块读写，随机读写</li></ul></li></ul></li></ol><h2 id="数据传输方式">数据传输方式</h2><h3 id="pioprogrammed-io">PIO(Programmed IO)</h3><ol type="1"><li>例子：RS-232串口<ul><li>简单的串行控制器<ul><li>状态寄存器：就绪、忙、...</li><li>数据寄存器</li></ul></li></ul></li><li>输出数据时<ul><li>CPU:<ul><li>等待设备状态变为非"忙"</li><li>写数据到数据寄存器</li><li>通知设备"就绪"</li></ul></li><li>设备:<ul><li>等待直到状态变为"就绪"</li><li>消除"就绪"标志，设置"忙"标志</li><li>从数据寄存器中拿走数据</li><li>清除"忙"标志</li></ul></li></ul></li><li>PIO的轮询(Polling)<ul><li>CPU等待直到设备状态变为非"忙"</li><li>好处：简单</li><li>坏处：慢且浪费CPU资源</li><li>改进：使用中断机制可以避免CPU轮询</li></ul></li><li>支持中断的设备<ul><li>例如：鼠标</li><li>简单的鼠标控制器<ul><li>状态寄存器（完成、中断、...)</li><li>数据寄存器（X、Y、按键）</li></ul></li><li>输入数据时<ul><li>鼠标<ul><li>等待直到状态变为"完成"</li><li>将相应的值保存到数据寄存器</li><li>发中断</li></ul></li><li>CPU（中断处理）<ul><li>清除"完成"标志</li><li>将数据寄存器的值读到内核缓冲区（内存）中</li><li>置"完成"标志</li><li>调用调度器</li></ul></li></ul></li></ul></li></ol><h3 id="dmadirect-memory-access">DMA(Direct Memory Access)</h3><ol type="1"><li>基于数据寄存器的不足<ul><li>数据寄存器满后，发送中断请求，CPU进行中断处理</li><li>传输大量数据时，中断频繁，需要CPU频繁处理中断</li></ul></li><li>DMA的基本思想<ul><li>以数据块为单位进行传输，由DMA控制器控制完成外设与主机间的数据传输</li><li>DMA需要连续的内核缓冲区</li><li>CPU再数据开始传输前设置DMA控制器</li><li>数据传输结束后，DMA控制器发送中断给CPU，CPU再进行处理</li><li>减少占用CPU资源</li></ul></li><li>例子：磁盘<ul><li>简单的磁盘控制器<ul><li>状态寄存器（完成、中断、...)</li><li>DMA内存地址和字节数</li><li>DMA控制寄存器：命令、设备、传输模式及粒度</li><li>DMA数据缓冲区</li></ul></li><li>DMA写<ul><li>CPU：<ul><li>等待DMA设备状态为"就绪"</li><li>清除"就绪"</li><li>设置DMA命令为write,地址和大小</li><li>设置"开始"</li><li>阻塞当前的线程/进程</li></ul></li><li>磁盘控制器：<ul><li>DMA方式将数据传输到缓冲区(Count--;addr++)</li><li>当count==0时，发中断</li></ul></li><li>CPU（中断处理）<ul><li>将被该DMA阻塞的线程/进程加入到就绪队列</li></ul></li><li>磁盘<ul><li>将数据从缓冲区写入磁盘</li></ul></li></ul></li></ul></li></ol><h1 id="同步io-和-异步io">同步I/O 和 异步I/O</h1><h2 id="同步io">同步I/O</h2><ol type="1"><li>read()和write()将会阻塞用户进程，直到读写完成</li><li>在一个进程做同步I/O时，OS调度另一个进程执行</li></ol><h2 id="异步io">异步I/O</h2><ol type="1"><li>aio_read()和aio_write()不阻塞用户进程</li><li>在I/O完成以前，用户进程可以做别的事</li><li>I/O完成将通知用户进程</li></ol><h2 id="同步异步读过程">同步/异步读过程</h2><ol type="1"><li>用户进程P1调用read()系统调用</li><li>系统调用代码检查正确性和缓存</li><li>如果需要进行I/O，会调用设备驱动程序</li><li>设备驱动程序为读数据分配一个buffer，并调度I/O请求</li><li>启动DMA进行读传输</li><li>阻塞当前进程P1，调度另一个就绪的进程P2 // 异步I/O:直接跳到第12步</li><li>设备控制器进行DMA读传输</li><li>传输完时，设备发送一个中断请求</li><li>中断处理程序唤醒被阻塞的用户进程P1（将P1加入就绪队列</li><li>设备驱动检查结果（是否有错误），返回</li><li>将数据从内核buffer拷贝到用户buffer // 异步I/O:通知进程P1读操作完成</li><li>read系统调用返回到用户程序</li><li>用户进程继续执行</li></ol><h1 id="设备驱动">设备驱动</h1><ol type="1"><li>给操作系统的其它模块提供操作设备的API</li><li>与设备控制器交互<ul><li>与设备控制器交互以进行数据传输：命令、参数、数据</li></ul></li><li>主要功能<ul><li>初始化设备</li><li>解析OS发来的命令</li><li>多个请求的调度</li><li>管理数据传输</li><li>接收和处理中断</li><li>维护驱动与内核数据结构的完整性</li></ul></li></ol><h2 id="设备驱动的主要流程">设备驱动的主要流程</h2><ol type="1"><li>准备工作<ul><li>参数检查、请求格式转换</li><li>设备状态检查：忙 -&gt; 请求入队列</li><li>开设备或上电时执行</li></ul></li><li>操纵设备<ul><li>将控制命令写入设备的控制寄存器</li><li>检查设备状态：就绪 -&gt; 写下一命令</li><li>直到设备完成所有命令</li></ul></li><li>阻塞等待<ul><li>等待设备完成工作</li><li>被中断唤醒</li><li>有的设备不需要等待：如显示器</li></ul></li><li>错误处理<ul><li>检查设备状态：错误 -&gt; 重试</li></ul></li><li>返回调用者</li></ol><h2 id="设备驱动安装">设备驱动安装</h2><ol type="1"><li>静态安装设备驱动<ul><li>将设备驱动直接编译进内核，系统启动后可以直接调用</li><li>新设备的使用需要重启OS</li><li>设备驱动修改效率不高，需要重新编译内核</li></ul></li><li>动态挂载设备驱动<ul><li>将驱动动态加载进内核空间</li><li>不需要重启，而是采用间接指针<ul><li>设备入口点表：所有设备的入口点</li></ul></li><li>安装入口点，维护相关的数据结构</li><li>加载 / 删除设备驱动<ul><li>分配内核空间 / 删除内核空间</li><li>存储驱动代码 / 删除驱动代码</li><li>与入口点关联 / 删除入口点</li></ul></li></ul></li></ol><h2 id="设备驱动的利与弊">设备驱动的利与弊</h2><ol type="1"><li>灵活性：<ul><li>用户可以下载和安装设备驱动</li><li>灵活接入不同硬件设备</li></ul></li><li>安全隐患<ul><li>设备驱动运行于内核态</li><li>有bug的设备驱动会导致内核崩溃，或者引入安全漏洞</li></ul></li><li>如何让设备驱动更安全<ul><li>检查设备驱动的代码</li><li>为设备驱动构建状态机模型进行检查</li></ul></li><li>用户态驱动：面向高速设备，提升性能</li></ol>]]></content>
      
      
      <categories>
          
          <category> Study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚存设计关键问题</title>
      <link href="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%99%9A%E5%AD%98%E8%AE%BE%E8%AE%A1%E5%85%B3%E9%94%AE%E9%97%AE%E9%A2%98/"/>
      <url>/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%99%9A%E5%AD%98%E8%AE%BE%E8%AE%A1%E5%85%B3%E9%94%AE%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="虚存设计">虚存设计</h1><ol type="1"><li>设计目标<ul><li>保护<ul><li>隔离进程之间的错误</li></ul></li><li>虚拟化<ul><li>用磁盘来扩展物理内存的容量</li><li>方便用户进行编程（进程地址空间从0-max）</li></ul></li></ul></li><li>虚存设计时要考虑的问题<ul><li>虚实映射<ul><li>映射机制：分段/分页</li><li>映射加速：TLB/TLB Miss/TLB表项数目</li><li>映射开销：页大小和页表大小</li></ul></li><li>按需加载和页替换<ul><li>缺页处理</li><li>页替换：替换算法/颠簸/pin和unpin</li><li>后备存储：Swap</li></ul></li><li>虚存使用<ul><li>清零</li><li>Copy on Write</li><li>共享内存</li></ul></li></ul></li></ol><h1 id="虚存设计问题-虚实映射设计问题">虚存设计问题 ——虚实映射设计问题</h1><h2 id="页大小">页大小</h2><ol type="1"><li>大页<ul><li>好处：页表小 且 磁盘I/O高效</li><li>不足：内部碎片<ul><li>进程执行不需要的部分也放进了内存</li><li>页可能不满，存在浪费</li></ul></li></ul></li><li>小页<ul><li>好处：减少内部碎片</li><li>不足：页表大<ul><li>占用更多的内存</li><li>加载时间更长</li><li>查找虚页的时间更长</li></ul></li><li>不足：磁盘I/O不够高效<ul><li>进程加载、页替换</li></ul></li></ul></li></ol><h1 id="虚存设计问题-页替换设计问题">虚存设计问题 —— 页替换设计问题</h1><h2 id="颠簸">颠簸</h2><ol type="1"><li>颠簸的概念<ul><li>频繁发生缺页，运行速度很慢</li><li>进程被阻塞，等待页从磁盘取进内存</li><li>从磁盘中读入一页<sub>10ms，执行一条指令</sub>几ns</li></ul></li><li>虚存访问时间<ul><li>请求平均访问时间 = h*内存访问时间 +(1-h)*磁盘访问时间（h：命中率）</li><li>例如：假设内存访问时间 = 100ns，磁盘访问时间 = 10ms，h=0.9<ul><li>请求平均访问时间 = 0.9*100ns + 0.1*10ms = 1.0009ms</li></ul></li></ul></li><li>颠簸的原因<ul><li>进程的工作集 &gt; 可用的物理内存</li><li>进程过多，即使单个进程都小于内存</li><li>内存没有被很好地回收利用</li></ul></li><li>如何避免<ul><li>多进程时，哪些工作集放进内存</li><li>多进程时，如何分配页</li></ul></li></ol><h3 id="多进程时哪些工作集放进内存">多进程时，哪些工作集放进内存</h3><ol type="1"><li>将进程分为两组<ul><li>活跃组：工作集加载进内存</li><li>不活跃组：工作集不加载进内存</li></ul></li><li>如果确定哪些进程是不活跃的<ul><li>等待事件（键盘、鼠标等IO设备）</li><li>等待资源</li><li>典型方法是设定一个等待时间阈值，如果超过了这个阈值则被称为不活跃进程</li></ul></li><li>两种调度器<ul><li>长期调度器（准入调度器）决定<ul><li>哪些进程可以同时运行（CPU vs I/O，工作集之和，...）</li><li>哪些进程是不活跃的进程，将它们换出到磁盘</li><li>哪些进程是活跃的进程，将它们换入到内存</li></ul></li><li>短期调度器（CPU调度器）执行CPU调度算法，决定<ul><li>把CPU分配给哪个活跃进程</li></ul></li></ul></li></ol><h3 id="多进程时如何分配页">多进程时，如何分配页</h3><ol type="1"><li>多个进程同时运行的时候，替换哪个进程的页框？<ul><li>全局分配<ul><li>从所有进程的所有页框中选择</li></ul></li><li>局部分配<ul><li>只从本进程（发生缺页的进程）的页框中选择</li></ul></li></ul></li><li>全局分配 vs 局部分配<ul><li>全局分配<ul><li>从所有进程的所有页框中选择</li><li>可替换其他进程的页框</li><li>每个进程运行期间，其内存大小是动态变化的</li><li>好处：全局资源调配</li><li>坏处：没有隔离，干扰其他进程/收到其他进程的页替换干扰<ul><li>不能控制各个进程的内存使用量</li></ul></li></ul></li><li>局部分配<ul><li>只能从本进程（发生缺页的进程）自己的页框中选择</li><li>一个进程运行期间，固定其内存大小不变<ul><li>页框池：分配给进程的页框的集合，不同进程的页框池大小可不同</li></ul></li><li>好处：隔离，不影响其他进程</li><li>坏处：不灵活<ul><li>进程使用内存频繁会产生颠簸</li><li>难以充分利用内存：每个进程对内存的需求不一样</li></ul></li></ul></li></ul></li></ol><h3 id="平衡分配">平衡分配</h3><ol type="1"><li>局部分配 + 池大小动态调整<ul><li>每个进程有自己的页框池（pool）</li><li>从自己的池中分配页，且从自己的工作集中替换页</li><li>用一种机制来运行时动态调整每个池的大小<ul><li>初始大小 + 动态调整</li></ul></li></ul></li><li>进程加载方式：进程换入时<ul><li>纯粹的按需加载页：加载较慢</li><li>预加载：先加载部分页 -&gt; 初始池大小</li><li>初始池大小约等于工作集的大小</li></ul></li><li>初始池大小<ul><li>固定大小：所有进程都一样</li><li>平均分配</li><li>根据进程大小按照比例分配</li></ul></li><li>动态调整池大小：进程大小变化<ul><li>PFF算法（Page Fault Frequency）<ul><li>缺页率 PFR：进程每秒产生多少次缺页</li><li>对应大多数替换策略，PFR随分配给进程的内存增加而减少</li></ul></li><li>根据进程的PFR来调整分配给它的内存量（pool size）<ul><li>当PFR高于A，就增加其内存（pool 增大）</li><li>当PFR低于B，就缩小其内存（pool 减小）</li></ul></li><li>PFR的计算<ul><li>方法1：只看当前1秒钟内的缺页次数Ri</li><li>方法2：求滑动均值<ul><li>例如 <span class="math inline">\(PFR_i = (R_i + PFR_{i-1}) /2\)</span></li></ul></li></ul></li></ul></li></ol><h2 id="后备存储">后备存储</h2><ol type="1"><li>交换区（Swap Area）<ul><li>在磁盘上</li><li>专门用于存储进程换出页</li><li>交换分区（Swap Partition）<ul><li>用专门的磁盘分区保存专门的换出数据</li></ul></li><li>交换文件<ul><li>用文件保存换出的数据</li></ul></li></ul></li><li>交换空间分配<ul><li>静态分配<ul><li>创建进程时分配，进程结束时回收</li><li>大小：进程映像</li><li>进程控制块记录交换空间的磁盘地址</li><li>绑定：一个虚存页 &lt;-&gt; 一个磁盘页<ul><li>磁盘页称为shadow page</li></ul></li><li>初始化：两种方法<ul><li>页换出：进程映像拷贝到交换区</li><li>页换入：进程映像加载进内存</li></ul></li><li>缺点：难以增长（栈段/堆）</li></ul></li><li>动态分配<ul><li>创建进程时不分配</li><li>页换出时分配，页换入时回收</li><li>虚页和磁盘页不绑定<ul><li>多次换出，分配不同的磁盘页</li></ul></li><li>PTE中记录页的磁盘地址</li><li>一个优化：程序text段<ul><li>直接用磁盘上的可执行文件作为交换区，减少交换区的大小</li><li>换出时直接丢弃（只读的），减少不必要的写回</li></ul></li></ul></li></ul></li><li>页地址转换<ul><li>PTE： 虚页 -&gt; 页框和磁盘<ul><li>如果valid bit=1，物理页号pp#</li><li>如果valid bit=0，磁盘页号dp#</li></ul></li><li>换出<ul><li>将PTE和TLB置为无效</li><li>把页拷贝到磁盘</li><li>将磁盘页号写回PTE</li></ul></li><li>换入<ul><li>找一个空闲页框（可能触发页替换）</li><li>将页从磁盘拷贝到这个页框中</li><li>将页框号填入PTE中，并将PTE置为有效</li></ul></li></ul></li></ol><h2 id="钉住页pinunpin">钉住页（pin/unpin）</h2><ol type="1"><li>为什么需要？<ul><li>有些页需要频繁访问，换出后又会被换入，影响系统性能</li><li>数据再内外存间进行传输时，需要传输的页框不能被换出，否则CPU会把新内容写入这些页框</li></ul></li><li>如何设计？<ul><li>用一个数据结构来记录所有钉住的页</li><li>换页算法在替换页时检查该数据结构<ul><li>如果页被钉住，则不替换它，重新再选择一页</li></ul></li></ul></li></ol><h1 id="虚存设计问题-页使用设计问题">虚存设计问题 —— 页使用设计问题</h1><h2 id="清零页">清零页</h2><ol type="1"><li>将页清零<ul><li>把页置成全0</li><li>堆和栈的数据都要初始化</li></ul></li><li>如何实现<ul><li>对于堆和栈段中的页，当它们第一次发生page fault时，将他们清零</li><li>可以通过一个专门的线程来实现清零</li></ul></li><li>不做页清零可能会引起安全问题</li></ol><h2 id="写时复制copy-on-write">写时复制（Copy-On-Write）</h2><ol type="1"><li>该技术用于创建子进程（fork系统调用）</li><li>原理<ul><li>子进程的地址空间使用其父进程相同的映射</li><li>将所有的页置成 read-only</li><li>将子进程置成就绪</li><li>对于读，可以随意读</li><li>对于写，产生page fault<ul><li>修改PTE，映射到一个新的物理页</li><li>将页内容全部拷贝到新物理页</li><li>重新运行发生缺页的指令</li></ul></li></ul></li></ol><h2 id="进程间共享内存">进程间共享内存</h2><ol type="1"><li>两个进程的页表共享一些物理页<ul><li>进程间通信</li><li>进程间数据共享</li></ul></li><li>涉及问题<ul><li>共享页的换入换出<ul><li>可能会影响到多个进程，需要使用pin/unpin钉住页</li></ul></li><li>有共享页的进程的工作集<ul><li>共享页优先进入工作集</li></ul></li><li>有共享页的进程结束<ul><li>根据情况确定是否释放共享页</li></ul></li></ul></li></ol><h1 id="unix-和-linux-的虚存机制">UNIX 和 Linux 的虚存机制</h1><h2 id="unix的地址空间">UNIX的地址空间</h2><ol type="1"><li>Text段：只读 &amp; 大小不变</li><li>数据段<ul><li>初始化数据</li><li>未初始化数据：BSS段</li><li>Heap区</li></ul></li><li>栈段</li><li>内存映射文件（Memory Mapped File）<ul><li>将一个文件映射进虚存，并像访问内存一样访问文件</li><li>mmap 和 unmap</li></ul></li></ol><h2 id="bsd4的虚存">BSD4的虚存</h2><ol type="1"><li>物理内存划分<ul><li>Core map(pin): 所有页框的描述信息</li><li>内核(pin)</li><li>其它页框：给用户进程</li></ul></li><li>页替换<ul><li>运行换页守护进程(page daemon)，直到有足够的空闲页</li><li>早期BSD使用原始的Clock替换算法（FIFO with Second Chance）</li><li>后来的BSD使用双表针的Clock算法</li><li>如果page daemon找不到足够多的空闲页的话，则运行swapper<ul><li>寻找idle时间超过20秒及以上的进程</li><li>最大的4个进程</li></ul></li></ul></li></ol><h2 id="linux的地址空间">Linux的地址空间</h2><ol type="1"><li>32位机的地址空间<ul><li>3GB 的用户空间</li><li>1GB 的内核空间</li></ul></li><li>栈段从3GB位置向下增长<ul><li>初始时保存进程的环境变量和命令行参数</li></ul></li><li>数据段<ul><li>大小可变</li><li>BSS段：未初始化的全局变量<ul><li>页加载时初始为0</li><li>zero page: 避免分配大量全0的物理页</li></ul></li></ul></li><li>系统调用<ul><li>brk(addr) —— change data segment size</li><li>mmap(addr,len,prot,flags,fd,offset) —— Map a file in</li><li>unmap(addr,len) —— Unmap a file</li></ul></li><li>Linux的地址转换<ul><li>2.6.11及之后的Linux都是使用4级页表<ul><li>虚地址划分为5段: GDT UDT MDT PT 和 Offset</li><li>如何支持2级页表的MMU（例如Pentium）<ul><li>通过将UDT和MDT都设置为只有一个表项</li></ul></li></ul></li></ul></li><li>Linux的物理页分配<ul><li>伙伴算法<ul><li>初始时：只有一个段，含全部可用空间</li><li>分配空间，m页：找size&gt;=m 且 size最小的段，假设其为n</li><li>如果n&gt;=2m，则将该段对分为两个size=n/2的段</li><li>重复对分，直到n&gt;=m&gt;n/2</li><li>释放空间：m页，如果其伙伴也是空闲的，则不断合并它们，直到找不到空闲伙伴为止</li></ul></li><li>数据结构<ul><li>空闲链表数组：每条链上的页大小为2的幂</li></ul></li></ul></li><li>Linux的页替换<ul><li>方法<ul><li>保持一定数量的空闲页</li><li>文件缓存（page cache）使用Clock算法</li><li>未使用的共享页使用Clock算法</li><li>用户进程的内存使用改进的Clock算法<ul><li>两条链</li><li>Active List：所有进程的工作集</li><li>Inactive List：回收的候选页</li><li>Refill是将页从active list移动到inactive list</li></ul></li></ul></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> Study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>按需加载与页替换</title>
      <link href="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%8C%89%E9%9C%80%E5%8A%A0%E8%BD%BD%E4%B8%8E%E9%A1%B5%E6%9B%BF%E6%8D%A2/"/>
      <url>/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%8C%89%E9%9C%80%E5%8A%A0%E8%BD%BD%E4%B8%8E%E9%A1%B5%E6%9B%BF%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="缺页与换页">缺页与换页</h1><h2 id="进程加载">进程加载</h2><ol type="1"><li>简单方法<ul><li>将整个进程加载进内存 -&gt; 运行它 -&gt; 退出</li></ul></li><li>问题<ul><li>慢（特别是对于大的进程）</li><li>浪费空间（一个进程并不是每时每刻都需要所有的内存）</li></ul></li><li>解决办法<ul><li>按需加载页：只将实际使用的页加载进内存</li><li>换页：内存空间有限，只放频繁使用的那些页</li></ul></li><li>机制<ul><li>一部分虚存映射到内存，另一部分虚存映射到磁盘</li></ul></li></ol><h2 id="缺页处理">缺页处理</h2><ol type="1"><li>内存访问（先查TLB）</li><li>若TLB不命中，则进行页表查找，找到PTE</li><li>若PTE的valid位=0（页不在内存），则触发缺页（Page Fault）</li><li>虚存管理中的缺页处理接管控制，将页从磁盘读到内存</li><li>更新PTE：填入PP#，将Valid位置1</li><li>重新执行该指令：重新进行内存访问</li></ol><blockquote><p>发生缺页后，如何切换到缺页处理？</p></blockquote><ul><li>缺页可能发生在一条指令执行的中途</li><li>应用程序透明：必须让用户程序不感知缺页</li><li>需要保存状态并从断点处继续执行</li></ul><h2 id="页替换">页替换</h2><ol type="1"><li>需要的页不再内存里 -&gt; 需换入 -&gt; 需为它分配一个页框</li><li>可能此时没有空闲页框 -&gt; VM需要进行页替换</li></ol><h2 id="包含页替换的缺页处理算法">包含页替换的缺页处理算法</h2><ol type="1"><li>进程A发生缺页，发生缺页的页记为VP<ul><li>陷入内核，保存进程A的当前状态: PC和寄存器</li><li>调用OS的缺页处理模块<ul><li>检查地址和操作类型的合法性，若不合法则终止进程</li><li>为VP分配一个物理页框，记为PP<ul><li>如果有空闲页框PP1，则用它，记PP=PP1</li><li>如果没有空闲页框，选择一个状态为used页框PP2<ul><li>如果他是脏的(M位=1)，则把它写回磁盘</li><li>PTE表项的valid置0，刷新TLB</li><li>写回完成后，PP=PP2</li></ul></li></ul></li><li>找到VP对应的磁盘页，把它读到这个页框(PP)中</li><li>修改VP的PTE：填入PP#，将valid位置1，并把该PTE加载进TLB</li></ul></li><li>恢复进程A的状态，重新执行发生缺页的指令</li></ul></li><li>通用数据结构<ul><li>空闲页框链表</li><li>一张映射表：页框-&gt;PID和虚页</li></ul></li></ol><h1 id="页替换算法">页替换算法</h1><ol type="1"><li>随机选一页</li><li>最优算法（MIN）</li><li>NRU(Not Recently Used)</li><li>FIFO(First-In-First-Out)</li><li>FIFO with Second Chance</li><li>NFU(Not Frequently Used)</li><li>LRU(Least Recently Used)</li><li>Aging(Approximate LRU)</li><li>Clock</li><li>Working Set</li><li>WSClock</li></ol><h2 id="最优算法min">最优算法（MIN）</h2><ol type="1"><li>算法<ul><li>替换在未来最长一段时间里不用的页</li><li>前提：知道未来所有的访问</li></ul></li><li>例子<ul><li>内存大小为4个页</li><li>访问序列：<strong>1,2,3,4</strong>,1,2,<strong>5</strong>,1,2,3,<strong>4</strong>,5</li><li>一共发生6次缺页</li></ul></li><li>好处<ul><li>是最优的方案，可以作为一种离线的分析手段</li></ul></li><li>坏处<ul><li>在线系统无法采用，因为不知道未来访问的顺序</li><li>没有线性时间复杂度的实现</li></ul></li></ol><h2 id="fifo">FIFO</h2><ol type="1"><li>算法<ul><li>选择最老的页扔掉</li></ul></li><li>例子<ul><li>内存大小为4个页</li><li>访问序列：<strong>1,2,3,4</strong>,1,2,<strong>5,1,2,3,4,5</strong></li><li>一共发生10次缺页</li></ul></li><li>好处<ul><li>实现开销最小</li></ul></li><li>坏处<ul><li>频繁使用的页被替换</li></ul></li></ol><blockquote><p>能否通过增加页的数量来减少缺页？</p></blockquote><ol type="1"><li>假设内存大小为3个页，访问序列：<strong>1,2,3,4,1,2,5</strong>,1,2,<strong>3,4</strong>,5，只发生9次缺页</li><li>"Belady'sAnomaly"现象：采用FIFO算法时，有时会出现分配页数增多，缺页次数反而升高的异常现象</li></ol><h2 id="fifo-with-second-chance">FIFO with Second Chance</h2><ol type="1"><li>核心思想<ul><li>尽量让频繁使用的页留在内存，不被替换</li><li>替换时给访问过的页第二次机会，在内存中呆更长的时间</li></ul></li><li>算法<ul><li>检查最老页的R位，如果为0，则将其替换</li><li>如果为1，则将R位清0，将该页移到队尾，继续查找</li></ul></li><li>例子<ul><li>内存大小为4个页</li><li>访问序列：<strong>1,2,3,4</strong>,1,2,<strong>5</strong>,1,2,<strong>3,4,5</strong></li><li>一共发生8次缺页</li></ul></li><li>好处<ul><li>实现简单</li></ul></li><li>坏处<ul><li>最坏情况可以需要很长时间</li></ul></li></ol><h2 id="clock">Clock</h2><ol type="1"><li>改进Second Chance的替换开销<ul><li>移动开销</li></ul></li><li>算法：把所有页框组织成环形链表<ul><li>用一个表针指向最老的页</li><li>发生缺页的时候，按表针走动方向来检查页</li><li>第二次机会<ul><li>如果R位为1，则将R位清0，且表针向前移一格</li><li>如果R位为0，则将该页替换，且表针向前移一格</li></ul></li></ul></li><li>与Second Chance算法相比<ul><li>更加高效</li></ul></li><li>如果内存很大<ul><li>轮转一遍需要很长的时间</li></ul></li></ol><h2 id="lru">LRU</h2><ol type="1"><li>替换最长时间没有使用的页<ul><li>将所有页框组织成一个链表</li><li>前端为最久未访问页（LRU端）：替换的页</li><li>后端为最近刚访问的页（MRU端）：新加载的页和命中的页</li><li>每次命中将页重新插入 MRU 端</li></ul></li><li>例子<ul><li>内存大小为4个页</li><li>访问序列：<strong>1,2,3,4</strong>,1,2,<strong>5</strong>,1,2,<strong>3,4,5</strong></li><li>一共发生8次缺页</li></ul></li><li>好处<ul><li>对 MIN 算法的很好近似</li></ul></li><li>坏处<ul><li>实现困难</li></ul></li></ol><h2 id="nrunot-recently-used">NRU（Not Recently Used）</h2><ol type="1"><li>算法<ul><li>按下面顺序，随机选择一个页<ul><li>未访问过 且 未修改过</li><li>未访问过 且 修改过</li><li>访问过 且 未修改过</li><li>访问过 且 修改过</li></ul></li></ul></li><li>例子<ul><li>内存大小为4个页</li><li>访问序列：<strong>1,2,3,4</strong>,1,2,<strong>5</strong>,1,2,<strong>3,4</strong>,5</li><li>一共发生7次缺页</li></ul></li><li>好处<ul><li>实现简单</li></ul></li><li>坏处<ul><li>需要扫描内存中所有页的R位和M位</li></ul></li></ol><h2 id="lfuleast-frequently-used">LFU（Least Frequently Used）</h2><ol type="1"><li>算法：记录每个页的访问次数，替换访问次数最少的页<ul><li>每页有一个访问计数器，用软件模拟</li><li>每个时钟中断时，所有页的计数器分别和它的R位值相加</li></ul></li><li>例子<ul><li>内存大小为4个页</li><li>访问序列：<strong>1,2,3,4</strong>,1,2,<strong>5</strong>,1,2,<strong>3,4,5</strong></li><li>一共发生8次缺页</li></ul></li><li>坏处<ul><li>过去访问频繁、现在不访问的页，可能无法被替换出去</li></ul></li></ol><h2 id="aging">Aging</h2><ol type="1"><li>在LFU的基础上消除过去访问的影响<ul><li>每个时钟中断时，先将所有页计数器右移1位，再将每页计数器最高位与该页的R位相加</li><li>替换时，选择计数器最小的页</li></ul></li><li>Aging 和 LRU 的主要差别<ul><li>记录下来的历史更短（计数器长度）</li><li>无法区分访问的先后顺序（同一个tick内）</li></ul></li><li>Aging需要多少位才够用<ul><li>实际工作中8位就工作的很好</li></ul></li></ol><h2 id="working-set">Working Set</h2><ol type="1"><li>主要思想<ul><li>80/20原则<ul><li>80%的访问只涉及20%的内存空间</li><li>80%的访问都来自20%的代码</li></ul></li><li>空间局限性<ul><li>相邻的页很可能会被访问</li></ul></li><li>时间局限性<ul><li>被访问的页很可能在不远的将来再被访问</li></ul></li></ul></li><li>工作集的概念<ul><li>工作集被定义为在最近K次访问的那些页</li><li>把工作集放在内存能大大地减少缺页</li><li>工作集可以近似为过去T秒钟里使用的页</li></ul></li><li>算法：记录页的"上次访问时间"<ul><li>在缺页处理时，扫描该进程所有的页</li><li>如果R位为1，将该页的上次访问时间设置为当前时间</li><li>如果R位为0，计算当前时间和上次访问时间之差<ul><li>如果差值大于T，则该页在过去T秒里没有被访问过，则替换它</li><li>否则，检查下一页</li></ul></li><li>将发生缺页的页加入工作集</li></ul></li></ol><h2 id="wsclock">WSClock</h2><ol type="1"><li>将 Working Set类似的组织成环形链表（类似 Clock）</li><li>按表针走动的顺序来检查页</li><li>如果R位为1<ul><li>将R位置成0，该页的上次访问时间设置为当前时间</li><li>检查下一页</li></ul></li><li>如果R位为0<ul><li>设差值为 当前时间-上次访问时间</li><li>如果该值小于等于T，则代表在过去T秒里被访问过，检查下一页</li><li>如果该值大于T，则代表在过去T秒里没有被访问过<ul><li>若M位为1，则将该页写回加入写回链表（异步进行写回），并检查下一页</li><li>若M位为0，则将该页替换出去</li></ul></li></ul></li></ol><h2 id="总结">总结</h2><ol type="1"><li>LRU很好但是实现困难，Aging是一个很好的近似LFU</li><li>Clock被认为是一个很好的实际解决方案</li><li>所有的替换算法都不会优化由Cold Miss带来的缺页</li></ol><table><colgroup><col style="width: 50%" /><col style="width: 50%" /></colgroup><thead><tr class="header"><th style="text-align: center;">算法</th><th style="text-align: center;">特点</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">MIN</td><td style="text-align: center;">最优算法，但无法在实际系统中实现</td></tr><tr class="even"><td style="text-align: center;">FIFO</td><tdstyle="text-align: center;">没有考虑重复访问的情况，仅根据第一次访问时的顺序进行替换</td></tr><tr class="odd"><td style="text-align: center;">Second Chance</td><td style="text-align: center;">在FIFO的基础上考虑了重复访问</td></tr><tr class="even"><td style="text-align: center;">Clock</td><td style="text-align: center;">基于SecondChance，可以更加高效的实现</td></tr><tr class="odd"><td style="text-align: center;">LRU</td><tdstyle="text-align: center;">考虑了访问时效性，实现时有频繁链表操作，开销较大</td></tr><tr class="even"><td style="text-align: center;">NRU</td><tdstyle="text-align: center;">粗粒度近似LRU，只区分有无访问，同时优先保留脏页；与LRU比，时效性考虑较少</td></tr><tr class="odd"><td style="text-align: center;">LFU</td><tdstyle="text-align: center;">考虑访问的次数，将访问次数多的数据留在内存中；容易受短期高频访问的影响</td></tr><tr class="even"><td style="text-align: center;">Aging</td><tdstyle="text-align: center;">近似LFU，更容易实现；记录窗口短；相同访问次数时，无法区分时效性</td></tr><tr class="odd"><td style="text-align: center;">Working Set</td><td style="text-align: center;">实现开销大</td></tr><tr class="even"><td style="text-align: center;">WSClock</td><tdstyle="text-align: center;">基于WS优化实现时的数据结构（环形链表），实现开销小</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚存和地址转换</title>
      <link href="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%99%9A%E5%AD%98%E5%92%8C%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2/"/>
      <url>/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%99%9A%E5%AD%98%E5%92%8C%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机存储体系结构">计算机存储体系结构</h1><ol type="1"><li><p>冯·诺依曼结构</p></li><li><p>层次化存储结构</p><ul><li>内存DRAM：快、容量小、易丢失、昂贵</li><li>外存磁盘：慢、容量大、不易丢失、便宜</li></ul></li></ol><h2 id="需求一进程保护">需求一：进程保护</h2><ol type="1"><li>一个进程出错不能影响到其他进程</li><li>需要对每个内存访问都进行检查，保证内存访问都合法</li></ol><h2 id="需求二扩展内存和应用透明">需求二：扩展内存和应用透明</h2><ol type="1"><li>一个进程必须能运行再不同的物理内存区域上</li><li>一个进程必须能运行在不同的物理内存大小上</li></ol><h2 id="问题如何高效地使用内存空间">问题：如何高效地使用内存空间？</h2><ol type="1"><li>目标1：同时运行多个进程<ul><li>系统能够运行的进程越多越好</li></ul></li><li>目标2：地址空间足够大<ul><li>一个大进程，其大小超过物理内存</li><li>多个小进程，其大小总和超过物理内存</li></ul></li><li>目标3：保护<ul><li>一个用户进程不能读取和修改其他用户进程的内存</li><li>用户进程不能破坏内核使用的内存空间</li></ul></li></ol><h2 id="解决方案虚拟内存">解决方案：虚拟内存</h2><ol type="1"><li>基本内存抽象<ul><li>地址空间：进程的内存视图 -&gt; 虚拟内存</li><li>透明使用、高效访问、安全保护</li></ul></li><li>虚拟内存 vs 虚拟CPU<ul><li>虚拟CPU<ul><li>进程不与CPU绑定，可以迁移到任一CPU</li><li>进程执行时，自以为独占了CPU</li><li>进程CPU状态与切换：通过上下文</li></ul></li><li>虚拟内存<ul><li>进程数据不与物理内存绑定，可以迁移到任意的内存/磁盘空间</li><li>进程执行时，自以为独占了内存</li><li>进程内存状态：通过swap到磁盘上进行保存</li></ul></li></ul></li></ol><h1 id="虚拟内存">虚拟内存</h1><ol type="1"><li>独立的（进程）地址空间<ul><li>给每个进程提供一个很大的、静态的"虚拟"内存空间</li></ul></li><li>虚实地址转换<ul><li>进程运行时，每次访存通过地址转换获得实际的物理内存地址</li></ul></li><li>磁盘作为内存的延展（磁盘交换区）<ul><li>按需加载：只装载部分地址空间到物理内存</li></ul></li></ol><h2 id="地址空间">地址空间</h2><ol type="1"><li>独立的进程地址空间 [0,MAX-1]<ul><li>程序员能够看到的是虚地址</li></ul></li><li>运行时装载部分地址空间</li><li>每次访存：虚地址-&gt;物理地址<ul><li>CPU 和 进程 看到的是虚地址</li><li>内存 和 I/O设备 看到的是物理地址</li></ul></li><li>如果访问到未装载的地址空间<ul><li>通过OS将它加载进内存</li></ul></li></ol><h2 id="虚存的好处">虚存的好处</h2><ol type="1"><li>灵活<ul><li>进程在执行时才会被放进内存，另一部分在内存/磁盘中</li></ul></li><li>简单<ul><li>进程的内存访问变得简单</li></ul></li><li>高效<ul><li>20/80原则：20%的地址空间承担了80%的访问</li><li>将20%地址空间放进物理内存</li></ul></li><li>安全<ul><li>虚实地址转换时进行安全检查，防止非法访问</li></ul></li></ol><h1 id="地址映射">地址映射</h1><h2 id="目标">目标</h2><ol type="1"><li>隐式：对每个内存访问，转换是隐式的，用户程序不感知</li><li>快速：有转换关系的时候，访存速度非常快</li><li>例外：没有转换关系时会触发一个例外</li><li>保护：能够隔离用户进程的错误</li></ol><h2 id="地址映射和粒度">地址映射和粒度</h2><ol type="1"><li>需要某种"映射"机制<ul><li>把虚地址空间（大）的内容 放进 物理内存空间（小）</li></ul></li><li>映射必须有合适的粒度<ul><li>粒度决定灵活性</li><li>大粒度映射可能造成内存浪费</li><li>细粒度映射则需要更多的映射信息</li></ul></li><li>极端情况<ul><li>字节粒度映射：映射表过大</li><li>进程粒度映射：内存浪费</li></ul></li></ol><h2 id="基址-长度cray-1中采用的方法">基址 +长度（Cray-1中采用的方法）</h2><ol type="1"><li>连续分配<ul><li>为每个进程分配地址连续的内存空间</li><li>用一个二元组来限定其内存区域: &lt;base,bound&gt;</li></ul></li><li>保护<ul><li>一个进程只能访问[base,base+bound]区间的内存</li></ul></li><li>上下文切换<ul><li>保存/恢复 基址寄存器</li></ul></li><li>好处<ul><li>简单：映射时将虚地址和基地址相加</li><li>支持换出(swapping)：多进程并发执行</li></ul></li><li>坏处<ul><li>外部碎片（进程间的碎片）</li><li>难以支持进程增大</li><li>难以共享内存</li></ul></li></ol><blockquote><p>内存碎片：随着进程的换入与换出，内存会产生很多空洞（未使用的小区域）</p></blockquote><h2 id="分段">分段</h2><ol type="1"><li>不连续分配<ul><li>把程序逻辑上划分为若干段：代码、全局变量、栈</li><li>每个段分配连续内存，段间不必连续</li><li>每个进程有一张段表</li><li>每个段采用基址 + 长度</li></ul></li><li>保护<ul><li>每个段有不同的权限（Read,Write,Exec)</li></ul></li><li>上下文切换<ul><li>保存/恢复 段表和指向段表的内核指针</li></ul></li><li>好处<ul><li>相比于基址 + 长度，资源使用更高效</li><li>易共享</li></ul></li><li>不足<ul><li>管理的复杂度增加</li><li>仍然存在外部碎片（段间碎片）</li></ul></li></ol><h3 id="虚实地址转换过程">虚实地址转换过程</h3><p>Virtual Address = Seg# + Offset Seg# 通过 Segment Table 映射到Physical Address</p><p>如果 offset &gt; 段Size， 则触发 Memory Violation异常如果访问地址所在的 Seg# 的 Valid 为0，则触发 Segment Fault异常</p><h2 id="分页">分页</h2><ol type="1"><li>分页机制<ul><li>使用固定大小的映射单元</li><li>把虚存划分成固定大小的单元（称为页 Page）</li><li>把物理内存划分成同样大小的单元（称为页框 Page Frame）</li><li>按需加载（On-Demand Paging）</li></ul></li><li>用页表来记录映射<ul><li>虚页 -&gt; 物理页</li></ul></li><li>每个表项都有若干个控制位<ul><li>按页进行保护（Read,Write,Exec)</li></ul></li><li>上下文切换<ul><li>与分段类似，保存/恢复页表及其地址</li></ul></li><li>好处<ul><li>分配简单</li><li>易共享</li></ul></li><li>坏处<ul><li>页表很大</li><li>进程地址空间有很多空洞：对应的页表项没用</li></ul></li></ol><h3 id="页表项">页表项</h3><ol type="1"><li>表达一个映射关系（Page Table Entry，PTE）<ul><li>虚页号 -&gt; 物理页号</li></ul></li><li>包含如下信息：<ul><li>物理页框号</li><li>有效位：标志该页是否在内存中</li><li>保护位：标志该页的访问权限(Read,Write,Exec)</li><li>修改位：标志该页是否被修改过</li><li>访问位：标志该页是否被访问过</li><li>缓存位</li></ul></li><li>PTE的数量<ul><li>假设一页是 4K（12位页内偏移Offset）</li><li>32位虚拟地址空间：2^32 = 4G = 4K * 1024<ul><li>一个PTE的大小为32位 = 4B，故总共为 4MB</li><li>如果有10K个进程，那么可能内存连页表都放不下</li></ul></li><li>64位虚拟地址空间：2^64 = 16EB = 4K * 1024 * 1024 * 1024<ul><li>一个PTE的大小为64位 = 8B，故总共为 8TB</li><li>内存连一个页表的大小都放不下</li></ul></li></ul></li></ol><h2 id="分段-分页">分段 + 分页</h2><ol type="1"><li>先将进程划分为若干段</li><li>每个段采用分页</li><li>段表记录它的页表地址</li><li>不足：仍然存在分段的不足</li></ol><h2 id="多级页表">多级页表</h2><ol type="1"><li>虚地址除去 offset 之外的部分划分为多个段<ul><li>每段对应一级页表</li><li>多个页表</li></ul></li><li>好处：节省空间</li></ol><p>示例：二级页表</p><ol type="1"><li>虚地址：32位，前10位为一级页表索引，中间10位为二级页表索引，后12位为页内偏移</li><li>每个页表4KB，共有1024个页表项，下级页表每一项映射1页(4KB)，上级页表映射1024页(4MB)</li><li>对于大地址空间，大部分程序都只需要几个页表</li></ol><h2 id="反向页表">反向页表</h2><ol type="1"><li>基本逻辑<ul><li>64位地址空间，4K页，共有2<sup>52个页；256MB物理内存，总共有2</sup>16个页框</li><li>按物理页索引，记录每个物理页对应的进程ID及虚页</li></ul></li><li>主要思想<ul><li>每个物理页对应一个PTE</li><li>通过Hash查找进行地址转换（Hash(Vpage,pid) -&gt; Ppage#）</li></ul></li><li>好处<ul><li>页表大小与地址空间大小无关，只与物理内存大小有关</li><li>对于大地址空间，页表较小</li></ul></li><li>坏处<ul><li>查找困难（Hash冲突）</li><li>管理哈希链需要大量开销</li></ul></li></ol><h1 id="mmu-和-tlb">MMU 和 TLB</h1><h2 id="地址转换实现">地址转换实现</h2><ol type="1"><li>地址类别<ul><li>CPU发出的是虚地址</li><li>内存和IO设备接收的是物理地址</li></ul></li><li>MMU（Memory Management Unit，内存管理单元）职责<ul><li>负责虚地址到物理地址转换的硬件单元，通常在片内实现</li><li>虚存地址转换到物理地址（每条Load 和 Store指令都需要地址转换）</li><li>内存保护，检查地址是否有效</li><li>特殊指令操作对应寄存器，记录Base/Bound，或者页目录</li></ul></li><li>操作系统职责<ul><li>内存管理：新进程分配空间，结束的进程回收空间</li><li>进程切换时上下文管理（RISC-V satp寄存器等）</li><li>异常处理：内存越界访问、无效地址等</li></ul></li></ol><h2 id="加速地址转换">加速地址转换</h2><ol type="1"><li>程序只知道虚地址<ul><li>每个程序或进程的地址空间是[0,max-1]</li></ul></li><li>每个虚地址必须要进行转换<ul><li>可能需要逐级查找多级页表</li><li>页表保存在内存中，一个内存访问可能变成多个内存访问</li></ul></li><li>解决办法<ul><li>用速度更快的部件来缓存使用最频繁的那部分页表项</li></ul></li></ol><h2id="tlbtranslation-look-aside-buffer地址转换旁路缓冲">TLB（TranslationLook-aside Buffer，地址转换旁路缓冲）</h2><blockquote><p>TLB是一种页表的缓冲机制</p></blockquote><ol type="1"><li>共有的（必须的）位<ul><li>VP#（虚页号）：与虚地址进行匹配</li><li>PP#（物理页号）：转换后的实际地址</li><li>Valid位：标志此表项是否有效</li><li>访问控制位：运行内核/用户访问，以及允许何种访问（Read,Write）</li></ul></li><li>可选的（有用的）位<ul><li>进程标签（pid）</li><li>访问标签位（R位）</li><li>修改标志位（M位）</li><li>缓存标志位</li></ul></li></ol><h3 id="tlb具体流程硬件和软件不同">TLB具体流程（硬件和软件不同）</h3><ol type="1"><li>CPU先把一个虚地址VA给MMU进行转换</li><li>MMU先查TLB: VA = VP# || offset<ul><li>将该虚页号同时与TLB中所有的表项进行比较（硬件支持）</li></ul></li><li>TLB hit：TLB里找到含 VP# 的表项<ul><li>如果有效（TLB的Valid位=1），取表项中的物理页号</li><li>如果无效（TLB的Valid位=0），则等同于TLB miss</li></ul></li><li>如果TLB miss（不命中）：TLB中没有含有 VP# 的表项<ul><li>MMU硬件在页表中进行查找，得到PTE /进入内核异常处理程序，软件在页表中进行查找，得到PTE</li><li>将找到的PTE加载进TLB<ul><li>如果没有空闲表项，则替换一个TLB表项</li></ul></li><li>获取TLB表项中的物理页号 / 重新执行TLB不命中的指令</li></ul></li></ol><h3 id="硬件控制-vs-软件控制">硬件控制 vs 软件控制</h3><ol type="1"><li>硬件控制<ul><li>高效</li><li>不灵活</li></ul></li><li>软件控制<ul><li>简化 MMU 的逻辑，是的 CPU芯片上有更多面积可以用于缓存</li><li>软件控制更加灵活</li><li>可以使用反向页表进行映射，处理大的虚地址空间</li></ul></li></ol><h3 id="tlb-设计问题">TLB 设计问题</h3><ol type="1"><li>替换哪个TLB表项<ul><li>伪随机 或 LRU算法</li></ul></li><li>上下文切换时需要做什么<ul><li>有进程标签：修改TLB寄存器和进程寄存器的内容</li><li>无进程标签：将整个TLB的内容置于无效</li></ul></li><li>修改一个页表项时需要做什么<ul><li>修改内存中的PTE</li><li>将对应的TLB表项置于无效（刷新TLB）</li></ul></li><li>TLB的大小<ul><li>很小的TLB（64项），能够有很好的TLB命中率</li><li>不能太大（不超过256项），CPU的面积有限</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> Study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程间通信</title>
      <link href="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"/>
      <url>/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>进程间通信（IPC Inter-Process Communication）</p></blockquote><ul><li><p>共享资源互斥访问</p></li><li><p>条件同步</p></li><li><p>数据传输</p></li></ul><span id="more"></span><h1 id="信号">信号</h1><blockquote><p>进程间的中断通知和处理机制</p></blockquote><ul><li>例如：<code>SIGKILL</code>，<code>SIGSTOP</code>，<code>SIGCONT</code>等</li><li>可以在任一时刻发送给某一个进程且无需直到进程的状态</li><li>内核可以保存信号，再传递给进程</li><li>信号可以被阻塞</li></ul><h2 id="信号的产生">信号的产生</h2><h3 id="硬件方式">硬件方式</h3><ul><li>键盘<code>Ctrl+C</code>发送<code>SIGINT</code>信号</li><li>CPU检测到硬件非法访问（例如内存），通知内核生成信号，发送给发生事件的进程</li></ul><h3 id="软件方式">软件方式</h3><ul><li>通过系统调用，发送<code>SIGKILL</code>信号等</li></ul><h2 id="信号的接收处理">信号的接收处理</h2><ul><li>捕获（<code>Catch</code>）<ul><li>默认处理：执行操作系统指定的缺省处理，例如进程终止、进程挂起等</li><li>自定义处理：执行进程指定的信号处理函数</li></ul></li><li>忽略（<code>Ignore</code>)<ul><li>不对信号做任何处理</li></ul></li><li>屏蔽（<code>Mask</code>）<ul><li>禁止进程接受和处理信号</li><li>解除屏蔽后可以接受和处理信号</li></ul></li></ul><h2 id="信号的实现">信号的实现</h2><p><img src="https://raw.githubusercontent.com/JamesYuuu/Picbed/main/image-20221020151124712.png" alt="image-20221020151124712" style="zoom:80%;" /></p><h1 id="管道">管道</h1><h2 id="管道的分类">管道的分类</h2><h3 id="无名管道">无名管道</h3><ul><li>进程间基于内存文件的通信机制<ul><li>内核缓冲区，数据单向流动，半双工通信</li><li>读空或写满时，需要有相应的并发机制控制</li><li>可以用<code>Read</code>，<code>Write</code>函数读写</li></ul></li><li>只能在具有亲缘关系的进程间使用，例如父子进程<ul><li>子进程可以从父进程继承文件描述符</li></ul></li></ul><h3 id="命名管道">命名管道</h3><ul><li>基于一种特殊设备文件的进程通信机制</li><li>允许无亲缘关系的进程间通信</li></ul><h2 id="与管道有关的系统调用">与管道有关的系统调用</h2><ul><li>读管道（<code>read(fd,buffer,nbytes)</code>)<ul><li>C语言中的<code>scanf()</code>就是基于它实现的</li></ul></li><li>写管道（<code>write(fd,buffer,nbytes)</code>)<ul><li>C语言中的<code>printf()</code>就是基于它实现的</li></ul></li><li>创建管道（<code>pipe(fd[2])</code>）<ul><li>fd是2个文件描述符组成的数组<ul><li>fd[0]是读文件描述符</li><li>fd[1]是写文件描述符</li></ul></li></ul></li></ul><h3 id="管道示例">管道示例</h3><blockquote><p>Shell 可以通过管道重定向输入输出流</p></blockquote><ul><li>可能从键盘、文件、程序读取</li><li>可能写入到终端、文件、程序</li></ul><p><img src="https://raw.githubusercontent.com/JamesYuuu/Picbed/main/image-20221020153743147.png" alt="image-20221020153743147" style="zoom:80%;" /></p><h1 id="消息队列">消息队列</h1><blockquote><p>消息队列是由操作系统维护的以字节序列为基本单位的间接通信机制</p></blockquote><ul><li><p>独立于发送和接收进程</p></li><li><p>每个消息是一个字节序列</p></li><li><p>相同标识的消息按照先进先出的顺序组成一个消息队列</p></li></ul><p><img src="https://raw.githubusercontent.com/JamesYuuu/Picbed/main/image-20221020153928170.png" alt="image-20221020153928170" style="zoom:80%;" /></p><h3 id="消息队列的系统调用">消息队列的系统调用</h3><ul><li><code>msgget(key,flags)</code><ul><li>获取消息队列标识</li></ul></li><li><code>msgsnd(QID,buf,size,flags)</code><ul><li>发送消息</li></ul></li><li><code>msgrcv(QID,buf,size,type,flags)</code><ul><li>接收消息</li></ul></li><li><code>msgctl(...)</code><ul><li>消息队列控制</li></ul></li></ul><h1 id="共享内存">共享内存</h1><blockquote><p>共享内存是操作系统把同一个物理内存区域同时映射到多个进程的内存地址空间的通信机制</p></blockquote><ul><li>每个进程将共享内存区域映射到私有地址空间</li><li>必须用额外的同步机制来协调数据访问</li><li>优点：快速、方便地共享数据</li></ul><p><img src="https://raw.githubusercontent.com/JamesYuuu/Picbed/main/image-20221020155342022.png" alt="image-20221020155342022" style="zoom:80%;" /></p><h2 id="共享内存系统调用">共享内存系统调用</h2><ul><li><code>shmget(key,size,flags)</code><ul><li>创建或获取一个共享段</li></ul></li><li><code>shmat(shmid,*shmaddr,flags)</code><ul><li>把共享段映射到进程地址空间</li><li>返回指向共享内存的指针</li></ul></li><li><code>shmdt(*shmaddr)</code><ul><li>取消共享段到进程地址空间的映射</li></ul></li><li><code>shmctl(...)</code><ul><li>共享段控制</li></ul></li></ul><h1 id="套嵌字socket-api">套嵌字（Socket API）</h1><blockquote><p>TCP/UDP的抽象</p></blockquote><ul><li>寻址：IP地址和端口</li><li>创建和关闭<code>socket</code><ul><li><code>sockid=socket(af,type,proto);</code></li><li><code>sockerr=close(sockid);</code></li></ul></li><li>绑定<code>socket</code>到本地地址<ul><li><code>sockerr=bind(sockid,localaddr,addrlen);</code></li></ul></li><li>监听与接收<ul><li><code>listen(sockid,len);</code></li><li><code>accept(sockid,addr,len);</code></li></ul></li><li>连接<code>socket</code>到目标地址<ul><li><code>connect(sockid,destaddr,addrlen)</code></li></ul></li></ul><h1 id="ipc方式对比">IPC方式对比</h1><ul><li>信号<ul><li>传送的信息量小，只有一个信号类型</li></ul></li><li>管道<ul><li>半双工方式，单向通信；无格式字节流</li><li>需进程打开、关闭管道</li></ul></li><li>消息队列<ul><li>缓冲区大小受限（KB级别）</li></ul></li><li>共享内存<ul><li>通信效率高，但需要信号量等机制协调共享内存的访问冲突</li></ul></li><li>套嵌字（Socket）<ul><li>用于不同机器的进程间通信</li><li>需要对数据进行封包和解包操作</li></ul></li></ul><h1 id="ipc设计考虑">IPC设计考虑</h1><h2 id="设计考虑">设计考虑</h2><h3 id="进程间通信的基本原语">进程间通信的基本原语</h3><ul><li>Send(msg)，Receive(msg)</li></ul><h3 id="进程通信流程">进程通信流程</h3><ul><li>建立通信链路<ul><li>内存、设备文件、网络</li></ul></li><li>Send/Recv 交换数据<ul><li>是否缓冲消息</li><li>直接通信 vs 间接通信</li><li>同步 vs 异步</li><li>例外处理</li></ul></li></ul><h2 id="缓冲消息">缓冲消息</h2><h3 id="无缓冲">无缓冲</h3><ul><li>发送方必须等到接收方接收消息</li><li>每个消息都需要握手</li></ul><h3 id="有界缓冲">有界缓冲</h3><ul><li>缓冲区长度有限</li><li>缓冲区满则发送方阻塞</li></ul><h3 id="无界缓冲">无界缓冲</h3><ul><li>“无限”长度</li><li>发送方永远不会阻塞</li><li>实际应用受限</li></ul><h2 id="直接通信-vs-间接通信">直接通信 VS 间接通信</h2><h3 id="直接通信">直接通信</h3><ul><li>通信进程明确指定接收者或发送者<ul><li>Send(P,msg)</li><li>Recv(C,msg)</li></ul></li></ul><h3 id="间接通信">间接通信</h3><ul><li>使用信箱<ul><li>允许多对多的通信</li><li>需要打开/关闭信箱</li><li>Send(A,msg)/Recv(A,msg)</li></ul></li><li>缓冲区<ul><li>信箱内需要有一个缓冲区、互斥锁和条件变量</li></ul></li><li>消息长度<ul><li>不确定，可以把大消息切成多个包发送</li></ul></li><li>信箱和管道的对比<ul><li>信息允许多对多的通信</li><li>管道隐含了一个发送，一个接收</li></ul></li></ul><h2 id="同步和异步">同步和异步</h2><h3 id="发送">发送</h3><ul><li>同步发送<ul><li>发送进程阻塞，直到消息由接收进程收到</li><li>若使用缓冲，启动数据传输直到源缓冲用完后再阻塞</li></ul></li><li>异步发送<ul><li>发送进程调用<code>async_send</code>启动数据传输后，继续执行其他操作</li><li>结束后<ul><li>需要应用检查状态</li><li>通知或者向应用发送信号</li></ul></li></ul></li></ul><h3 id="接收">接收</h3><ul><li>同步接收<ul><li>接收进程阻塞，直到有消息可用</li><li>如果有消息，则返回数据</li></ul></li><li>异步接收<ul><li>如果有消息，则返回数据</li><li>如果无消息，则返回状态</li></ul></li></ul><h1 id="例外处理">例外处理</h1><h2 id="进程结束">进程结束</h2><ul><li>R等待S发生的消息，但S已经结束<ul><li><strong>问题</strong>：同步接收时，R会永久阻塞</li><li><strong>解决</strong>：等待超时</li></ul></li><li>S发送一个消息给R，但R已经结束<ul><li><strong>问题</strong>：同步发送时，S会永久阻塞</li><li><strong>解决</strong>：发送超时</li></ul></li></ul><h2 id="消息丢失">消息丢失</h2><blockquote><p>使用确认（ACK）和超时（TIMEOUT）检测和重传消息</p></blockquote><ul><li>需要接收者没收到一个消息后发送一个确认</li><li>发送者阻塞直到<code>ACK</code>到达或者超时</li><li>如果超时发生且没收到确认，重发消息</li></ul><p><strong>问题：如果消息没有丢失，重复发送了消息怎么办？</strong></p><blockquote><p>重传：接收端收到的消息重复</p></blockquote><p><strong>解决办法：</strong></p><ul><li>使用序列号确认是否重复</li><li>在接收端删掉重复消息</li></ul><p><strong>减少确认消息：</strong></p><ul><li>批量传送确认</li><li>接收者发送<code>noack</code></li></ul><h2 id="消息损坏">消息损坏</h2><h3 id="检测方法">检测方法</h3><ul><li>发送端计算整个消息的校验和，并随消息发送校验和（CRC）</li><li>在接收端重新计算校验和，并和消息中的校验和对比</li></ul><h3 id="纠正方法">纠正方法</h3><ul><li>重传</li><li>使用纠错码恢复</li></ul>]]></content>
      
      
      <categories>
          
          <category> Study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信号量与管程</title>
      <link href="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%BF%A1%E5%8F%B7%E9%87%8F%E4%B8%8E%E7%AE%A1%E7%A8%8B/"/>
      <url>/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%BF%A1%E5%8F%B7%E9%87%8F%E4%B8%8E%E7%AE%A1%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="信号量">信号量</h1><h2 id="为什么需要信号量">为什么需要信号量</h2><h3 id="生产者-消费者问题">生产者-消费者问题</h3><ul><li>一个或多个生产者再生成数据后放进了一个缓冲区里</li><li>单个消费者从缓冲区取出数据处理</li><li>任何时刻只能有一个生产者或消费者可访问缓冲区</li></ul><h3 id="锁方案">锁方案</h3><ul><li><strong>临界区</strong>：读写缓冲区<ul><li>保证始终只有一个线程访问缓冲区</li></ul></li><li><strong>问题</strong>：生产者线程释放锁后，可能仍然是生产者线程获得锁<ul><li>锁能够保护共享资源互斥访问</li><li>但锁不能够提供线程条件同步</li></ul></li></ul><h3 id="所需的机制特征">所需的机制特征</h3><ul><li>表示资源状态：缓冲区空 VS 缓冲区满</li><li>条件同步：使得多进程/线程根据资源的状态执行</li></ul><span id="more"></span><h2 id="信号量-1">信号量</h2><blockquote><p>信号量是操作系统提供的一种协调共享资源访问的方法</p></blockquote><h3 id="信号量的组成">信号量的组成</h3><ul><li>一个整形变量：用于表示系统资源的数量</li><li>两个原子操作（P操作和V操作）</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Class Semaphore&#123;</span><br><span class="line">    <span class="type">int</span> sem;</span><br><span class="line">    WaitQueue q;</span><br><span class="line">&#125;</span><br><span class="line">Semaphore::<span class="built_in">P</span>()&#123;</span><br><span class="line">    sem--; <span class="comment">//请求资源</span></span><br><span class="line">    <span class="keyword">if</span> (sem&lt;<span class="number">0</span>)&#123;  <span class="comment">//当资源不足的时候将线程阻塞</span></span><br><span class="line">        Add <span class="keyword">this</span> thread t to q;</span><br><span class="line">        <span class="built_in">block</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Semaphore::<span class="built_in">V</span>()&#123;</span><br><span class="line">    sem++;    <span class="comment">//释放资源</span></span><br><span class="line">    <span class="keyword">if</span> (sem&lt;=<span class="number">0</span>)&#123;  <span class="comment">//若仍存在阻塞的线程，则释放一个线程</span></span><br><span class="line">        Remove a thread t from q;</span><br><span class="line">        <span class="built_in">waitupt</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>信号量的使用<ul><li>互斥访问：保护临界区互斥访问</li><li>条件同步：多线程之间同步</li></ul></li></ul><h3id="用信号量实现生产者-消费者问题">用信号量实现生产者-消费者问题</h3><ul><li>有界缓冲区的生产者-消费者问题<ul><li>一个或多个生产者再生成数据后放进了一个缓冲区里</li><li>单个消费者从缓冲区取出数据处理</li><li>任何时刻只能有一个生产者或消费者可访问缓冲区</li></ul></li><li>要求<ul><li>任何时刻都只能有一个线程操作（互斥访问）</li><li>缓冲区空时：消费者必需等待生产者（条件同步）</li><li>缓冲区满时：生产者必需等待消费者（条件同步）</li></ul></li></ul><h4 id="设计">设计</h4><ul><li>缓冲区空：信号量<code>emptyBuffers</code></li><li>缓冲区满：信号量<code>fullBuffers</code></li><li>互斥访问：互斥锁<code>mutex</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Class BoundedBuffer&#123;</span><br><span class="line">    mutex = <span class="keyword">new</span> <span class="built_in">Semaphore</span>(<span class="number">1</span>);</span><br><span class="line">    fullBuffers = <span class="keyword">new</span> <span class="built_in">Semaphore</span>(<span class="number">0</span>);</span><br><span class="line">    emptyBuffers = <span class="keyword">new</span> <span class="built_in">Semaphore</span>(n);</span><br><span class="line">&#125;</span><br><span class="line">BoundedBuffer::<span class="built_in">Deposit</span>(c)&#123;</span><br><span class="line">    emptyBuffers-&gt;<span class="built_in">P</span>();</span><br><span class="line">    mutex-&gt;<span class="built_in">P</span>();</span><br><span class="line">    Add c to the buffer;</span><br><span class="line">    mutex-&gt;<span class="built_in">V</span>();</span><br><span class="line">    fullBuffers-&gt;<span class="built_in">V</span>();</span><br><span class="line">&#125;</span><br><span class="line">BoundedBuffer::<span class="built_in">Remove</span>(c)&#123;</span><br><span class="line">    fullBuffers-&gt;<span class="built_in">P</span>();</span><br><span class="line">    mutex-&gt;<span class="built_in">P</span>();</span><br><span class="line">    Remove c to the buffer;</span><br><span class="line">    mutex-&gt;<span class="built_in">V</span>();</span><br><span class="line">    emptyBuffers-&gt;<span class="built_in">V</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="哲学家就餐问题">哲学家就餐问题</h3><ul><li>5个哲学家围绕一张圆桌而坐<ul><li>桌子上放着5个叉子</li><li>每两个哲学家之间放一个叉子</li></ul></li><li>哲学家的动作包括思考和进餐<ul><li>进餐时需同时拿到左右两边的叉子</li><li>思考时将两支叉子放回原处</li></ul></li><li><strong>问题</strong>：如何保证哲学家们的动作有序进行<ul><li>即保证不存在有人永远拿不到叉子</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 5</span></span><br><span class="line">semaphore fork[<span class="number">5</span>];</span><br><span class="line"><span class="type">void</span> <span class="title function_">philosopher</span><span class="params">(<span class="type">int</span> i)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        think();</span><br><span class="line">        <span class="keyword">if</span> (i%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">            P(fork[i]);</span><br><span class="line">            P(fork[(i+<span class="number">1</span>)%N]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">    P(fork[(i+<span class="number">1</span>)%N]);</span><br><span class="line">            P(fork[i]);</span><br><span class="line">        &#125;  <span class="comment">// 使用不同的顺序拿叉子以防止死锁</span></span><br><span class="line">        eat();</span><br><span class="line">        V(fork[i]);</span><br><span class="line">        V(fork[(i+<span class="number">1</span>)%N]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="管程">管程</h1><blockquote><p>管程是一种用于多线程互斥访问共享资源的程序结构</p></blockquote><ul><li>采用面向对象方法，简化了线程间的同步控制</li><li>任意时刻最多只能有一个线程执行管程代码</li><li>正在管程中的线程可临时放弃管程的互斥访问，等待事件出现时恢复</li></ul><h2 id="组成">组成</h2><ul><li>一个锁<ul><li>用于控制管程代码的互斥访问</li></ul></li><li>条件变量<ul><li>用于管理共享数据的条件同步</li></ul></li><li>等待原因<ul><li>用于判断是否需要等待的条件</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可能需要等待的线程</span></span><br><span class="line">Acquire(mutex);</span><br><span class="line"><span class="keyword">while</span> (等待条件满足)   <span class="comment">//当前没有资源可供使用</span></span><br><span class="line">    cond.wait(mutex);</span><br><span class="line">使用资源</span><br><span class="line">Release(mutex);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改变等待条件的线程</span></span><br><span class="line">Acquire(mutex);</span><br><span class="line">使资源可用且使等待条件不满足</span><br><span class="line">Signal(cond);<span class="comment">// 唤醒一个在等待的线程</span></span><br><span class="line">Release(mutex);</span><br></pre></td></tr></table></figure><h2 id="面向对象封装">面向对象封装</h2><ul><li>成员变量<ul><li>等待原因（比如某个变量值）</li><li>条件变量<ul><li>提供原语操作（实现等待和通知等）</li><li>包含等待队列</li></ul></li></ul></li><li>成员函数<ul><li>资源操作代码</li></ul></li></ul><h3 id="条件变量原语操作">条件变量原语操作</h3><ul><li>条件变量是管程内的等待机制<ul><li>每个条件变量表示一种等待的原因，对应一个等待队列</li></ul></li><li><code>Wait</code>原语操作<ul><li>将自己阻塞在等待队列中</li><li>等待被唤醒或执行线程释放管程的互斥访问</li></ul></li><li><code>Signal</code>原语操作<ul><li>将等待队列中的一个线程唤醒</li></ul></li><li><code>Broadcast</code>原语操作<ul><li>唤醒等待队列中所有的线程</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Class Condition&#123;</span><br><span class="line">    <span class="type">int</span> numWaiting = <span class="number">0</span>;</span><br><span class="line">    WaitQueue q;</span><br><span class="line">&#125;</span><br><span class="line">Condition::<span class="built_in">Wait</span>(lock)&#123;</span><br><span class="line">    numWaiting++;</span><br><span class="line">    Add <span class="keyword">this</span> thread t to q;</span><br><span class="line">    <span class="built_in">release</span>(lock); <span class="comment">// 解锁后再调用scheduler防止死锁</span></span><br><span class="line">    <span class="built_in">do_scheduler</span>();</span><br><span class="line">    <span class="built_in">acquire</span>(lock); <span class="comment">// 重新申请锁，恢复原状</span></span><br><span class="line">&#125;</span><br><span class="line">Condition::<span class="built_in">Signal</span>()&#123;</span><br><span class="line">    <span class="keyword">if</span> (numWaiting &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        Remove a thread t from q;</span><br><span class="line">        <span class="built_in">wakeup</span>(t);</span><br><span class="line">        numWaiting--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2id="用管程来实现生产者-消费者问题">用管程来实现生产者-消费者问题</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Class BoundedBuffer&#123;</span><br><span class="line">    Lock lock;</span><br><span class="line">    <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">    Condition full,empty;</span><br><span class="line">&#125;</span><br><span class="line">BoundedBuffer::<span class="built_in">Deposit</span>(c)&#123;</span><br><span class="line">    lock-&gt;<span class="built_in">Acquire</span>();</span><br><span class="line">    <span class="keyword">while</span> (count==n)</span><br><span class="line">    full.<span class="built_in">Wait</span>(&amp;lock); <span class="comment">// 如果满了就等待消费者消费</span></span><br><span class="line">    Add c to the buffer;</span><br><span class="line">    count++;</span><br><span class="line">    empty.<span class="built_in">Signal</span>();</span><br><span class="line">    lock-&gt;<span class="built_in">Release</span>();    <span class="comment">// 新的生产者信号，通知消费者可以消费</span></span><br><span class="line">&#125;</span><br><span class="line">BoundedBuffer::<span class="built_in">Remove</span>(c)&#123;</span><br><span class="line">    lock-&gt;<span class="built_in">Acquire</span>();</span><br><span class="line">    <span class="keyword">while</span> (count==<span class="number">0</span>)</span><br><span class="line">        empty.<span class="built_in">wait</span>(&amp;lock); <span class="comment">// 如果空了就等待生产者生产</span></span><br><span class="line">    Remove c from buffer;</span><br><span class="line">    count--;</span><br><span class="line">    full.<span class="built_in">Signal</span>();</span><br><span class="line">    lock-&gt;<span class="built_in">Release</span>(); <span class="comment">// 新的消费者信号，通知生产者可以生产</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="signal后的三种选择">Signal后的三种选择</h2><h3 id="hansen管程">Hansen管程</h3><blockquote><p>发送方退出管程</p></blockquote><ul><li>规定Signal必须是管程中的过程的最后一个语句</li></ul><h3 id="hoare管程">Hoare管程</h3><blockquote><p>让被唤醒的线程立即执行，发送方进入Signal队列</p></blockquote><ul><li>如果发送方有其他工作要做，会很麻烦<ul><li>很难确定没有其他工作要做，因为Signal的实现并不知道其是如何被使用的</li></ul></li></ul><h3 id="mesa管程">Mesa管程</h3><blockquote><p>发送方继续执行</p></blockquote><ul><li>易于实现</li><li>被唤醒的进程实际执行的时候，条件不一定为真<ul><li>需要让被唤醒的进程重新回到<code>wait()</code>执行，需要重新判断等待原因条件</li></ul></li></ul><h2 id="信号量与管程对比">信号量与管程对比</h2><ul><li>信号量<ul><li>控制对多个共享资源的访问，用于进程/线程间的条件同步</li><li>可以并发，取决于sem的初始值<ul><li>sem表示资源的数量</li></ul></li><li>P操作可能导致阻塞，也可能不阻塞</li><li>V操作唤醒其他进程/线程后，当前进程/线程与被唤醒者可以并发执行</li></ul></li><li>管程<ul><li>一种程序结构，限制同一时刻只有一个线程可以访问临界区</li><li>管程内部同一时刻只有一个线程在执行</li><li>需要自行判断资源是否可用（等待原因判断）</li><li><code>wait</code>操作一定会造成阻塞</li><li><code>signal</code>操作后，被唤醒的线程是否执行取决于管程的风格</li></ul></li></ul><h1 id="屏障">屏障</h1><blockquote><p>线程A和线程B希望在某一个特定的点交会并继续执行</p></blockquote><h2 id="屏障原语barrier">屏障原语（Barrier）</h2><h3 id="功能">功能</h3><ul><li>协调多个进程并行共同完成某项任务</li><li>设定一个屏障变量b以及初始值n<ul><li>如果屏障变量值小于n，则线程等待</li><li>如果屏障变量的值达到n，则唤醒所有线程，所有的线程继续工作</li></ul></li></ul><h3 id="屏障实现">屏障实现</h3><ul><li>使用两个信号量（两个线程时）<ul><li>初始化两个信号量均为0</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/JamesYuuu/Picbed/main/image-20221020103351441.png" alt="image-20221020103351441" style="zoom:50%;" /></p><ul><li>使用管程实现（超过两个线程时）<ul><li>等待原因：抵达屏障的线程数量没有达到n</li></ul></li></ul><h2 id="同步机制">同步机制</h2><h3 id="操作系统提供的同步机制">操作系统提供的同步机制</h3><figure><imgsrc="https://raw.githubusercontent.com/JamesYuuu/Picbed/main/image-20221020103532408.png"alt="image-20221020103532408" /><figcaption aria-hidden="true">image-20221020103532408</figcaption></figure><h1 id="读者-写者问题">读者-写者问题</h1><ul><li>共享数据的两类使用者<ul><li>读者：只读取数据，不进行修改</li><li>写者：读取并修改数据</li></ul></li><li>对共享数据的读写<ul><li>“读者-读者”允许<ul><li>同一时刻，允许有多个读者同时读</li></ul></li><li>“读者-写者”互斥<ul><li>没有写者的时候读者才可以读</li><li>没有读者的时候写者才可以写</li></ul></li><li>“写者-写者”互斥<ul><li>没有其他写者的时候写者才可以写</li></ul></li></ul></li></ul><h2 id="用信号量解决读者-写者问题">用信号量解决读者-写者问题</h2><blockquote><p>用信号量描述每一个约束</p></blockquote><ul><li>信号量<code>WriteMutex</code><ul><li>控制对于读写操作的互斥</li><li>初始化为1</li></ul></li><li>读者数量<code>Rcount</code><ul><li>描述正在进行读操作的读者数目</li><li>初始化为0</li></ul></li><li>信号量<code>CountMutex</code><ul><li>控制对读者计数的互斥修改</li><li>初始化为1</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Writer Process</span></span><br><span class="line">P(WriteMutex); <span class="comment">//写写互斥</span></span><br><span class="line">Write;</span><br><span class="line">V(WriteMutex);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Reader Process</span></span><br><span class="line">P(CountMutex);</span><br><span class="line"><span class="keyword">if</span> (Rcount==<span class="number">0</span>) P(WriteMutex);   <span class="comment">//读写互斥</span></span><br><span class="line">++Rcount;</span><br><span class="line">V(CountMutex);</span><br><span class="line"></span><br><span class="line">read;</span><br><span class="line"></span><br><span class="line">P(CountMutex);</span><br><span class="line">--Rcount;</span><br><span class="line"><span class="keyword">if</span> (Rcount==<span class="number">0</span>) V(WriteMutex);  <span class="comment">//读写互斥</span></span><br><span class="line">V(CountMutex);</span><br></pre></td></tr></table></figure><h2 id="用管程解决读者-写者问题">用管程解决读者-写者问题</h2><h3 id="管程封装">管程封装</h3><ul><li>两个基本方法</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Database::<span class="built_in">Read</span>() &#123;</span><br><span class="line">Wait until no writers;</span><br><span class="line">read database;</span><br><span class="line">check out – wake up waiting writers; </span><br><span class="line">&#125;</span><br><span class="line">Database::<span class="built_in">Write</span>() &#123;</span><br><span class="line">Wait until no readers/writers;</span><br><span class="line">write database;</span><br><span class="line">check out – wake up waiting readers/writers; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>管程的状态变量</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">AR = <span class="number">0</span>; <span class="comment">// of active readers</span></span><br><span class="line">AW = <span class="number">0</span>; <span class="comment">// of active writers</span></span><br><span class="line">WR = <span class="number">0</span>; <span class="comment">// of waiting readers</span></span><br><span class="line">WW = <span class="number">0</span>; <span class="comment">// of waiting writers</span></span><br><span class="line">Lock lock;</span><br><span class="line">Condition okToRead;</span><br><span class="line">Condition okToWrite;</span><br></pre></td></tr></table></figure><h3 id="读者实现">读者实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Private <span class="title">Database::StartRead</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">lock.<span class="built_in">Acquire</span>();</span><br><span class="line"><span class="keyword">while</span> ((AW+WW) &gt; <span class="number">0</span>)  <span class="comment">//读写互斥</span></span><br><span class="line">    &#123;</span><br><span class="line">WR++;</span><br><span class="line">okToRead.<span class="built_in">wait</span>(&amp;lock);</span><br><span class="line">WR--;</span><br><span class="line">&#125;</span><br><span class="line">AR++;</span><br><span class="line">lock.<span class="built_in">Release</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Private <span class="title">Database::DoneRead</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">lock.<span class="built_in">Acquire</span>();</span><br><span class="line">AR--;</span><br><span class="line"><span class="keyword">if</span> (AR ==<span class="number">0</span> &amp;&amp; WW &gt; <span class="number">0</span>) <span class="comment">//唤醒写者</span></span><br><span class="line">    &#123;</span><br><span class="line">okToWrite.<span class="built_in">signal</span>();</span><br><span class="line">&#125;</span><br><span class="line">lock.<span class="built_in">Release</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="写者实现">写者实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Private <span class="title">Database::StartWrite</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">lock.<span class="built_in">Acquire</span>();</span><br><span class="line"><span class="keyword">while</span> ((AW+AR) &gt; <span class="number">0</span>) <span class="comment">//读写/写写互斥</span></span><br><span class="line">    &#123;</span><br><span class="line">WW++;</span><br><span class="line">okToWrite.<span class="built_in">wait</span>(&amp;lock);</span><br><span class="line">WW--;</span><br><span class="line">&#125;</span><br><span class="line">AW++;</span><br><span class="line">lock.<span class="built_in">Release</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Private <span class="title">Database::DoneWrite</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">lock.<span class="built_in">Acquire</span>();</span><br><span class="line">AW--;</span><br><span class="line"><span class="keyword">if</span> (WW &gt; <span class="number">0</span>)  <span class="comment">//唤醒写者</span></span><br><span class="line">    &#123;</span><br><span class="line">okToWrite.<span class="built_in">signal</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (WR &gt; <span class="number">0</span>) <span class="comment">//唤醒读者</span></span><br><span class="line">    &#123;</span><br><span class="line">okToRead.<span class="built_in">broadcast</span>();</span><br><span class="line">&#125;</span><br><span class="line">lock.<span class="built_in">Release</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>死锁</title>
      <link href="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%AD%BB%E9%94%81/"/>
      <url>/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%AD%BB%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h1 id="死锁的条件">死锁的条件</h1><h2 id="共享资源访问">共享资源访问</h2><h3 id="锁机制">锁机制</h3><ul><li>锁获取：是一个原子操作；一个进程获得锁后，其他进程等待</li><li>锁释放：锁释放后，请求锁的某一个进程可以获得锁</li><li>锁的原子性：通过进入临界区的原子性保证锁的原子性</li></ul><h3 id="资源持有与请求">资源持有与请求</h3><blockquote><p>当资源持有与请求图中形成环路，则代表形成死锁</p></blockquote><p>例如：进程A持有资源R，进程B持有资源S。A在持有R的时候请求S，而B在持有S的时候请求R，这样就导致了死锁。</p><span id="more"></span><h3 id="死锁">死锁</h3><blockquote><p>在讨论死锁的时候，进程和线程等价！</p></blockquote><h4 id="定义">定义</h4><p>两个或两个以上进程/线程在执行过程中，因争夺资源而造成的一种相互等待的现象。</p><h4 id="影响">影响</h4><ul><li>发生死锁的进程/线程无法执行</li><li>被占有的资源无法释放</li><li>浪费系统资源，降低了系统性能</li></ul><h4 id="与饥饿的关系">与饥饿的关系</h4><ul><li><strong>饥饿</strong>：进程无限等待</li><li>死锁可能导致饥饿</li></ul><h3 id="死锁的必要条件">死锁的必要条件</h3><h4 id="互斥">互斥</h4><ul><li>某个资源在一段时间内只能由一个进程占有，且其他进程无法访问</li></ul><h4 id="占有且等待">占有且等待</h4><ul><li>一个进程占有资源，同时请求新资源</li><li>新资源被其他进程占有，进程等待资源被释放</li></ul><h4 id="不可抢占">不可抢占</h4><ul><li>资源不可被抢占，只能由占有者主动释放</li></ul><h4 id="环路等待">环路等待</h4><ul><li>多个进程以环路的方式进行等待</li></ul><h1 id="处理死锁的策略">处理死锁的策略</h1><h2 id="忽略问题鸵鸟算法">忽略问题（鸵鸟算法）</h2><blockquote><p>认为产生死锁是用户的错</p></blockquote><ul><li>操作系统内核死锁<ul><li>重启</li></ul></li><li>设备驱动死锁<ul><li>卸载设备是否重启</li></ul></li><li>应用程序死锁（程序挂起或“不响应”）<ul><li>方法一：杀死并重启程序</li><li>方法二：给程序设定一个<code>checkpoint</code>；在改变运行环境后，从上一个<code>checkpoint</code>重新开始</li></ul></li></ul><h2 id="检测并恢复">检测并恢复</h2><h4 id="检测">检测</h4><ul><li>扫描资源分配图，检测环路</li></ul><h4 id="恢复">恢复</h4><ul><li>杀死进程/线程<ul><li>全部终止或逐个终止</li></ul></li><li>有时需要回滚死锁线程（例如数据库）<ul><li>代价大</li></ul></li></ul><h2 id="避免">避免</h2><h3 id="安全状态">安全状态</h3><ul><li>未发生死锁</li><li>存在一个调度方案<ul><li>使得所有进程能够按照某一次序分配资源，依次运行完成</li><li>且满足所有进程同时请求最大资源</li></ul></li></ul><h3 id="安全状态判断">安全状态判断</h3><blockquote><p>核心思想：寻找一个使系统安全的进程资源分配序列</p></blockquote><ol type="1"><li>初始化<ul><li>当前可用资源：<code>Available</code>；进程需求资源：<code>Need</code><br /></li><li>进程已分配资源：<code>Allocation</code>；进程完成标记：<code>Finish=true</code></li></ul></li><li>寻找一个进程<code>Ti</code>，满足<code>Need&lt;=Available &amp; Finish=False</code>，否则执行4</li><li>执行进程<code>Ti</code>，完成后释放所有资源，更新如下信息，重复2<ul><li>Available+=Allocation</li><li>Finish=True</li></ul></li><li>若此时所有进程的<code>Finish=True</code>，则系统安全，否则系统不安全</li></ol><h3 id="银行家算法">银行家算法</h3><blockquote><p>核心思想：再分配资源前，假设已经给资源做了分配，若分配后保证系统处于安全状态，则分配</p></blockquote><ul><li>单个资源<ul><li>每个进程都有一个资源需求</li><li>总的资源可能不能满足所有的资源需求</li><li>跟踪已分配的资源和仍然需要的资源</li><li><strong>每次进程请求资源时，系统分配前检查安全性</strong></li></ul></li><li>多个资源<ul><li><code>n</code>代表线程数量，<code>m</code>代表资源类型数量，<code>i</code>代表线程编号，<code>j</code>代表资源编号</li><li><code>Available</code>（剩余空闲量）：长度为m的向量</li><li><code>Allocation</code>（已分配量）：大小为<spanclass="math inline">\(n\times m\)</span>的矩阵</li><li><code>Need</code>（未来需要量）：大小为<spanclass="math inline">\(n\times m\)</span>的矩阵<ul><li><spanclass="math inline">\(Need[i,j]=Max[i,j]-Allocation[i,j]\)</span></li></ul></li></ul></li></ul><h4 id="银行家算法的描述">银行家算法的描述</h4><ol start="0" type="1"><li>初始化<spanclass="math inline">\(Request_i[j]\)</span>代表线程<code>Ti</code>请求资源<code>Rj</code>的实例</li></ol><p>循环处理线程<code>Ti</code></p><ol type="1"><li>如果<span class="math inline">\(Request_i \leqNeed[i]\)</span>，则跳转到步骤2。否则拒绝资源申请，因为线程请求的资源已经超过了其最大的要求</li><li>如果<span class="math inline">\(Request_i \leqAvailable\)</span>，则跳转到步骤3。否则该线程必需等待，因为当前资源不足</li><li>假设资源已经分配给了<code>Ti</code>，执行如下<code>what-if</code>判断，进行如下更新计算</li></ol>$$Available=Available-Request_i \\\\Allocation[i]=Allocation[i]+Request_i \\\\Need[i]=Need[i]-Request_i$$<ol start="4" type="1"><li>调用安全状态判断此时系统是否安全<ul><li>若返回结果是安全，则将资源分配给<code>Ti</code></li><li>若返回结果是不安全，系统则拒绝<code>Ti</code>的资源请求</li></ul></li></ol><h2 id="预防">预防</h2><blockquote><p>消除死锁四个必要条件中的一个</p></blockquote><h3 id="避免互斥">避免互斥</h3><ul><li>资源设计成可共享，不用互斥<ul><li>只读文件、只读内存、读/写锁等</li><li><strong>缺点：</strong>有些资源必须互斥访问</li></ul></li><li>增加资源<ul><li>使用临时缓存，使得一个资源看起来像有多个资源（虚拟化）</li><li>使用队列进行调度</li></ul></li><li>Lock-Free设计<ul><li>使用原子操作，例如<code>CAS指令</code></li></ul></li></ul><h3 id="避免占有和等待">避免占有和等待</h3><blockquote><p>采用两阶段加锁的策略</p></blockquote><ul><li><strong>阶段一</strong>：试图对所有所需的资源进行加锁</li><li><strong>阶段二</strong>：<ul><li>如果成功则使用资源，然后释放资源</li><li>否则释放所有资源，再从头开始</li></ul></li></ul><h3 id="允许抢占">允许抢占</h3><blockquote><p>使调度器了解资源分配情况</p></blockquote><ul><li>方法一：<ul><li>如果系统无法满足一个已占有资源的进程的请求，则抢占该进程并释放所有资源</li><li>只在系统能满足所有资源时在进行调度</li></ul></li><li>方法二<ul><li>抢占正占有被请求的资源的进程</li></ul></li></ul><h4 id="减少抢占带来的开销">减少抢占带来的开销</h4><ul><li>将已完成工作（例如数据、状态等）复制到一个缓冲区，再释放资源</li></ul><h3 id="避免环路等待">避免环路等待</h3><blockquote><p>对所有资源制定请求顺序</p></blockquote><ul><li>方法一：<ul><li>对每个资源分配唯一的id</li><li>所有请求必须按照id升序提出</li></ul></li><li>方法二：<ul><li>对每个资源分配唯一的id</li><li>进程不能请求比当前所占有资源编号低的资源</li><li>占用高资源标号的进程需要释放资源</li></ul></li></ul><h2 id="权衡和应用">权衡和应用</h2><ul><li>死锁处理<ul><li>处理死锁是应用开发者的工作</li><li>OS应该要提供打破应用程序死锁的机制</li></ul></li><li>内核不应该出现死锁<ul><li>使用预防方法</li><li><strong>流行做法：</strong>在所有地方使用避免环路等待原则</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>临界区与原子操作</title>
      <link href="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%B8%B4%E7%95%8C%E5%8C%BA%E4%B8%8E%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/"/>
      <url>/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%B8%B4%E7%95%8C%E5%8C%BA%E4%B8%8E%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="并发访问控制">并发访问控制</h1><blockquote><p>通过互斥访问保障 多进程/多线程正确地使用共享资源</p></blockquote><h2 id="临界区critical-section">临界区（Critical Section）</h2><blockquote><p>进程中访问临界资源（共享资源）的一段需要互斥执行的代码</p></blockquote><h3 id="进入临界区">进入临界区</h3><ul><li>检查是否可以进入临界区</li><li>如果可以进入，则设置相应“正在访问临界区”的标志</li></ul><h3 id="退出临界区">退出临界区</h3><ul><li>清除“正在访问临界区”的标志</li></ul><span id="more"></span><h2 id="原子操作">原子操作</h2><ul><li>原子操作是指一次不存在任何中断或失败的操作<ul><li>只有可能操作成功完成</li><li>或者操作完全没有执行</li><li><strong>不可能出现操作部分执行的状态</strong></li></ul></li><li>对临界区的操作必须是原子操作，进入临界区的操作也必须要是原子操作</li><li>操作系统需要利用同步机制在进线程并发执行的同时，保证一些操作是原子操作</li></ul><h2 id="同步机制">同步机制</h2><ul><li><strong>第一步</strong>：识别出共享资源和使用者</li><li><strong>第二步</strong>：设计合适的同步机制</li><li><strong>第三步</strong>：验证临界区是否符合原子操作</li></ul><p>以协调采购为例：</p><table><thead><tr class="header"><th style="text-align: center;">时间</th><th style="text-align: center;">A</th><th style="text-align: center;">B</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">3:00</td><td style="text-align: center;">查看冰箱发现没有面包</td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;">3:05</td><td style="text-align: center;">离开家去商店</td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;">3:10</td><td style="text-align: center;">到达商店</td><td style="text-align: center;">查看冰箱发现没有面包</td></tr><tr class="even"><td style="text-align: center;">3:15</td><td style="text-align: center;">购买面包</td><td style="text-align: center;">离开家去商店</td></tr><tr class="odd"><td style="text-align: center;">3:20</td><td style="text-align: center;">到家并把面包放进冰箱</td><td style="text-align: center;">到达商店</td></tr><tr class="even"><td style="text-align: center;">3:25</td><td style="text-align: center;"></td><td style="text-align: center;">购买面包</td></tr><tr class="odd"><td style="text-align: center;">3:30</td><td style="text-align: center;"></td><td style="text-align: center;">到家并把面包放进冰箱</td></tr></tbody></table><h3 id="方案一">方案一</h3><h4 id="方案描述">方案描述</h4><ul><li>在冰箱上设置一把锁和钥匙</li><li>去买面包前锁住冰箱并且拿走钥匙</li></ul><h4 id="临界区">临界区</h4><ul><li><strong>进入临界区</strong>：锁住冰箱并拿走钥匙</li><li><strong>临界区操作</strong>：去商店买面包</li><li><strong>退出临界区</strong>：打开冰箱，放入面包，放回钥匙</li></ul><h4 id="缺点">缺点：</h4><ul><li>进入临界区的时候锁住的资源太大，让冰箱内的其他食品也无法被取到</li></ul><h3 id="方案二">方案二</h3><h4 id="方案描述-1">方案描述</h4><ul><li>利用便签来避免购买太多的面包</li><li>购买之前留下一张便签</li><li>购买完之后把便签移除</li><li>当其他人看到标签后，就不会再去购买面包</li></ul><h4 id="临界区-1">临界区</h4><ul><li><strong>进入临界区</strong>：查看别人是否留便签，若没有人留下便签，则留下便签</li><li><strong>临界区操作</strong>：去商店买面包</li><li><strong>退出临界区</strong>：拿走便签</li></ul><h4 id="缺点-1">缺点</h4><ul><li>如果在检查面包和标签后、贴标签之前，有其他人也检查了面包和便签<ul><li>可能会购买太多面包</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (noBread)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (noNote)</span><br><span class="line">    &#123;</span><br><span class="line">        Leave Note;</span><br><span class="line">        Buy Bread;</span><br><span class="line">        Remove Note;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方案三">方案三</h3><h4 id="方案描述-2">方案描述</h4><ul><li>在方案二的基础上，修改贴标签、检查面包和标签两者的顺序</li><li>修改为先贴标签，后检查面包和其他人留下的标签</li></ul><h4 id="缺点-2">缺点</h4><ul><li>如果在贴标签之后、检查面包和标签前，有其他人也贴了标签<ul><li>可能没有人买面包</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Leave Note;</span><br><span class="line"><span class="keyword">if</span> (noBread)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (noNote)</span><br><span class="line">    &#123;</span><br><span class="line">        Buy Bread;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Remove Note;</span><br></pre></td></tr></table></figure><h3 id="方案四">方案四</h3><h4 id="方案描述-3">方案描述</h4><ul><li>两个人采取不同的流程<ul><li>例如A采取方案二，B采取方案三</li></ul></li></ul><h4 id="缺点-3">缺点</h4><ul><li>A和B的代码不同，扩展性差</li><li>A可能时刻处于忙等状态</li></ul><h3 id="方案五">方案五</h3><h4 id="方案描述-4">方案描述</h4><ul><li>利用同步机制：锁（<code>Lock</code>）</li><li><code>Lock.Acquire()</code><ul><li>在锁被释放前一直等待，直到获得锁</li><li>如果两人都在等待同一个锁，并且同时发现锁被释放了，那么只有一个能够获得锁</li></ul></li><li><code>Lock.Release()</code><ul><li>解锁并唤醒任何等待中的进程</li></ul></li></ul><blockquote><p>注意：锁的操作必须是原子操作！</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BreadLock.Acquire();</span><br><span class="line"><span class="keyword">if</span> (noBread)</span><br><span class="line">&#123;</span><br><span class="line">    Buy Bread;</span><br><span class="line">&#125;</span><br><span class="line">BreadLock.Release();</span><br></pre></td></tr></table></figure><h2 id="临界区的保障">临界区的保障</h2><blockquote><p>以下代码都是基于线程Ti实现</p></blockquote><h3 id="基于软件的方法">基于软件的方法</h3><blockquote><p>线程之间可通过共享一些共有变量来同步它们的行为</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    enter section       <span class="comment">// 进入临界区</span></span><br><span class="line">    critical section    <span class="comment">// 执行临界区</span></span><br><span class="line">    <span class="built_in">exit</span> section        <span class="comment">// 退出临界区</span></span><br><span class="line">    remainder section   <span class="comment">// 执行剩余区</span></span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br></pre></td></tr></table></figure><h4 id="方案一-1">方案一</h4><p>利用共享变量<code>turn</code>，<code>turn</code>的值代表允许进入临界区的线程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (turn != i);</span><br><span class="line">    critical section</span><br><span class="line">    turn = j;</span><br><span class="line">    remainder section</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br></pre></td></tr></table></figure><ul><li>满足“忙则等待”，但有时候不满足“空闲则入”<ul><li>例如<code>Ti</code>进入临界区后，被切换而没能执行。</li><li><code>Tj</code>需要等待再次调度器切换到<code>Ti</code>，并等待<code>Ti</code>执行完成后才能再继续运行。</li></ul></li></ul><h4 id="方案二-1">方案二</h4><p>利用共享变量<code>flag[N]</code>，<code>flag[i]=1</code>代表线程<code>Ti</code>可以进入临界区</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (flag[j]==<span class="number">1</span>);</span><br><span class="line">    flag[i]==<span class="number">1</span>;</span><br><span class="line">    critical section</span><br><span class="line">    flag[i]=<span class="number">0</span>;</span><br><span class="line">    remainder section</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br></pre></td></tr></table></figure><ul><li>不满足“忙则等待”</li></ul><p>修改如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    flag[i]==<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (flag[j]==<span class="number">1</span>);</span><br><span class="line">    critical section</span><br><span class="line">    flag[i]=<span class="number">0</span>;</span><br><span class="line">    remainder section</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br></pre></td></tr></table></figure><ul><li>满足“忙则等待”，但是不满足“空闲则入”</li></ul><h4 id="dekkers-算法">Dekker's 算法</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">flag[<span class="number">0</span>]=flag[<span class="number">1</span>]=<span class="literal">false</span>; turn=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    flag[i]=<span class="literal">true</span>;               <span class="comment">// 示意自己需要访问临界区</span></span><br><span class="line">    <span class="keyword">while</span> (flag[j])             <span class="comment">// 检查对方是否需要访问临界区</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (turn!=i)            <span class="comment">// 如果轮到对方访问</span></span><br><span class="line">        &#123;</span><br><span class="line">            flag[i]=<span class="literal">false</span>;      <span class="comment">// 示意自己不访问临界区</span></span><br><span class="line">            <span class="keyword">while</span> (turn !=i);   <span class="comment">// 等待对方访问完成</span></span><br><span class="line">            flag[i]=<span class="literal">true</span>;       <span class="comment">// 重新示意自己需要访问临界区</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    critical section            <span class="comment">// 执行临界区操作</span></span><br><span class="line">    turn = j;                   <span class="comment">// 将下一轮竞争的轮次让给对手</span></span><br><span class="line">    flag[i]=<span class="literal">false</span>;              <span class="comment">// 示意自己不访问临界区</span></span><br><span class="line">    remainder section           <span class="comment">// 进入剩余区</span></span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br></pre></td></tr></table></figure><h4 id="peterson算法">Peterson算法</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    flag[i]=<span class="literal">true</span>;                 <span class="comment">// 示意自己需要访问临界区</span></span><br><span class="line">    turn=j;                       <span class="comment">// 将机会谦让给另一个线程</span></span><br><span class="line">    <span class="keyword">while</span> (flag[j] &amp;&amp; turn==j);   <span class="comment">// 等待另一个线程完成访问</span></span><br><span class="line">    critical section              <span class="comment">// 进入临界区</span></span><br><span class="line">    flag[i] = <span class="literal">false</span>;              <span class="comment">// 示意自己不访问临界区</span></span><br><span class="line">    remainder section             <span class="comment">// 进入剩余区</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="分析">分析</h4><ul><li>复杂<ul><li>需要算法和两个进程/线程之间的共享数据项来保证锁的原子性</li></ul></li><li>需要“忙等”<ul><li>浪费CPU时间</li></ul></li></ul><h3 id="禁用中断实现互斥">禁用中断实现互斥</h3><ul><li>使用中断<ul><li>可以实现抢占式的CPU调度</li><li>两种类型的事件可以引起切换<ul><li>内部事件，主动放弃CPU控制权</li><li>外部事件，使得CPU重新调度</li></ul></li></ul></li><li>通过在<code>acquire</code>和<code>release</code>之间禁止上下文切换来提供互斥</li><li>禁用中断以屏蔽外部事件<ul><li>引入不可中断的代码区域</li><li>大多数时候用串行思维</li><li><strong>延迟</strong>处理外部事件</li></ul></li></ul><blockquote><p>相当于同步机制中的方案一，锁住了整个冰箱</p></blockquote><h4 id="使用锁变量并引入等待队列">使用锁变量并引入等待队列</h4><blockquote><p>设置等待队列以避免忙等，并在yield前启用中断</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Acquire(lock)</span><br><span class="line">&#123;</span><br><span class="line">    disable interrupts;</span><br><span class="line">    <span class="keyword">while</span> (lock.value == BUSY)</span><br><span class="line">    &#123;</span><br><span class="line">        add TCB to wait_queue;</span><br><span class="line">        enable interrupts;</span><br><span class="line">        yield();</span><br><span class="line">        disable interrupts;</span><br><span class="line">    &#125;</span><br><span class="line">    lock.value=BUSY;</span><br><span class="line">    enable interrupts;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Release(lock)</span><br><span class="line">&#123;</span><br><span class="line">    disable interrupts;</span><br><span class="line">    remove every thread from wait_queue and wakeup them;</span><br><span class="line">    lock.value=FREE;</span><br><span class="line">    enable interrupts;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="缺点-4">缺点</h4><ul><li>禁用中断后，进程无法被停止<ul><li>整个系统都会为此而停止</li><li>可能导致其他进程处于饥饿状态</li></ul></li><li>临界区可能很长<ul><li>无法确定处理临界区需要的时间</li><li>可能导致长时间无法响应中断</li></ul></li></ul><h3 id="原子操作指令和互斥锁">原子操作指令和互斥锁</h3><blockquote><p>现代CPU都提供一些特殊的原子操作指令</p></blockquote><ul><li>例如TAS指令（Test-and-Set）<ul><li>从内存单元中读取值</li><li>返回内存单元原值</li><li>将内存单元值设置为1</li></ul></li><li>利用TAS指令可以实现自旋锁和互斥锁</li></ul><h4 id="优点">优点</h4><ul><li>适用于单处理器或者共享主存的多处理器中任意数量的进程同步</li><li>简单且易证明</li><li>支持多临界区</li></ul><h4 id="缺点-5">缺点</h4><ul><li>忙等会消耗处理器时间</li><li>可能导致饥饿<ul><li>进程离开临界区时有多个等待进程的情况</li></ul></li><li><strong>死锁</strong><ul><li>低优先级进程占有临界区</li><li>请求访问临界区的高优先级进程获得处理器并等待临界区</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CPU调度</title>
      <link href="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/CPU%E8%B0%83%E5%BA%A6/"/>
      <url>/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/CPU%E8%B0%83%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="cpu调度基础">CPU调度基础</h1><h2 id="进程调度">进程调度</h2><ul><li>进程切换和调度<ul><li>CPU是共享资源，进程按照一定的策略使用CPU资源</li><li>当发生进程切换时，原先的进程不再使用CPU，切换到新的进程使用CPU</li><li>进程切换场景<ul><li>进程主动放弃CPU使用权</li><li>进程等待IO、等待资源（例如锁）</li><li>内核不让进程使用CPU（例如有更高优先级进程要运行）</li></ul></li><li>进程调度需求<ul><li>决定使用CPU的进程</li><li>非抢占式调度和抢占式调度</li></ul></li></ul></li></ul><span id="more"></span><h2 id="非抢占式调度">非抢占式调度</h2><p><img src="https://raw.githubusercontent.com/JamesYuuu/Picbed/main/image-20221020104956853.png" alt="image-20221020104956853" style="zoom: 67%;" /></p><ul><li>进程主动放弃CPU使用权（<code>yield</code>)</li><li>进程等待I/O，等待资源或特定事件（<code>block</code>）</li><li>内核调度器直接进行调度（<code>do_scheduler</code>）</li></ul><h2 id="抢占式调度">抢占式调度</h2><p><img src="https://raw.githubusercontent.com/JamesYuuu/Picbed/main/image-20221020105039824.png" alt="image-20221020105039824" style="zoom:67%;" /></p><h3 id="为什么要抢占">为什么要抢占</h3><ul><li>让进程更加公平的使用CPU资源，避免饥饿</li><li>交替使用I/O和计算资源，提升资源的利用率</li><li>有紧急任务（高优先级进程）要先执行</li></ul><h3 id="基于中断进行抢占式调度">基于中断进行抢占式调度</h3><blockquote><p>时钟中断或IO中断发生的时候，进行进程切换</p></blockquote><ul><li>硬件中断<ul><li>由外部事件（外部设备）触发，例如时钟中断，硬盘读写请求完成等</li><li>硬件中断产生与当前正在执行的任务无关</li></ul></li><li>软件中断（可编程中断）</li></ul><h4 id="按可否屏蔽划分中断">按可否屏蔽划分中断</h4><ul><li>可屏蔽中断<ul><li>可以关闭/开启中断</li></ul></li><li>不可屏蔽中断<ul><li>无法恢复的硬件错误等</li></ul></li></ul><h3 id="中断处理的基本流程">中断处理的基本流程</h3><ul><li>CPU检查中断条件是否满足<ul><li>有中断请求</li><li>CPU允许中断</li></ul></li><li>如果CPU允许中断，则关中断，保证在处理中断的时候不再响应其他中断</li><li>保存被中断的线程</li><li>判断中断的类型，根据不同的中断类型调用对应的中断处理程序</li><li>执行中断处理程序</li><li>恢复现场</li><li>开中断</li></ul><h4 id="io中断处理">I/O中断处理</h4><ul><li>保存当前进程/线程的上下文</li><li>进行I/O，例如将数据从外设拷贝到内核内存中</li><li>调用调度器</li></ul><h4 id="时钟中断处理">时钟中断处理</h4><ul><li>保存当前进程/线程的上下文</li><li>更新系统时间，递减进程时间片</li><li>调用调度器</li></ul><h2 id="调度器">调度器</h2><h3 id="调度器的工作">调度器的工作</h3><ul><li>保存当前进程/线程的上下文</li><li>选择下一个待运行的进程/线程</li><li>加载相应进程/线程的上下文，并跳转执行</li></ul><h3 id="什么时候会触发调度">什么时候会触发调度</h3><ul><li>进程/线程创建</li><li>进程/线程退出</li><li>I/O阻塞或同步阻塞</li><li>I/O中断</li><li>时钟中断</li></ul><h1 id="cpu调度算法">CPU调度算法</h1><h2 id="调度准则">调度准则</h2><h3 id="假设">假设</h3><ul><li>一个用户运行一个程序，一个程序创建一个线程</li><li>程序之间是独立的</li></ul><h3 id="常用指标">常用指标</h3><ul><li>吞吐率：每秒处理请求数</li><li>响应时间（等待时间）：从提交一个请求到产生响应所用的时间（交互式系统）</li><li>周转时间：从作业提交到作业完成的时间间隔（批处理系统）</li><li>公平性：每个程序是否都有执行机会，防止挨饿</li></ul><h3 id="批处理和实时交互系统设计目标">批处理和实时交互系统设计目标</h3><ul><li>保证公平性</li><li>最大化CPU资源利用率</li><li>最大化吞吐率</li><li>最小化周转时间</li><li>缩短响应时间</li><li>均衡性：满足用户需求且提升计算机系统各部件的利用率</li></ul><h4id="不同类型计算机系统的需求不一样">不同类型计算机系统的需求不一样</h4><ul><li>服务器：看重吞吐率、响应时间和公平性</li><li>个人计算机：看重响应时间</li><li>工业控制计算机：看重实时性</li></ul><h2 id="先到先服务fcfs算法">先到先服务（FCFS）算法</h2><blockquote><p>适用于非抢占式调度，适用于批处理系统</p></blockquote><h3 id="核心理念">核心理念</h3><ul><li>一个进程一直运行到结束</li><li>或一直运行到阻塞</li><li>或一直运行到主动放弃CPU</li></ul><h3 id="优点实现简单">优点：实现简单</h3><h3 id="缺点">缺点</h3><ul><li>平均周转时间波动较大<ul><li>短进程可能被排到长进程的后面</li></ul></li><li>可能导致I/O资源利用效率低<ul><li>CPU密集型应用长期占用CPU，导致I/O密集型应用没有机会使用I/O设备</li><li>进而导致I/O设备空闲，I/O资源利用率低</li></ul></li></ul><h2 id="最短时间算法">最短时间算法</h2><h3 id="最短时间优先stcf算法">最短时间优先（STCF）算法</h3><blockquote><p>适用于非抢占式调度</p></blockquote><p>所有作业同时到达，根据所需时间从小到大依次执行。</p><h3 id="最短剩余时间优先srtcf算法">最短剩余时间优先（SRTCF）算法</h3><blockquote><p>适用于抢占式调度</p></blockquote><p>选择就绪队列中剩余时间最短进程占用CPU并进入运行状态</p><h3 id="优点平均响应时间短">优点：平均响应时间短</h3><h3 id="缺点-1">缺点</h3><ul><li>可能会造成饥饿</li><li>由于连续的短进程运行导致长进程始终无法获得CPU资源</li></ul><h2 id="时间片轮转rr算法">时间片轮转（RR）算法</h2><blockquote><p>适用于抢占式调度，多用于交互式系统</p></blockquote><p>在时间片结束的时候，调度器按<code>FCFS</code>算法切换到下一个就绪的进程</p><h3 id="时间片长度的选择">时间片长度的选择</h3><ul><li>大时间片<ul><li>等待时间过长</li><li>极端情况下退化为<code>FSFS</code></li></ul></li><li>小时间片<ul><li>响应时间块</li><li>产生大量上下文切换，影响系统吞吐</li></ul></li><li>经验规则<ul><li>选择一个合适的时间片，使上下文切换开销处于1%以内</li></ul></li></ul><h3 id="虚拟轮转vrr算法">虚拟轮转（VRR）算法</h3><ul><li>引入辅助队列（<code>FIFO</code>算法）</li><li>I/O密集型进程进入辅助队列<strong>（而不是就绪队列）</strong>以备调度</li><li>辅助队列比就绪队列有着更高的优先级</li></ul><h2 id="多级队列mlq与优先级调度">多级队列（MLQ）与优先级调度</h2><blockquote><p>将就绪队列分为多个独立的子队列，每个队列可有自己的调度算法</p></blockquote><p>例如：将前台任务（交互式）采用<code>RR</code>算法，后台任务（批处理）采用<code>FCFS</code>算法</p><h3 id="队列之间">队列之间</h3><ul><li>最高优先级优先<ul><li>固定优先级</li><li>先调度高优先级，在调度低优先级</li><li>可能导致饥饿</li></ul></li><li>潜在问题：<strong>优先级反转</strong><ul><li>高优先级进程所需资源被低优先级进程占有，需要等待低优先级进程的执行</li><li>中优先级进程优先执行，呈现为优先级高于高优先级进程</li></ul></li><li>解决办法：<strong>优先级继承</strong><ul><li>高优先级进程由于等待资源被阻塞时，自动提升低优先级进程的优先级</li></ul></li></ul><h3 id="多级反馈队列mlfq算法">多级反馈队列（MLFQ）算法</h3><blockquote><p>进程可在不同队列间移动的多级队列算法，实现优先级动态调整</p></blockquote><h4 id="特征">特征：</h4><ul><li>每一级队列分配一个时间片，时间片的大小随着优先级别的增加而减小</li><li>进程在当前的时间片没有完成，则降到下一个优先级</li><li>CPU密集型进程的优先级下降很快，而I/O密集型进程则停留在高优先级</li><li>在一定时间周期后，将所有进程的优先级都提升到最高的等级</li></ul><h2 id="公平共享调度fss">公平共享调度（FSS）</h2><blockquote><p>FSS基于份额控制用户对系统资源的访问</p></blockquote><h3 id="份额管理">份额管理</h3><ul><li>按一定的比例在不同用户间分配份额</li><li>需要为突发任务预留份额</li><li>可以为用户设置份额上限</li></ul><h3 id="优先级和份额的区别">优先级和份额的区别</h3><ul><li>优先级表明任务执行的先后，可以优化周转时间、响应时间，但无法确保任务能获得应得的资源比例</li><li>份额对应任务使用的资源比例</li></ul><h2 id="彩票调度">彩票调度</h2><h3 id="彩票方法">彩票方法</h3><ul><li>给每个作业一定数量的彩票（份额）</li><li>随机抽取一张中奖彩票，中奖的作业将获得CPU</li><li>有较多彩票的作业能获得的调度机会更多，随着调度次数增加，每个作业的彩票数量占比趋近于调度次数占比</li><li>为了近似SRTCF，给短作业更多的彩票</li><li>为了避免饥饿，给每个作业至少一个彩票</li></ul><h2 id="调度算法总结">调度算法总结</h2><table style="width:100%;"><colgroup><col style="width: 8%" /><col style="width: 14%" /><col style="width: 27%" /><col style="width: 26%" /><col style="width: 22%" /></colgroup><thead><tr class="header"><th style="text-align: center;">算法</th><th style="text-align: center;">适用系统</th><th style="text-align: center;">平均响应时间</th><th style="text-align: center;">公平性</th><th style="text-align: center;">潜在问题</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">FCFS</td><td style="text-align: center;">批处理</td><td style="text-align: center;">长</td><td style="text-align: center;">可能造成饥饿</td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;">STCF</td><td style="text-align: center;">批处理</td><td style="text-align: center;">短</td><td style="text-align: center;">长进程可能饥饿</td><td style="text-align: center;">需要预测作业执行时间</td></tr><tr class="odd"><td style="text-align: center;">SRTCF</td><td style="text-align: center;">批处理</td><td style="text-align: center;">短</td><td style="text-align: center;">长进程可能饥饿</td><td style="text-align: center;">需要预测作业执行时间</td></tr><tr class="even"><td style="text-align: center;">RR</td><td style="text-align: center;">交互式</td><td style="text-align: center;">短，I/O进程响应时间较长</td><td style="text-align: center;">公平对待</td><td style="text-align: center;">时间片小会导致吞吐率低</td></tr><tr class="odd"><td style="text-align: center;">VRR</td><td style="text-align: center;">交互式</td><td style="text-align: center;">短</td><td style="text-align: center;">对I/O密集型进程友好</td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;">MLQ</td><td style="text-align: center;">交互式和批处理</td><td style="text-align: center;">低优先级队列任务 响应时间长</td><td style="text-align: center;">可能造成饥饿</td><td style="text-align: center;">优先级反转</td></tr><tr class="odd"><td style="text-align: center;">MLFQ</td><td style="text-align: center;">交互式和批处理</td><td style="text-align: center;">短</td><td style="text-align: center;">兼顾长短作业</td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;">彩票算法</td><td style="text-align: center;">交互式和批处理</td><td style="text-align: center;">短</td><td style="text-align: center;">兼顾长短作业，考虑资源比例</td><td style="text-align: center;"></td></tr></tbody></table><h2 id="实时调度">实时调度</h2><h3 id="两种类型的实时">两种类型的实时</h3><ul><li><strong>硬实时</strong>：必须满足，否则会产生错误</li><li><strong>软实时</strong>：大多时候需满足，没有强制性</li></ul><h3 id="准入控制">准入控制</h3><blockquote><p>只有当系统能够保证所有进程的实时性的前提下，新的实时进程才能被准入</p></blockquote><p>如果满足以下条件，则作业就是可调度的 <span class="math display">\[\sum\frac{C_i}{T_i}\leq1\]</span> 其中<span class="math inline">\(C_i\)</span>为计算时间，<spanclass="math inline">\(T_i\)</span>为周期</p><h3 id="速率单调调度">速率单调调度</h3><h4 id="假设-1">假设</h4><ul><li>每个周期性进程必须在其周期内完成</li><li>进程之间没有依赖关系</li><li>每个进程在每个周期内需要的CPU时间相同</li><li>非周期性进程没有截止时间</li><li>进程抢占瞬时发生（没有开销）</li></ul><h4 id="基本思想">基本思想</h4><ul><li>给每个进程分配一个固定的优先级（出现频率）<ul><li>例如每50ms运行一次，则优先级是20</li></ul></li><li>运行最高优先级的进程</li><li>已经被证明是最优的静态优先级实时调度策略</li></ul><h3 id="最早截止时间优先调度edf">最早截止时间优先调度（EDF）</h3><h4 id="假设-2">假设</h4><ul><li>当进程运行时，它会提供其需要完成运行的截止时间</li><li>不一定是一个周期性的进程</li></ul><h4 id="基本思想-1">基本思想</h4><ul><li>根据截止时间对就绪的进程进行排序</li><li>运行列表中的第一个进程（最早截止时间优先）<ul><li>例如P1在30s之前结束，P2在40s之前结束，则P1先运行</li></ul></li><li>当新的进程就绪的时候，并且其截止时间快来临时，它会抢占当前进程</li></ul>]]></content>
      
      
      <categories>
          
          <category> Study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程</title>
      <link href="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%BA%BF%E7%A8%8B/"/>
      <url>/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="线程的概念">线程的概念</h1><h2 id="引入线程">引入线程</h2><ul><li>线程是进程的一部分，具有一段执行流</li><li>线程在同一个进程的地址空间内，可以共享变量</li><li>线程是CPU调度的基本单位</li></ul><h2 id="进程-vs-线程">进程 VS 线程</h2><h3 id="进程">进程：</h3><ul><li>运行时：代码、寄存器、堆栈、数据段</li><li>资源：地址空间、文件描述符、权限等</li></ul><blockquote><p>最简单的进程只有一个线程</p></blockquote><span id="more"></span><h3 id="地址空间">地址空间</h3><ul><li>进程之间不共享内存</li><li>进程切换会切换页表</li><li>进程中的线程共享整个地址空间</li></ul><h3 id="权限">权限</h3><ul><li>进程拥有自己的权限（如文件访问权限）</li><li>进程中的线程共享所有的权限</li></ul><h2 id="过程-vs-线程">过程 VS 线程</h2><h3 id="过程调用">过程调用</h3><ul><li><code>s0/fp</code>/指向栈底，<code>sp</code>指向最新的栈顶</li><li>被调用者将函数参数压栈</li><li>被调用者将局部变量压栈</li></ul><p><img src="https://raw.githubusercontent.com/JamesYuuu/Picbed/main/image-20221020104530721.png" alt="image-20221020104530721" style="zoom:80%;" /></p><h3 id="线程调用">线程调用</h3><ul><li>多线程并发执行<ul><li>多线程可以并行地在多个CPU上运行</li><li>过程调用是顺序的</li></ul></li><li>线程可能会乱序地执行<ul><li>不能利用栈恢复过程</li><li>每一个线程都有自己的栈</li></ul></li><li>线程不能频繁的切换<ul><li>每一个线程通常绑定一个CPU的核</li></ul></li></ul><h2 id="线程并发性并行性">线程并发性/并行性</h2><ul><li>人们希望同时完成多件事情（服务器需要同时服务多个请求）</li><li>计算交叠、I/O交叠（不同的线程使用不同的资源）</li><li>多个线程共享内存，但会带来共享资源访问问题</li></ul><h1 id="线程表示与操作api">线程表示与操作API</h1><h2 id="线程控制块tcb">线程控制块（TCB）</h2><ul><li>状态<ul><li>就绪态：准备运行</li><li>运行态：正在运行</li><li>阻塞态：等待资源</li></ul></li><li>寄存器</li><li>程序计数器（PC）</li><li>栈</li><li>代码</li></ul><h2 id="典型的线程api">典型的线程API</h2><h3 id="创建">创建</h3><p><code>create</code>，<code>join</code></p><h3 id="互斥">互斥</h3><p><code>acquire</code>，<code>release</code></p><h3 id="条件变量">条件变量</h3><p><code>wait</code>，<code>signal</code>，<code>broadcast</code></p><h3 id="警报">警报</h3><p><code>alert</code>，<code>alertwait</code>，<code>testalert</code></p><h2 id="线程上下文切换">线程上下文切换</h2><ul><li>保存上下文<ul><li>所有的寄存器（通用寄存器和浮点寄存器）</li><li>所有协处理器的状态</li></ul></li><li>开始新的上下文<ul><li>做保存上下文的逆操作</li></ul></li><li>可能触发进程的上下文切换<ul><li>单线程操作</li><li>执行I/O操作</li></ul></li></ul><h3 id="保存上下文">保存上下文</h3><ul><li>在线程的栈上保存上下文<ul><li>可以利用处理器专用的指令进行高效的保存</li><li>保存前需要确保栈上没有溢出的问题</li></ul></li><li>在<code>TCB</code>中保存上下文<ul><li>不存在溢出问题，但效率可能不是很高</li></ul></li></ul><h1 id="线程模型">线程模型</h1><h2 id="分类">分类</h2><ul><li>用户级线程</li><li>内核级线程</li><li>轻量级线程</li></ul><h3 id="分类依据核内调度-vs-核外调度">分类依据（核内调度 VS核外调度）</h3><ul><li>核外调度：减少上下文切换开销</li><li>核内调度：充分利用SMP结构</li></ul><h2 id="用户级线程协程">用户级线程（协程）</h2><blockquote><p>由一组用户级的线程库函数来完成线程的管理，包括线程的创建、终止、同步和调度等</p></blockquote><p><img src="https://raw.githubusercontent.com/JamesYuuu/Picbed/main/image-20221020104627285.png" alt="image-20221020104627285" style="zoom:80%;" /></p><h2 id="内核级线程">内核级线程</h2><blockquote><p>直接由内核本身启动的工作线程，执行内核函数</p></blockquote><h3 id="特点">特点</h3><ul><li>在CPU特权级中运行</li><li>访问内存的内核地址空间</li></ul><h2 id="轻量级线程lwp">轻量级线程（LWP）</h2><h3 id="特点-1">特点</h3><ul><li>共享某些资源的进程，例如地址空间、打开文件等资源</li><li>实现内核支持的线程机制</li></ul><p><img src="https://raw.githubusercontent.com/JamesYuuu/Picbed/main/image-20221020104706995.png" alt="image-20221020104706995" style="zoom:80%;" /></p><h3 id="模式一">模式一</h3><blockquote><p>用户空间线程映射到一个LWP上（Linux）</p></blockquote><p><img src="https://raw.githubusercontent.com/JamesYuuu/Picbed/main/image-20221020104727441.png" alt="image-20221020104727441" style="zoom:80%;" /></p><h3 id="模式二">模式二</h3><blockquote><p>多个用户空间线程映射到多个LWP上（Solaris，Unix，System V）</p></blockquote><p><img src="https://raw.githubusercontent.com/JamesYuuu/Picbed/main/image-20221020104752700.png" alt="image-20221020104752700" style="zoom:80%;" /></p><h2 id="用户级线程-vs-lwp">用户级线程 VS LWP</h2><ul><li>用户级线程<ul><li>用户级线程库实现线程上下文切换</li><li>时间中断会引入抢占</li><li>当用户级线程被I/O事件阻塞时，整个进程都会被阻塞</li></ul></li><li>LWP<ul><li>LWP被内核调度器调度</li><li>由于跨越了用户态和内核态，LWP的上下文切换开销大于用户级线程</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/JamesYuuu/Picbed/main/image-20221020104822873.png" alt="image-20221020104822873" style="zoom:80%;" /></p><h3 id="不同映射关系的对比">不同映射关系的对比</h3><ul><li>一对一：每一个线程都拥有自己的内核栈</li><li>多对一：一个进程的所有线程共享同一个内核栈</li><li>多对多：多个线程共享一个内核栈</li></ul><table><colgroup><col style="width: 13%" /><col style="width: 28%" /><col style="width: 28%" /><col style="width: 28%" /></colgroup><thead><tr class="header"><th style="text-align: center;"></th><th style="text-align: center;">一对一<br>私有的内核栈</th><th style="text-align: center;">多对多<br>共享的内核栈</th><th style="text-align: center;">多对一<br>共享的内核栈</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">内存消耗</td><td style="text-align: center;">高</td><td style="text-align: center;">中</td><td style="text-align: center;">低</td></tr><tr class="even"><td style="text-align: center;">系统服务</td><td style="text-align: center;">并发</td><td style="text-align: center;">部分并发</td><td style="text-align: center;">串行访问</td></tr><tr class="odd"><td style="text-align: center;">多处理器</td><td style="text-align: center;">是</td><td style="text-align: center;">部分利用</td><td style="text-align: center;">无法利用</td></tr><tr class="even"><td style="text-align: center;">内核复杂性</td><td style="text-align: center;">高</td><td style="text-align: center;">高</td><td style="text-align: center;">低</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程</title>
      <link href="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B/"/>
      <url>/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="进程的起源">进程的起源</h1><blockquote><p>分时共享的诞生，使得多个程序可以同时运行，“进程”开始登上了历史舞台。</p></blockquote><h1 id="进程的概念与表示">进程的概念与表示</h1><h2 id="进程的概念">进程的概念</h2><p>进程是指一个具有一定独立功能的程序在一个数据集合上的一次动态执行过程</p><p>进程刻画了一个程序运行所需要的资源和运行状态</p><p><img src="https://raw.githubusercontent.com/JamesYuuu/Picbed/main/image-20221020103850775.png" alt="image-20221020103850775"/></p><span id="more"></span><h2 id="进程资源">进程资源</h2><h3 id="进程cpu资源">进程CPU资源</h3><ul><li>寄存器<ul><li>PC</li><li>栈指针（SP寄存器）</li><li>其他标志信息（SSTATUS寄存器）</li></ul></li></ul><h3 id="进程内存资源">进程内存资源</h3><ul><li>抽象：进程地址空间</li></ul><h3 id="进程io资源">进程I/O资源</h3><ul><li>抽象：文件（文件描述符）</li></ul><h2 id="进程在内核中的表示">进程在内核中的表示</h2><p>每个进程的创建和销毁都由内核来负责，内核需要对每个进程登记信息。</p><p>内核用进程控制块（<code>PCB</code>）来保存进程的信息，同样内核也利用<code>PCB</code>来索引进程。</p><h3 id="pcb块中包含的信息"><code>PCB</code>块中包含的信息</h3><ul><li>进程标识信息：进程ID、进程名称</li><li>与各种资源相关的信息<ul><li>CPU、内存、文件、通信等</li></ul></li><li>CPU相关的进程管理信息<ul><li>状态：就绪态、运行态、阻塞态等</li><li>寄存器，SSTATUS等其他CPU状态</li><li>优先级</li></ul></li><li>内存管理信息<ul><li>栈（用户栈和内核栈），代码段和数据段</li><li>页表、统计信息等</li></ul></li><li>I/O和文件管理<ul><li>通信端口、目录和文件描述符等</li></ul></li></ul><h2 id="进程-vs-程序">进程 VS 程序</h2><h3 id="关联">关联</h3><ul><li>程序是进程的一部分（代码段）</li><li>进程是程序的动态执行</li></ul><h3 id="区别">区别</h3><ul><li>一个程序可以创建多个进程</li><li>进程还包含运行时状态和所使用的资源信息</li></ul><h1 id="进程的状态">进程的状态</h1><h2 id="进程的创建">进程的创建</h2><h3 id="什么时候会创建进程">什么时候会创建进程</h3><ul><li>系统初始化的时候</li><li>用户操作（在终端中调用命令）</li><li>正在运行的进程通过<code>syscall</code>创建新的进程</li></ul><h3 id="怎么样创建进程">怎么样创建进程</h3><ul><li>创建并初始化<code>PCB</code></li><li>创建地址空间、调用栈和堆</li><li>将数据和代码加载至内存</li><li>初始化进程的状态，将进程标志为就绪态</li></ul><h2 id="进程的运行">进程的运行</h2><blockquote><p>内核选择一个就绪的进程，为它分配一个处理器的时间片，并开始执行。</p></blockquote><h3 id="如何选择就绪的进程">如何选择就绪的进程？</h3><ul><li>进程调度算法</li><li>进程优先级</li></ul><h2 id="进程抢占">进程抢占</h2><h3 id="进程时间片用完">进程时间片用完</h3><ul><li>非抢占式内核<ul><li>进程始终保持运行，直到其主动退出并让出CPU资源</li></ul></li><li>抢占式内核<ul><li>在时间片用完后，调度高优先级进程</li></ul></li></ul><h2 id="进程等待">进程等待</h2><h3 id="进程进入等待阻塞的情况">进程进入等待（阻塞）的情况</h3><ul><li>需要的数据没有到达/需要的资源没有获得（等待用户输入/等待锁）</li><li>进程主动进入等待（sleep）</li><li>请求并等待系统服务，无法立刻完成（内存页分配、硬盘读写）</li></ul><h2 id="进程唤醒">进程唤醒</h2><h3 id="唤醒进程的情况">唤醒进程的情况</h3><ul><li>被阻塞进程需要的资源被满足</li><li>被阻塞进程等待的事件到达</li></ul><blockquote><p>进程只能被别的进程或操作系统唤醒</p></blockquote><h2 id="进程结束">进程结束</h2><h3 id="进程结束的情况">进程结束的情况</h3><ul><li>正常运行结束，退出</li><li>发生错误，退出</li><li>被其他进程所杀</li></ul><h2 id="进程状态转换图">进程状态转换图</h2><p><img src="https://raw.githubusercontent.com/JamesYuuu/Picbed/main/image-20221020104002142.png" alt="image-20221020104002142" style="zoom:67%;" /></p><h2 id="进程上下文切换">进程上下文切换</h2><ul><li>保存上下文<ul><li>保存所有的寄存器（通用寄存器以及浮点寄存器）以及部分特殊寄存器状态（标志位状态）</li><li>保存所有协处理器的状态</li></ul></li><li>恢复上下文<ul><li>做保存上下文相反的操作</li></ul></li><li>实现<ul><li>硬件自动保存和恢复（X86 TaskRegister寄存器，通过修改其值触发硬件保存所有的寄存器值）</li><li>软件保存和恢复：通过汇编指令保存相关的寄存器</li></ul></li></ul><h2 id="进程生命周期">进程生命周期</h2><ul><li>抢占式内核<ul><li>进程创建</li><li>进程执行</li><li><strong>进程抢占</strong></li><li>进程等待</li><li><strong>进程唤醒</strong></li><li>进程结束</li></ul></li><li>非抢占式内核<ul><li>进程创建</li><li>进程执行</li><li>进程等待</li><li>进程结束</li></ul></li></ul><h1 id="进程的操作原语api">进程的操作原语（API）</h1><h2 id="创建和终止">创建和终止</h2><p><code>Fork</code>，<code>Exec</code>，<code>Wait</code>，<code>Kill</code></p><h3 id="fork">Fork</h3><ul><li>克隆出一个进程</li><li>共享当前代码段，复制数据段、堆栈、页表等</li><li>采用写时复制机制</li></ul><h3 id="exec">Exec</h3><ul><li>替换掉当前进程等代码段、数据段、堆栈等</li></ul><h3 id="wait">Wait</h3><ul><li>等待子进程结束</li></ul><h3 id="kill">Kill</h3><ul><li>向进程发送信号，结束进程并释放资源</li></ul><h2 id="操作">操作</h2><p><code>Block</code>，<code>Yield</code></p><h2 id="信号">信号</h2><p><code>Cond</code>，<code>Signal</code></p><h2 id="同步">同步</h2><p><code>Lock</code>，<code>Semaphore</code>，<code>Barrier</code></p><h1 id="进程并发和并行">进程、并发和并行</h1><h2 id="进程的顺序执行">进程的顺序执行</h2><p><img src="https://raw.githubusercontent.com/JamesYuuu/Picbed/main/image-20221020104115533.png" alt="image-20221020104115533" style="zoom:50%;" /></p><h2 id="进程和并发性">进程和并发性</h2><h3 id="并发性">并发性</h3><ul><li>一个系统中有多个进程“同时”运行<strong>（逻辑上）</strong></li><li>CPU、DRAM和I/O设备是共享的</li><li>每一个进程都希望能拥有自己的计算机资源</li></ul><h3 id="虚拟化分时复用">虚拟化（分时复用）</h3><ul><li>每个进程都运行一段时间（时间片）</li><li>使得一个CPU变成“多个”，每一个进程就好像拥有了自己的CPU</li></ul><p><img src="https://raw.githubusercontent.com/JamesYuuu/Picbed/main/image-20221020104210102.png" alt="image-20221020104210102" style="zoom:50%;" /></p><h3 id="cpu并行性">CPU并行性</h3><ul><li><p>多个CPU（如SMP）</p></li><li><p>使得进程在物理上能够同时运行，进而加速程序</p></li></ul><p><img src="https://raw.githubusercontent.com/JamesYuuu/Picbed/main/image-20221020104232404.png" alt="image-20221020104232404" style="zoom:50%;" /></p><h3 id="io并行性">I/O并行性</h3><ul><li>CPU计算与I/O操作交叠</li><li>减少总共所需的完成时间</li></ul><p><img src="https://raw.githubusercontent.com/JamesYuuu/Picbed/main/image-20221020104313620.png" alt="image-20221020104313620" style="zoom:50%;" /></p><h2 id="并发和并行">并发和并行</h2><h3 id="并发">并发</h3><blockquote><p>一个系统能同时处理多个任务的能力，但在同一时刻可能只有一个任务在运行</p></blockquote><h3 id="并行">并行</h3><blockquote><p>一个系统在同一时刻支持多个任务同时运行</p></blockquote><h3 id="并行性收益">并行性收益</h3><ul><li>将一个复杂的问题分解成多个子问题</li><li>每个子问题由一个进程处理</li><li>多个进程同时处理，减少处理时间</li></ul>]]></content>
      
      
      <categories>
          
          <category> Study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统结构与组成</title>
      <link href="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BB%84%E6%88%90/"/>
      <url>/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BB%84%E6%88%90/</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统结构">操作系统结构</h1><h2 id="操作系统启动">操作系统启动</h2><ul><li>计算机上电</li><li>处理器Reset<ul><li>设置到初始状态</li><li>跳转到ROM代码（BIOS）</li><li>初始化启动所需最少的设备</li></ul></li><li>从持久存储中加载BootLoader</li><li>跳转到BootLoader继续执行</li><li>加载OS其余的部分</li><li>初始化OS并运行</li></ul><span id="more"></span><h2 id="程序的执行">程序的执行</h2><ul><li>GCC编译、汇编、链接各模块</li><li>编译器将程序编译成汇编文件</li><li>汇编器将汇编代码编程为可重定位的对象文件</li><li>链接器将多个对象文件链接成一个可执行文件</li></ul><h3 id="elf-文件格式">ELF 文件格式</h3><ul><li>ELF（Executable and Linking Format）<ul><li>可重定位的对象文件（.o）</li><li>可执行的对象文件</li><li>可被共享的对象文件（.so）</li></ul></li><li>链接视图<ul><li>由多个section组成</li></ul></li><li>执行视图<ul><li>由多个segments组成</li></ul></li></ul><h3 id="四个段">四个段</h3><ul><li>代码段：指令序列（text segment）</li><li>数据段：全局数据（data segment）</li><li>栈（stack）</li><li>堆（heap）</li></ul><h4 id="布局特点">布局特点</h4><ul><li>为了将代码段和数据段分离</li><li>栈和堆相向生长<ul><li>栈自顶向底生长</li><li>堆自底向顶生长</li></ul></li></ul><h4 id="全局数据和代码段">全局数据和代码段</h4><ul><li>编译器静态分配，产生名字和符号索引</li><li>链接器翻译索引和重定位地址</li><li>加载器最终完成在内存的布局</li></ul><h4 id="栈">栈</h4><ul><li>由编译器布局</li><li>进程创建的时候分配、进程结束的时候释放</li><li>相对于栈顶（栈指针）寻址</li></ul><h4 id="堆">堆</h4><ul><li>链接器和加载器确定起始地址</li><li>通过库函数<code>malloc</code>和<code>free</code>进行分配和释放</li><li>应用程序通过库函数进行管理</li></ul><h3 id="加载器">加载器</h3><p>在<code>Unix</code>下，由加载器<code>Loader</code>完成如下工作</p><ul><li>读取一个可执行文件</li><li>放置代码、数据、堆和栈</li><li>动态链接到共享库</li><li>运行应用程序</li></ul><h2 id="典型的unix操作系统">典型的UNIX操作系统</h2><ul><li>用户层<ul><li>应用：程序员编写并编译后的应用程序</li><li>库：<ul><li>精心设计的代码</li><li>预编译好的对象</li><li>通过头文件定义</li><li>通过链接器引入</li><li>类似函数调用</li><li>程序加载时必须定位</li></ul></li></ul></li><li>核心层<ul><li>可移植层：系统调用功能的集合</li><li>机器相关层<ul><li>启动</li><li>初始化</li><li>中断和例外</li><li>I/O设备驱动</li><li>内存管理</li><li>处理器调度</li><li>模式切换</li></ul></li></ul></li></ul><h2 id="程序运行保护">程序运行保护</h2><h3 id="cpu保护">CPU保护</h3><ul><li>保护CPU不被某个用户程序长期占用</li><li>保护用户程序间的尽可能隔离</li><li>维护CPU资源的抢占</li></ul><h3 id="内存保护">内存保护</h3><ul><li>避免用户程序修改OS的代码和数据结构</li></ul><h3 id="io保护">I/O保护</h3><ul><li>防止用户程序随意的写入磁盘的任何位置</li></ul><h2 id="内核态的保护机制">内核态的保护机制</h2><blockquote><p>需要满足处理器支持特权态，可以在特权模式和用户模式下切换。</p></blockquote><pre><code class="highlight mermaid">graph LRA([用户模式])----&gt;|中断或异常|B([特权模式])B----&gt;|特殊的返回指令|A</code></pre><ul><li><p>在用户模式下只能执行常规指令和访问用户内存。</p></li><li><p>在特权模式下可以执行特权指令和访问核心内存。</p><ul><li>特权指令包括<ul><li>读写系统状态寄存器（CSR寄存器）</li><li>执行I/O操作</li><li>无效快表（TLB）项</li></ul></li></ul></li></ul><h3 id="中断">中断</h3><h4 id="硬件中断">硬件中断</h4><ul><li>由外部事件（外部设备）触发<ul><li>例如：时钟中断，硬盘读写请求完成，移动鼠标，键盘输入</li></ul></li><li>硬件中断产生与当前正在执行的进程无关</li><li>硬件中断可以被关闭（CSR寄存器）</li></ul><h4 id="可编程中断软件中断">可编程中断（软件中断）</h4><ul><li>由编程者用相应指令触发（<code>syscall</code>)</li></ul><h4 id="中断处理程序">中断处理程序</h4><p>触发中断后，系统内核跳转到中断处理程序中，处理完毕后恢复被中断的进程。</p><h3 id="异常">异常</h3><ul><li>由当前正在执行的进程产生</li><li>类型：<ul><li>出错：处理后，重新执行触发异常的指令</li><li>陷入：处理后，执行触发异常指令的下一条指令</li><li>中止：不再执行指令</li></ul></li></ul><h3 id="系统调用机制">系统调用机制</h3><blockquote><p>关键和核心功能由内核完成，用户仅仅进行调用，而不修改内核代码</p></blockquote><h4 id="过程">过程</h4><ul><li>系统调用参数传递<ul><li>寄存器传参<ul><li>可用寄存器个数</li><li>系统调用参数个数</li></ul></li><li>内存向量（数组）传参<ul><li>一个寄存器传递起始地址</li><li>向量位于用户地址空间</li></ul></li><li>堆栈传参<ul><li>类似内存向量</li><li>遵循过程调用的约定</li></ul></li></ul></li><li>系统模式从用户态切换到内核态</li><li>执行系统调用功能</li><li>返回结果，切换到用户态<ul><li>通过寄存器返回结果</li><li>将错误返回给调用者</li></ul></li></ul><h4 id="系统调用-对比-库函数调用">系统调用 对比 库函数调用</h4><ul><li>系统调用</li><li>陷入内核，在内核态执行具体功能</li><li>依赖于操作系统</li><li>内核态和用户态切换</li><li>库函数调用<ul><li>在进程用户态空间执行和执行功能</li><li>标准C库函数相同</li><li>过程调用</li></ul></li></ul><h5 id="内存管理">内存管理</h5><ul><li>内核<ul><li>分配带硬件保护的页面</li><li>分配一大块（多个页面）给库</li><li>不关心小粒度的分配</li><li>通过<code>sbrk/brk/mmap</code>等函数分配页面，改变数据段长度</li></ul></li><li>库<ul><li>提供<code>malloc/free</code>等函数用于分配和释放内存</li><li>应用通过这些函数细粒度管理内存</li><li>当页面用完后，库函数会向内核批量请求更多的页面</li></ul></li></ul><h2 id="内核结构">内核结构</h2><h3 id="宏内核linuxwindowsbsd-unix">宏内核（Linux，Windows，BSDUnix）</h3><ul><li>在内核态实现操作系统所有功能</li><li>应用通过调用系统调用（<code>syscall</code>）使用操作系统提供的功能</li><li>好处<ul><li>内核所有函数共享地址空间</li><li>内核模块通信性能高</li></ul></li><li>缺点<ul><li>不稳定：模块的崩溃会造成系统的崩溃</li><li>不灵活：新增模块需要对内核进行编程</li></ul></li></ul><h3 id="微内核machminix">微内核（Mach，MINIX）</h3><ul><li>操作系统功能服务作为用户态的常规进程</li><li>应用通过消息获取服务进程的服务</li><li>好处<ul><li>开发灵活</li><li>故障隔离</li></ul></li><li>缺点<ul><li>进程间的通信效率低</li><li>保护机制不完整</li></ul></li></ul><h3 id="库操作系统exokernelexos">库操作系统（Exokernel，ExOS）</h3><ul><li>应用程序直接通过库与底层硬件交互</li><li>好处<ul><li>效率高</li></ul></li><li>缺点<ul><li>通用性差</li></ul></li></ul><h1 id="操作系统组成">操作系统组成</h1><ul><li>处理器管理</li><li>内存管理</li><li>I/O设备管理</li><li>文件系统</li><li>GUI</li></ul>]]></content>
      
      
      <categories>
          
          <category> Study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统课程简介</title>
      <link href="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E7%AE%80%E4%BB%8B/"/>
      <url>/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是系统">什么是系统</h1><p>由一群有关联的组件/部件/模块/个体组成，根据某种规则运作，能完成单个组件不能单独完成的工作的群体/整体。</p><h2 id="系统特征">系统特征</h2><ul><li>系统是复杂的<ul><li>不同组件之间需要交互</li><li>各个组件本身也很复杂</li></ul></li><li>系统设计是多目标的</li><li>系统工作与理论工作<ul><li>理论工作：寻找极限</li><li>系统工作：追求均衡/协调</li><li>在实现系统前先明确系统设计目标</li></ul></li></ul><span id="more"></span><h1 id="什么是操作系统">什么是操作系统</h1><p>操作系统是应用和硬件之间的一层软件。</p><ul><li>对底层硬件进行管理、实现共享且保证隔离</li><li>对上层软件提供硬件抽象、实现共用功能和操作接口</li></ul><h2 id="操作系统能做什么">操作系统能做什么</h2><ul><li>运行一个或多个程序</li><li>提供抽象与接口（例如输入和输出、使用硬件资源等）</li><li>CPU、内存等的资源使用、管理与隔离</li><li>数据持久化与存储设备管理</li><li>并发访问控制（控制多个程序访问相同资源时的正确性）</li><li>保证操作系统不因为一个用户程序的崩溃而崩溃</li><li>将数据传递给远程的计算机</li><li>虚拟机和容器技术</li><li>保护数据的安全等</li></ul><h2 id="操作系统的发展">操作系统的发展</h2><ul><li>大型机<ul><li>1954——IBM 701计算机<ul><li>OS作为一个通用函数库</li><li>用户提交程序，运行完后切换下一个用户</li></ul></li><li>1959——IBM 709计算机<ul><li>支持批处理</li></ul></li></ul></li><li>小型机<ul><li>1960s<ul><li>支持多个程序并行</li><li>CPU、内存和存储资源共享与隔离</li></ul></li><li>1965——Mulitics 和 1974——UNIX<ul><li>分时操作系统（Time-sharingOS），使用<code>Round-Robin</code>算法。</li></ul></li></ul></li><li>个人计算机<ul><li>Alto OS<ul><li>GUI</li><li>以太网</li><li>文件系统</li><li>顺序执行的单用户系统</li></ul></li><li>DOS Linux MacOS Windows</li></ul></li><li>集群<ul><li>网络连接的计算机</li><li>商用操作系统+分布式框架（MapReduce、Spark）</li></ul></li><li>云计算<ul><li>数据中心是一台计算机，按需分配资源</li><li>Mesos和Kubernetes作为数据中心的操作系统</li></ul></li><li>物联网<ul><li>嵌入式OS（RT-Thread，LiteOS）</li><li>移动端OS（iOS，Android）</li></ul></li></ul><h1 id="如何学好操作系统">如何学好操作系统</h1><blockquote><p>理论联系实际，不断地阅读代码和开发代码</p></blockquote><p>讲授内容</p><ul><li>操作系统结构</li><li>处理器：进程、线程和中断</li><li>并发：同步、通信</li><li>内存：虚存管理</li><li>设备：驱动</li><li>存储：文件系统</li></ul>]]></content>
      
      
      <categories>
          
          <category> Study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GalGame CG提取——ExHIBIT引擎篇</title>
      <link href="/GalGame%E8%A7%A3%E5%8C%85/GalGame%E8%A7%A3%E5%8C%85(ExHIBIT)/"/>
      <url>/GalGame%E8%A7%A3%E5%8C%85/GalGame%E8%A7%A3%E5%8C%85(ExHIBIT)/</url>
      
        <content type="html"><![CDATA[<h1 id="游戏引擎">游戏引擎</h1><p>ExHIBIT引擎</p><h1 id="主要使用厂商">主要使用厂商</h1><p>Skyfish社及其子社，Moonstone社及其子社</p><span id="more"></span><h1 id="游戏文件结构">游戏文件结构</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">├──fonts</span><br><span class="line">├──res</span><br><span class="line">│  ├──c</span><br><span class="line">│  ├──g</span><br><span class="line">│  │  ├──ch</span><br><span class="line">│  │  ├──ev</span><br><span class="line">│  │  ├──gn</span><br><span class="line">│  │  └──sy</span><br><span class="line">│  └──s</span><br><span class="line">│     ├──e</span><br><span class="line">│     └──m</span><br><span class="line">├──rld</span><br><span class="line">└──userdata</span><br></pre></td></tr></table></figure><h2 id="fonts">fonts</h2><p>fonts文件夹中存放字体文件。</p><h2 id="rld">rld</h2><p>rld文件夹中存放格式为.rld的剧本文件。</p><h2 id="userdata">userdata</h2><p>userdata文件夹中存放存档。</p><h2 id="res">res</h2><p>res文件夹中存放游戏资源。</p><h2 id="c">c</h2><p>c文件夹下存放格式为.rnf的游戏脚本文件</p><h2 id="g">g</h2><p>g文件夹下存放格式为.gyu的游戏图片文件，分为四个文件夹。</p><h3 id="ch">ch</h3><p>存放游戏立绘。</p><h3 id="ev">ev</h3><p>存放游戏CG。</p><h3 id="gn">gn</h3><p>存放效果图片。</p><h3 id="sy">sy</h3><p>存放游戏界面所需的系统图片</p><h2 id="s">s</h2><p>s文件下存放游戏的声音文件，分为两个文件夹。</p><h3 id="e">e</h3><p>存放格式为.wav的游戏配音文件</p><h3 id="m">m</h3><p>存放格式为.ogg的游戏BGM</p><h1 id="解包方法">解包方法</h1><p>游戏的CG以.gyu格式存放在res。通常ev文件夹下分为多个文件夹，通常每个文件夹为游戏的一组包含差分的CG，此外也有文件夹中保存背景图片。</p><h2 id="garbro">Garbro</h2><p>下载地址：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL21vcmt0L0dBUmJybw==">morkt/GARbro:Visual Novels resource browser (github.com)<i class="fa fa-external-link-alt"></i></span></p><p>Garbro是一个非常方便的解包软件，可以直接查看.gyu文件并提取。</p><h2 id="asmodean-gyu2bmp">Asmodean: gyu2bmp</h2><p>下载地址：<span class="exturl" data-url="aHR0cDovL2FzbW9kZWFuLnJldmVyc2UubmV0L3BhZ2VzL2d5dTJibXAuaHRtbA==">asmodean's reverseengineering page - gyu2bmp<i class="fa fa-external-link-alt"></i></span></p><p>Asmodean开发了大量针对性的工具，此处为用于将.gyu转换为.bmp格式的图片，使用方法如下：</p><p>1、新建一个文件夹，将上述res，并将rld文件夹中def.rld也复制到里面</p><p>2、修复CG文件的key：运行下面的bat文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fixipgyu.exe def.rld</span><br></pre></td></tr></table></figure><p>3、提取CG：运行下面的bat文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> /r %%i <span class="keyword">in</span> (*.gyu) <span class="keyword">do</span> gyu2bmp.exe %%i</span><br></pre></td></tr></table></figure><h2 id="后记">后记</h2><p>部分ExHIBIT引擎制作的游戏，存在一张大图配合多张小块差分CG的情况，图像大小信息存储在原始gyu的第5和第6两个字节，坐标信息保存在原始gyu文件的末尾，其中5050代表底图的文件名，384和80代表差分应该覆盖区域的左上角坐标。</p><figure><img src="https://raw.githubusercontent.com/JamesYuuu/Picbed/main/1.png"alt="gyu" /><figcaption aria-hidden="true">gyu</figcaption></figure><p>写了如下python代码进行处理，需要安装python和ImageMagick，并且将原gyu和bmp放在同一个文件夹下。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> files <span class="keyword">in</span> os.listdir(<span class="string">&quot;./&quot;</span>):</span><br><span class="line">    <span class="keyword">if</span> os.path.isdir(files):</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> file <span class="keyword">in</span> os.listdir(files):</span><br><span class="line">            file=os.path.join(files,file)</span><br><span class="line"></span><br><span class="line">            ext=file.split(<span class="string">&quot;.&quot;</span>)[-<span class="number">1</span>]</span><br><span class="line">            file_name=file.split(<span class="string">&quot;.&quot;</span>)[<span class="number">0</span>]+<span class="string">&quot;.bmp&quot;</span></span><br><span class="line">            <span class="keyword">if</span> ext==<span class="string">&quot;gyu&quot;</span>:</span><br><span class="line">                <span class="keyword">with</span> <span class="built_in">open</span>(file,<span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> gyu:</span><br><span class="line">                    data=gyu.read()</span><br><span class="line"></span><br><span class="line">                    x,y=struct.unpack(<span class="string">&quot;&lt;2I&quot;</span>,data[<span class="number">16</span>:<span class="number">24</span>])</span><br><span class="line">            </span><br><span class="line">                    length=<span class="built_in">len</span>(data)</span><br><span class="line">                    num=length-<span class="number">1</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">while</span> data[num]==<span class="number">0</span>:</span><br><span class="line">                        num=num-<span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> length-num-<span class="number">1</span>&lt;=<span class="number">3</span>:</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">            </span><br><span class="line">                    current_num=num</span><br><span class="line">                    <span class="keyword">while</span> data[current_num]!=<span class="number">0</span>:</span><br><span class="line">                        current_num=current_num-<span class="number">1</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span>  num+<span class="number">1</span>-current_num&gt;<span class="number">30</span>:</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">                    location=data[current_num:num+<span class="number">1</span>].decode(encoding=<span class="string">&quot;utf8&quot;</span>).split(<span class="string">&quot;,&quot;</span>)</span><br><span class="line">            </span><br><span class="line">                    base_file=os.path.join(location[<span class="number">0</span>][-<span class="number">4</span>:-<span class="number">2</span>],location[<span class="number">0</span>][-<span class="number">4</span>:]+<span class="string">&quot;.bmp&quot;</span>)</span><br><span class="line">                    size=<span class="built_in">str</span>(x)+<span class="string">&quot;x&quot;</span>+<span class="built_in">str</span>(y)+<span class="string">&quot;+&quot;</span>+location[<span class="number">1</span>]+<span class="string">&quot;+&quot;</span>+location[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">                    os.system(<span class="string">&quot;magick &quot;</span>+base_file+<span class="string">&quot; -compose over &quot;</span>+file_name+<span class="string">&quot; -geometry &quot;</span>+size+<span class="string">&quot; -composite &quot;</span>+file_name)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CG提取 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GalGame </tag>
            
            <tag> CG提取 </tag>
            
            <tag> moonstone </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>苍之彼方的四重奏——四色华彩，奏响彼方</title>
      <link href="/GalGame%E6%84%9F%E6%83%B3/%E8%8B%8D%E4%B9%8B%E5%BD%BC%E6%96%B9%E7%9A%84%E5%9B%9B%E9%87%8D%E5%A5%8F/"/>
      <url>/GalGame%E6%84%9F%E6%83%B3/%E8%8B%8D%E4%B9%8B%E5%BD%BC%E6%96%B9%E7%9A%84%E5%9B%9B%E9%87%8D%E5%A5%8F/</url>
      
        <content type="html"><![CDATA[<p>体育竞技类题材的作品在ACG中极为常见，远的有灌篮高手、黑子的篮球等令人爷青回的作品，近的也有口碑爆棚的乒乓、小排球、Free！这些高燃的新作，大部分的这类体育系作品往往有一套较为标准的设计思路，从新生的加入、基础规则的介绍、平时的训练、个人和团队间的对抗、从地区大赛进军全国大赛等等。体育竞技类作品的框架大多固定，经过多年的发展，对天赋和努力，个人和团队之间的探讨已经达到了一个很高的境界。</p><p><imgsrc="https://raw.githubusercontent.com/JamesYuuu/Picbed/main/1044620_20210816151300_1.png" /></p><span id="more"></span><p>苍彼作为其中的一类，却采用了完整的刻画一个虚构的运动这样的作法，这是极为少见的，更是需要极大的勇气。因为在脱离了现实的参照，想要设计好一个公平的、逻辑严密的运动，也是极难的。当然，高风险同样伴随着高收益，虚构一项运动意味着可以稍微脱离现实和规则的束缚进行原创，更好的发挥，更好的展现主旨。苍彼的故事展开就完全围绕着虚构的FlyingCircus（空竞）展开，大致的设计参考了战斗机空战的缠斗，如果有军迷的读者可千万不要错过哦。</p><p><imgsrc="https://raw.githubusercontent.com/JamesYuuu/Picbed/main/20210816134117_1.jpg" /></p><blockquote><p>无剧透简介：以和明日香的相遇为契机，晶也当上了空竞部的教练。虽说晶也很积极地进行指导，但明日香还刚入门，美咲根本没有干劲，真白没事就会挑刺儿找事，最后甚至跟住在隔壁的莉佳也发生了莫须有的误会，每天过得都可谓是惊心动魄波澜万丈。这时，久奈滨学院与高藤学院空竞部举办的一场合宿活动，让美咲对当代最强的飞空士真藤产生了强烈的竞争意识。而明日香也在和莉佳的比赛中使用高难度竞技技巧，让人感受到她蕴藏的无限潜力。虽然合宿期间也发生了一些大大小小的插曲，但不同的练习环境的确给久奈滨空竞部带来了很大的激励和提高，之后又会发生什么样的故事呢？</p></blockquote><p>苍彼的作画，配乐，演出堪称顶级，三者的完美配合，使得每一场FC比赛都给予我身临其境、血脉贲张的快感，但是Galgame中最重要的是剧情，再怎样顶级的配料，没有优秀的正餐，也只会令人索然无味。苍彼拥有一条极长的共通线，大致占了篇幅的七成作用，虽然大部分是为了刻画FC这项虚构的运动，介绍近未来的世界观而不得不着笔的笔墨，但稀释在其中的日常，稍微有些平淡和乏味，个人觉得节奏的控制不是很好，略有些拖沓。</p><h1 id="明日香线">明日香线</h1><p><imgsrc="https://raw.githubusercontent.com/JamesYuuu/Picbed/main/20210816133636_1.jpg" />明日香线就是少年漫画中带有主角光环的龙傲天剧情，极致的天赋、极致的努力、极致的热爱，再配上天然的性格，让人心生羡慕，又让人心生一些嫉妒。这条线中的男主（玩家）完全起不到一些作用，无所谓什么设计战术，只需要单纯的欣赏明日香从初学者开始各种开挂，一路走向世界大赛的过程。尽管整个过程让人看得热血澎湃，却缺少了一些深度。在明日香心中极为重要的动力“小时候的约定”，尽管有着不断的铺垫，但直到故事的结尾也没有解开，令人心生疑惑。明日香线中另一个败笔就是不合时宜的H场景的插入，在紧张激烈的竞技氛围中，在我期待着下一次空竞大战时，莫名其妙的两人独处一室，晶也一反常态地把明日香推倒，只有让人赶快c过去的冲动。总而言之，明日香线就是单纯的王道热血，少了一些深度。</p><p><imgsrc="https://raw.githubusercontent.com/JamesYuuu/Picbed/main/20210816133700_1.jpg" /></p><h1 id="真白线">真白线</h1><p><imgsrc="https://raw.githubusercontent.com/JamesYuuu/Picbed/main/20210816133809_1.jpg" /></p><p>真白是本作中人气最高的女主了，是唯一拥有FD的女主，其个人线中的甜度可见一斑，经过共通线中整整一话的铺垫，讲真白傲娇可爱的性格展现的淋漓尽致。在个人线中回收了对美咲憧憬的伏笔，展现了她对于友情的珍视，同样也丰满了美咲的形象。真白在自己屋子里扮演玩偶，自我攻略的样子更是萌到爆表，和男主之间感情的走势也是循序渐进，节奏感极好，吃醋徘徊的小细节更是让玩家脸红心跳，最后FC的剧情也算说的过去，完成了对美咲的救赎。总而言之，这是四条线中最甜，最像传统gal的线了，最能体会到恋爱的青春气息。</p><p><imgsrc="https://raw.githubusercontent.com/JamesYuuu/Picbed/main/20210816133818_1.jpg" /></p><h1 id="莉佳线">莉佳线</h1><p>不同学校的设定，在竞技类的gal中反而成为了败笔，尽管通过了邻居的设定来平衡了距离，但共通线中的出现实在是太少了，沦为了单纯发福利的路人，我甚至觉得在真白线中的莉佳，更有着立体感。莉佳的特点就是完美的优等生，拥有极佳的人妻属性，不过在个人线中还是回收了一个共通线中的伏笔，更多地探讨了友情的意义和竞技比赛中规则的意义。但这条线既没有真白线甜，也没有明日香线王道，更没有美咲线有深度，不如换成窗果线，毕竟这个女人可是该死的有趣啊，且和非空竞选手谈恋爱不是更好的调剂吗（笑）。</p><p><imgsrc="https://raw.githubusercontent.com/JamesYuuu/Picbed/main/20210816133838_1.jpg" /></p><p><imgsrc="https://raw.githubusercontent.com/JamesYuuu/Picbed/main/20210816133724_1.jpg" /></p><h1 id="美咲线">美咲线</h1><p>美咲线是真正将苍彼推上一个台阶的“MVP”级别的个人线，她将美咲这样一个看似懒散、放荡不羁、实则自尊心极强、有着复杂少女心的角色塑造的淋漓尽致。她和男主的羁绊也最深，最后成功的回收了开篇的伏笔，令人震撼。最后美咲和两个天才明日香和乾的大战，更是展示了男主在战术层面不断突破的魅力，真正的体现出了空竞中副手的意义。如果说明日香线是绝对的实力碾压，美咲线则更像是智取，有着不一样的魅力。但在我心中，美咲线更多的震撼来自于真实，当美咲发现天赋远胜于自己的明日香时，她的选择是放弃，这更像是普通人不是吗？当天赋不如他人时，再多的努力又有什么意义了，不如在一开始就放弃好了，这样不是还能留点念想，给自己多留一个台阶吗？美咲看似懒散、无所谓的态度，实则是自己极强的好胜心的保护伞，保护了自己的自尊不受到更大的摧残。当然，gal不是现实，美咲在主线中和晶也完成了互相的救赎，在真白线中被晶也和真白共同救赎，体会到了努力本身的意义，努力本身带来的快乐，学会了坦然接受失败。美咲线展示出了竞技体育甚至是人性的黑暗面，为本作带来了升华。但回到现实中，真的能做到这样吗，做到不含杂质的努力，单纯去享受努力本身，或许这才是苍彼为我们带来的思考。</p><p><imgsrc="https://raw.githubusercontent.com/JamesYuuu/Picbed/main/20210816133738_1.jpg" /></p><p>​最后，想作为一个体育迷，简单吐槽一下苍彼的设定，明日香这样才玩了不到一年空竞，就能够打进世界大赛的剧情，实在是有些离谱了。竞技体育远比苍彼中所描写的残酷的多得多得多，更多的人是像晶也一样从小开始不断地训练。像明日香线最后，关掉鞋子平衡器之后的大战，稍微有些对于其他选手努力付出的不尊重，也是对于竞技体育的不尊重。在Gal中寻求太多的真实感是不是搞错了什么（笑），毕竟Gal由于篇幅的限制，苍彼已经做到了极限，我们也可以期待一下今年美咲的FD能不能如约而至了。</p><p><imgsrc="https://raw.githubusercontent.com/JamesYuuu/Picbed/main/20210816134022_1.jpg" /></p>]]></content>
      
      
      <categories>
          
          <category> Game </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GalGame </tag>
            
            <tag> Sprite </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>苍之彼方的四重奏Extra1：真白的后宫(X)成长物语</title>
      <link href="/GalGame%E6%84%9F%E6%83%B3/%E8%8B%8D%E4%B9%8B%E5%BD%BC%E6%96%B9%E7%9A%84%E5%9B%9B%E9%87%8D%E5%A5%8FExtra1%EF%BC%9A%E7%9C%9F%E7%99%BD%E7%9A%84%E5%90%8E%E5%AE%AB(X)%E6%88%90%E9%95%BF%E7%89%A9%E8%AF%AD/"/>
      <url>/GalGame%E6%84%9F%E6%83%B3/%E8%8B%8D%E4%B9%8B%E5%BD%BC%E6%96%B9%E7%9A%84%E5%9B%9B%E9%87%8D%E5%A5%8FExtra1%EF%BC%9A%E7%9C%9F%E7%99%BD%E7%9A%84%E5%90%8E%E5%AE%AB(X)%E6%88%90%E9%95%BF%E7%89%A9%E8%AF%AD/</url>
      
        <content type="html"><![CDATA[<p>苍之彼方的四重奏Extra1是由著名冷饭厂雪碧社Sprite发行的以真白为女主角的后宫Galgame，玩家扮演的真白在本作中不但有晶也线，还有美咲线、明日香线、莉佳线等多条百合线，分别截图如下，各位玩家预购从速吧！！（上述都是一本正经的胡说八道）</p><p><imgsrc="https://raw.githubusercontent.com/JamesYuuu/Picbed/main/1340130_20210819163631_1.png" /></p><p><span id="more"></span></p><blockquote><p>无剧透简介：所仰慕的非常喜欢的前辈和能够坦诚内心烦恼，一起努力的志同道合的朋友们，这样靠着鼓起的勇气以及抓住不放的诸多重要的东西，历尽千辛万苦，终于达成了的HappyEnd！！……这意念一闪而过。学习还是一团糟，与莉佳和有梨华的甜点对决也完败，美咲和明日香宣称是“晶也的恋人”!?如此下去的话，前辈会被夺走，自己也会留级，真白乌冬面也会倒闭!就在这时，母亲却突然做出了晶也和真白的一晚约会决定。「做个好吃的便当！再好好打扮一番！」真白如是对晶也宣布。借助大家一臂之力，在约会日期到来之前，为了弥补女性魅力不足的问题而展开突击特训！！到底，晶也和真白是否真的能够迎来HappyEnd呢？</p></blockquote><figure><imgsrc="https://raw.githubusercontent.com/JamesYuuu/Picbed/main/1340130_20210819163601_1.png"alt="真白—晶也" /><figcaption aria-hidden="true">真白—晶也</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/JamesYuuu/Picbed/main/1340130_20210817143732_1.png"alt="真白—莉佳" /><figcaption aria-hidden="true">真白—莉佳</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/JamesYuuu/Picbed/main/1340130_20210819163533_1.png"alt="真白-明日香" /><figcaption aria-hidden="true">真白-明日香</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/JamesYuuu/Picbed/main/1340130_20210819164849_1.png"alt="真白-美咲" /><figcaption aria-hidden="true">真白-美咲</figcaption></figure><h1 id="真白成长的咏叹调">真白成长的咏叹调</h1><p>在苍彼正篇中的真白，更多的是作为美咲的附属品出现，无论做什么事情都和美咲相同，没有自己的主见，就像是一只永远紧盯着主人不放的小猫一般。而本作则完全成为了真白的主场，她开始正视和美咲的感情。作为一部不到4个小时的短篇作品，在剧情上也非常简单直接，通篇围绕真白和晶也的约会展开，大部分的剧情着笔于约会前的准备工作——准备期中考试，练习做便当的厨艺，挑选约会的衣服等等。最后通过约会讲故事推向高潮，为故事画上一个圆满的句号。</p><p><imgsrc="https://raw.githubusercontent.com/JamesYuuu/Picbed/main/1340130_20210819163446_1.png" />真白从原先胆小内向的性格，到现在的逐渐开朗，交上了不少的朋友；由原先美咲身后的小跟班，到现在拯救了美咲的FC生涯，鼓励了晶也复出以及不断的努力。这一切正是借游戏机与晶也结缘和在空竞中的不断努力所带来的，编剧巧妙地在结尾以回忆的形式，将两人的羁绊、两人的互相拯救，一幕一幕的呈现，增加了与前作的关联，也让人有发自心底的感动。</p><p>另外，作为真白内心另一面的小邪神，也在本作中起到了重要的作用，本是用于更加有趣的展现内心活动、活跃气氛，但编剧同样巧妙的将其作为象征，在结尾处安排了真白与邪神的告别，也标志着真白的成长与内心的独立可谓一举两得。最后作为高潮的约会，得益于精彩的演出效果和适当的配乐，糖分同样超标，在此就闲话少叙了，就用几张精彩的CG来管中窥豹。</p><p><imgsrc="https://raw.githubusercontent.com/JamesYuuu/Picbed/main/1340130_20210819163613_1.png" /></p><p><imgsrc="https://raw.githubusercontent.com/JamesYuuu/Picbed/main/1340130_20210819163620_1.png" /></p><h1 id="配角的成功塑造">配角的成功塑造</h1><p>雪碧社除了对于主角的精彩塑造外，对于配角的形象同样也是有所完善。并非在他人的FD中，配角就一定要沦为工具人，有血有肉的配角更能够丰满整个世界观，让故事能够完善，更加真实。本作中，便丰满了美咲的形象，将两者先前的羁绊娓娓道来，将美咲外冷内热的性格展现的淋漓尽致。看似对于真白爱答不理的背后，藏着美咲对于真白默默的复出。例如，美咲其实并不喜欢吃乌冬面，甚至因为小时候吃乌冬面噎着了，甚至有些讨厌乌冬面，但她为了不辜负真白的美意，仍然装着自己很喜欢乌冬面的样子，维护着与真白的友谊，守护着真白的成长，并用若即若离的方式促进着真白独立。</p><p><imgsrc="https://raw.githubusercontent.com/JamesYuuu/Picbed/main/1340130_20210819165049_1.png"alt="虎鱼" />当然还有本篇中戏份很少的莉佳与虎鱼，分别作为真白的“速度型伴侣”和青梅竹马以各自的方式守护者真白，尽自己的全力帮着真白努力应对约会，努力做好便当，努力学好空竞。虎鱼刀子嘴豆腐心的性格与莉佳人妻的属性，都能够在这里得到丰满，而不是单纯的作为推动剧情的工具人出现，让这个架空的世界多了一份温情，也让玩家有身临其境之感。</p><figure><imgsrc="https://raw.githubusercontent.com/JamesYuuu/Picbed/main/1340130_20210819163552_1.png"alt="莉佳" /><figcaption aria-hidden="true">莉佳</figcaption></figure><h1 id="出色的音画表现">出色的音画表现</h1><p>先不说2K分辨率的原画CG算得上是gal中佼佼者了，除了出彩的原画和演出外，配乐也是本作的一大亮点。延续了ElementsGarden稳定的发挥，特别是其中的几首钢琴曲，舒缓悠扬，令人沉浸其中。另外应援团们的表现，恰如其分的吐槽，也使得本作更加有趣，更有了恋爱喜剧的风格，又有谁不喜欢HappyEnd呢？</p><p><imgsrc="https://raw.githubusercontent.com/JamesYuuu/Picbed/main/1340130_20210819165134_1.png" /></p><h1 id="结语">结语</h1><p>少了FC元素的Extra1就已经这样精彩了，谁有能不期待有着大量FC的元素的Extra2呢？雪碧社的最新消息是已经画完了一百多张的CG了，也设计了新的FC战斗场景，就期待一下真正的龙傲天晶也，能否为我们带来精彩的FC表演。最后插播一个最近苍彼六周年的官方投票，美咲居然反杀了真白成为了第一，雪碧社得快马加鞭继续炒冷饭了哟！之前看到吧友说雪碧的官方已经将明日香的Extra3纳入了考虑，并且大部分是恋人的发糖哦，希望能弥补正作中的糖分不足。</p><p><imgsrc="https://raw.githubusercontent.com/JamesYuuu/Picbed/main/1340130_20210819165846_1.png" /></p><p><imgsrc="https://raw.githubusercontent.com/JamesYuuu/Picbed/main/1340130_20210819165808_1.png" /></p>]]></content>
      
      
      <categories>
          
          <category> Game </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GalGame </tag>
            
            <tag> Sprite </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
