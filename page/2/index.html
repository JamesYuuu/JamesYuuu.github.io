<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">
<link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="baidu-site-verification" content="PTwOehQpzZ">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.4.2/css/all.min.css" integrity="sha256-CTSx/A06dm1B063156EVh15m6Y67pAjZZaQc89LLSrU=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"blog.jamesyuuu.me","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.18.2","exturl":true,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"default"},"fold":{"enable":false,"height":500},"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":true,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="A Game and Bangumi Database For Private Use">
<meta property="og:type" content="website">
<meta property="og:title" content="JamesYu&#39;s Hut">
<meta property="og:url" content="https://blog.jamesyuuu.me/page/2/index.html">
<meta property="og:site_name" content="JamesYu&#39;s Hut">
<meta property="og:description" content="A Game and Bangumi Database For Private Use">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="JamesYu">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://blog.jamesyuuu.me/page/2/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/2/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>JamesYu's Hut - Game | Bangumi</title>
  







<link rel="stylesheet" href="//cdn.jsdelivr.net/gh/theme-next/theme-next-needmoreshare2@1/needsharebutton.min.css"><style>
#needsharebutton-postbottom {
  cursor: pointer;
  height: 26px;
  margin-top: 10px;
  position: relative;
}
#needsharebutton-postbottom .btn {
  border: 1px solid $btn-default-border-color;
  border-radius: 3px;
  display: initial;
  padding: 1px 4px;
}
</style>
  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css">
<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">JamesYu's Hut</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Game | Bangumi</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">7</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">3</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">36</span></a></li><li class="menu-item menu-item-观影"><a href="/movies/index.html" rel="section"><i class="fa fa-film fa-fw"></i>观影</a></li><li class="menu-item menu-item-追番"><a href="/bangumis/index.html" rel="section"><i class="fa fa-video-camera fa-fw"></i>追番</a></li><li class="menu-item menu-item-追剧"><a href="/cinemas/index.html" rel="section"><i class="fa fa-television fa-fw"></i>追剧</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="JamesYu"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">JamesYu</p>
  <div class="site-description" itemprop="description">A Game and Bangumi Database For Private Use</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">36</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0phbWVzWXV1dQ==" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;JamesYuuu"><i class="fab fa-github fa-fw"></i>GitHub</span>
      </span>
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9pbnN0YWdyYW0uY29tL2phbWVzeXUzMg==" title="Instagram → https:&#x2F;&#x2F;instagram.com&#x2F;jamesyu32"><i class="fab fa-instagram fa-fw"></i>Instagram</span>
      </span>
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9zcGFjZS5iaWxpYmlsaS5jb20vMTgyODA5NTQ5" title="Bilibili → https:&#x2F;&#x2F;space.bilibili.com&#x2F;182809549"><i class="fab fa-bilibili fa-fw"></i>Bilibili</span>
      </span>
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS95aWdlLWRhLXNodWFpLWJpLTQw" title="Zhihu → https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;yige-da-shuai-bi-40"><i class="fab fa-zhihu fa-fw"></i>Zhihu</span>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <span class="exturl cc-opacity" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><img src="https://cdn.jsdelivr.net/npm/@creativecommons/vocabulary@2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <span class="exturl github-corner" data-url="aHR0cHM6Ly9naXRodWIuY29tL0phbWVzWXV1dQ==" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></span>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://blog.jamesyuuu.me/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="JamesYu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JamesYu's Hut">
      <meta itemprop="description" content="A Game and Bangumi Database For Private Use">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | JamesYu's Hut">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/" class="post-title-link" itemprop="url">计算机网络体系结构</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-10-26 14:17:00" itemprop="dateCreated datePublished" datetime="2023-10-26T14:17:00+08:00">2023-10-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-11-01 20:48:22" itemprop="dateModified" datetime="2025-11-01T20:48:22+08:00">2025-11-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Study/" itemprop="url" rel="index"><span itemprop="name">Study</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>505</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="计算机网络体系结构">计算机网络体系结构</h1>
<h2 id="分层的网络体系结构">分层的网络体系结构</h2>
<h3 id="分层的优点">分层的优点</h3>
<ul>
<li>各层互相独立
<ul>
<li>将建造一个网络的问题分解为多个可处理的部分，一层解决一部分问题</li>
</ul></li>
<li>灵活性好
<ul>
<li>任何层发生变化时，只要接口不变，上下层都不受影响</li>
</ul></li>
<li>结构上可分割开
<ul>
<li>各层都可以采用最合适的技术实现</li>
</ul></li>
<li>易于实现和维护</li>
<li>能促进标准化工作</li>
</ul>
<h3 id="理论模型osi参考模型">理论模型（OSI参考模型）</h3>
<ul>
<li>20世纪70年代国际标准化组织(ISO)制定</li>
<li>按网络功能划分为7层</li>
</ul>
<figure>
<img
src="https://raw.githubusercontent.com/JamesYuuu/Picbed/main/image-20231026144506042.png"
alt="image-20231026144506042" />
<figcaption aria-hidden="true">image-20231026144506042</figcaption>
</figure>
<h3 id="实际架构tcpip-体系架构">实际架构（TCP/IP 体系架构）</h3>
<ul>
<li>ARPANET发展而来，有TCP和IP两个核心的协议</li>
<li>四层，但不严格的划分层，这样应用可以跨层使用网络</li>
</ul>
<p><img src="https://raw.githubusercontent.com/JamesYuuu/Picbed/main/image-20231026144827300.png" alt="image-20231026144827300" style="zoom: 67%;" /></p>
<ul>
<li>细腰结构是网络体系结构模型中最典型的特征
<ul>
<li>IP 可应用在各式各样的网络上</li>
<li>各式各样的应用可以承载在IP 之上</li>
</ul></li>
<li>分层模型中的相关概念
<ul>
<li>实体：任何可以发送或接受信息的硬件或软件进程</li>
<li>对等实体：位于不同系统中的同一层内相互交互的实体</li>
<li>网络协议：为进行网络中的数据交换建立的规则、标准或约定，控制两个对等实体进行通信的规则的集合</li>
<li>服务：由下层向上层通过层间接口提供</li>
<li>服务接口：同一系统内相邻两层的实体进行交互的地方，成为服务访问点（SAP）
<img
src="https://raw.githubusercontent.com/JamesYuuu/Picbed/main/image-20231026145800273.png"
alt="image-20231026145800273" /></li>
<li>数据传输通道
<ul>
<li>数据发送都是由上层传到下层，接收则由下层传到上层</li>
<li>层间是虚通信，最下层是实际通信</li>
</ul></li>
<li>多路复用/多路分解
<ul>
<li>发送端多个高层会话复用一条底层连接，在接收端再进行分解</li>
<li>逐层进行封装和解封</li>
</ul></li>
</ul></li>
</ul>
<figure>
<img
src="https://raw.githubusercontent.com/JamesYuuu/Picbed/main/image-20231026150432168.png"
alt="image-20231026150432168" />
<figcaption aria-hidden="true">image-20231026150432168</figcaption>
</figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://blog.jamesyuuu.me/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E6%80%A7%E8%83%BD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="JamesYu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JamesYu's Hut">
      <meta itemprop="description" content="A Game and Bangumi Database For Private Use">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | JamesYu's Hut">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E6%80%A7%E8%83%BD/" class="post-title-link" itemprop="url">计算机网络的性能</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-10-22 17:22:00" itemprop="dateCreated datePublished" datetime="2023-10-22T17:22:00+08:00">2023-10-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-11-01 20:48:22" itemprop="dateModified" datetime="2025-11-01T20:48:22+08:00">2025-11-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Study/" itemprop="url" rel="index"><span itemprop="name">Study</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>616</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="计算机网络的性能">计算机网络的性能</h1>
<h2 id="速率比特率">速率/比特率</h2>
<ul>
<li>比特是计算机中数据量的单位
<ul>
<li>1bit即1个二进制数字（0或1）</li>
</ul></li>
<li>网络技术中的数据率即数字信道上的传送数据的速率</li>
<li>单位（b/s）</li>
</ul>
<h2 id="带宽">带宽</h2>
<ul>
<li>计算机网络中，带宽即数字信道所能传送到的最高数据率</li>
<li>网络的带宽：在一段特定的时间内网络所能传送的比特数
<ul>
<li>以特定带宽传送的比特可以看作有一定的宽度</li>
</ul></li>
</ul>
<h2 id="吞吐量">吞吐量</h2>
<ul>
<li><p>吞吐量即单位时间内通过某个网络（或信道、接口）的数据量</p></li>
<li><p>带宽和吞吐量</p>
<ul>
<li>带宽一般指链路上每秒能传输的比特数</li>
<li>吞吐量表示系统的测量性能，即每秒实际传输的比特</li>
</ul></li>
<li><p>计算：Throughput = Transfer_size / Transfer_time</p>
<ul>
<li>Transfer_time = RTT + (1/Bandwidth) * Transfer_size
<ul>
<li>发请求并返回数据的时间 RTT</li>
<li>把数据传到网上的时间</li>
</ul></li>
<li>传输更大量的数据有助于提高吞吐量
<ul>
<li>当数据量趋于无限大时，吞吐量将接近网络带宽 ## 时延/延迟</li>
</ul></li>
</ul></li>
<li><p>时延：数据从网络的一端传送到另一端所花费的时间</p></li>
<li><p>往返时间（RTT）：数据从网络的一端传到另一端并返回所花费的时间</p></li>
<li><p>时延由四部分组成</p>
<ul>
<li>发送时延：发送数据时，数据块从结点进入到传输介质所需要的时间
<ul>
<li>发送时延 = 数据块长度 / 发送速率</li>
</ul></li>
<li>传播时延：电磁波在信道中需要传播一定的距离而花费的时间
<ul>
<li>不同介质的信道中传播的速度不同（光纤 <span
class="math inline">\(2\times10^8m/s\)</span>，电缆<span
class="math inline">\(2.3\times10^8m/s\)</span></li>
<li>传播时延 = 信道长度 / 信号在信道上的传播速率</li>
</ul></li>
<li>处理时延：主机或路由器在收到分组时进行一些必要的处理所花费的时间
<ul>
<li>比如分析分组首部、差错检验、查找路由</li>
</ul></li>
<li>排队时延：结点在队列中等待产生的时延</li>
</ul></li>
<li><p>注意：</p>
<ul>
<li><p>我们能提高的是数据的发送速率，而不是数据在链路中传输的速率</p></li>
<li><p>提高链路带宽可以降低数据的发送时延</p></li>
</ul></li>
</ul>
<h2 id="时延带宽积">时延带宽积</h2>
<ul>
<li>时延带宽积 = 时延 * 带宽，即以比特为单位的链路长度</li>
<li>代表了第一个比特到达终点时，发送端发出的尚未达到接收端的比特数</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://blog.jamesyuuu.me/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Internet%E7%9A%84%E7%BB%84%E6%88%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="JamesYu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JamesYu's Hut">
      <meta itemprop="description" content="A Game and Bangumi Database For Private Use">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | JamesYu's Hut">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Internet%E7%9A%84%E7%BB%84%E6%88%90/" class="post-title-link" itemprop="url">Internet的组成</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-10-22 16:58:00" itemprop="dateCreated datePublished" datetime="2023-10-22T16:58:00+08:00">2023-10-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-11-01 20:48:22" itemprop="dateModified" datetime="2025-11-01T20:48:22+08:00">2025-11-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Study/" itemprop="url" rel="index"><span itemprop="name">Study</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>553</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="internet的组成">Internet的组成</h1>
<h2 id="端系统">端系统</h2>
<h3 id="端系统的概念">端系统的概念</h3>
<ul>
<li>连接在因特网上的所有主机，运行应用程序</li>
<li>主机之间的通信，即主机A的某个进程（运行着的程序）和主机B上的另一个进程进行通信</li>
</ul>
<h3 id="端系统间的通信方式">端系统间的通信方式</h3>
<ul>
<li>客户-服务器方式（Client/Server）
<ul>
<li>基本概念
<ul>
<li>描述的是进程之间服务和被服务的关系</li>
<li>客户和服务器指通信中涉及的两个应用进程</li>
<li>客户是服务的请求方，服务器是服务的提供方</li>
</ul></li>
<li>客户端
<ul>
<li>被用户调用后运行，打算通信时主动向远地服务器发起通信（请求服务），必须知道服务器程序的地址</li>
<li>不需要特殊的硬件和复杂的操作系统</li>
</ul></li>
<li>客户端
<ul>
<li>专门用来提供某种服务的程序，可同时处理多个远地或本地客户的请求</li>
<li>系统启动后即自动调用并一直不断地运行着，被动地等待并接受来自各地的客户的通信请求，不需要知道客户程序的地址</li>
<li>一般需要强大的硬件和高级的操作系统支持</li>
</ul></li>
</ul></li>
<li>对等方式（P2P，Peer-to-Peer）
<ul>
<li>两个主机通信时，不区分服务请求方，还是服务提供方，进行平等和对等的连接通信</li>
<li>本质上仍然是使用客户服务器方式，只是对等连接中的每一个主机既是服务器又是客户</li>
</ul></li>
</ul>
<h2 id="接入网">接入网</h2>
<ul>
<li>将端系统连接到边缘路由器的物理链路
<ul>
<li>边缘路由器是端系统到任何其它远程系统的路径上的第一台路由器</li>
</ul></li>
<li>使用接入网的集中环境
<ul>
<li>家庭接入
<ul>
<li>数字用户线（基于电话线路）</li>
<li>电缆</li>
<li>光纤到户（FTTH）</li>
<li>拨号</li>
<li>卫星</li>
</ul></li>
<li>企业接入
<ul>
<li>局域网 LAN 接入</li>
<li>无线局域网接入</li>
</ul></li>
<li>广域无线网络接入（4G/5G）</li>
</ul></li>
</ul>
<h2 id="网络核心">网络核心</h2>
<ul>
<li>Internet网络核心组成
<ul>
<li>十多个第一层ISP和数十万个较低层ISP组成</li>
<li>内容提供商也创建自己的网络，直接在可能的地方与ISP互联</li>
</ul></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://blog.jamesyuuu.me/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E8%B5%B7%E6%BA%90%E5%92%8C%E5%8F%91%E5%B1%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="JamesYu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JamesYu's Hut">
      <meta itemprop="description" content="A Game and Bangumi Database For Private Use">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | JamesYu's Hut">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E8%B5%B7%E6%BA%90%E5%92%8C%E5%8F%91%E5%B1%95/" class="post-title-link" itemprop="url">计算机网络的起源与发展</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-10-22 14:52:00" itemprop="dateCreated datePublished" datetime="2023-10-22T14:52:00+08:00">2023-10-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-11-01 20:48:22" itemprop="dateModified" datetime="2025-11-01T20:48:22+08:00">2025-11-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Study/" itemprop="url" rel="index"><span itemprop="name">Study</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>983</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>4 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="计算机网络的起源与发展">计算机网络的起源与发展</h1>
<h2 id="电路交换">电路交换</h2>
<blockquote>
<p>传统的电路交换的电信网生存性和容错性弱</p>
</blockquote>
<h3 id="电路交换的特点">电路交换的特点</h3>
<ul>
<li><p>面向连接</p></li>
<li><p>必须经过以下三个步骤</p>
<ul>
<li>建立连接（占用通信资源）</li>
<li>通话（始终占用通信资源）</li>
<li>释放连接（归还通信资源）</li>
</ul></li>
</ul>
<h3 id="电路交换的缺点">电路交换的缺点</h3>
<ul>
<li>电路交换方式传送计算机数据效率低
<ul>
<li>计算机数据具有突发性
<ul>
<li>传送数据的时间不到10%，甚至低于1%</li>
</ul></li>
<li>面向连接的方式进行传输导致资源浪费
<ul>
<li>被占用的通信线路绝大部分时间都是空闲的</li>
</ul></li>
</ul></li>
</ul>
<h2 id="分组交换">分组交换</h2>
<h3 id="分组交换的原理">分组交换的原理</h3>
<ul>
<li>发送端
<ul>
<li>把较长的报文划分成较短的、固定长度的数据段</li>
<li>每一个数据段前面添加上<strong>首部</strong>构成<strong>分组</strong>
<ul>
<li>分组是互联网中传送的数据单元</li>
<li>每个首部都包含地址等控制信息</li>
</ul></li>
<li>以此把各分组发送出去</li>
</ul></li>
<li>中间节点：通过存储转发的形式将分组逐跳转发至目的地
<ul>
<li>中间结点即分组交换网中的分组交换机
<ul>
<li>专门负责转发分组的计算机（路由器、二层交换机等）</li>
</ul></li>
<li>每个分组交换机根据收到的分组的首部中的地址信息，把分组转发到下一个交换机
<ul>
<li>以存储转发的方式</li>
</ul></li>
<li>一个分组经历的一系列分组交换机和通信链路称为通过该网络的路径</li>
</ul></li>
<li>接收端
<ul>
<li>收到分组之后剥去分组的首部，把数据恢复成为原来的报文</li>
</ul></li>
</ul>
<h3 id="分组交换的优点">分组交换的优点</h3>
<ul>
<li>高效
<ul>
<li>动态分配传输带宽，对通信链路逐段占用，充分使用链路的带宽</li>
</ul></li>
<li>灵活
<ul>
<li>以分组为单位，查找路由和传送</li>
</ul></li>
<li>迅速
<ul>
<li>不必先建立连接就能向其他主机发送分组</li>
</ul></li>
<li>可靠
<ul>
<li>自适应的路由选择，使网络有很好的生存性</li>
</ul></li>
</ul>
<h3 id="分组交换的缺点">分组交换的缺点</h3>
<ul>
<li>时延
<ul>
<li>处理时延：逐跳决策，每个中间结点都需要进行路由查找</li>
<li>排队时延：分组在各结点存储转发时需要排队</li>
</ul></li>
<li>附加开销
<ul>
<li>分组必须携带报头（首部），造成一定开销</li>
</ul></li>
</ul>
<h2 id="交换技术的比较">交换技术的比较</h2>
<h3 id="电路交换-1">电路交换</h3>
<ul>
<li>面向连接，报文的比特流连续地从源到终点，像在一个管道中传输</li>
</ul>
<h3 id="报文交换">报文交换</h3>
<ul>
<li>在电报通信是采用，同样是基于存储转发原理</li>
<li>整个报文先传送到相邻节点，全部存储下来后查找转发表，转发到下一个结点</li>
</ul>
<h3 id="分组交换-1">分组交换</h3>
<ul>
<li>单个分组（整个报文的一部分）传送到相邻结点，存储下来后查找转发表，转发到下一结点</li>
</ul>
<figure>
<img
src="https://raw.githubusercontent.com/JamesYuuu/Picbed/main/image-20231022162120896.png"
alt="image-20231022162120896" />
<figcaption aria-hidden="true">image-20231022162120896</figcaption>
</figure>
<h2 id="互联网概述">互联网概述</h2>
<h3 id="基本概念">基本概念</h3>
<ul>
<li>链路
<ul>
<li>物理直连介质：同轴电缆、双绞线、光纤、无线电频谱等</li>
<li>网络连通有不同的层次，最底层的是一个或多个计算机通过物理介质直连</li>
</ul></li>
<li>结点
<ul>
<li>被连接的计算机/其他硬件
<ul>
<li>主机（端系统）：PC、服务器、智能手机、智能家电、传感器等</li>
<li>网络内部交换结点：交换机、AP、基站、路由器等</li>
</ul></li>
</ul></li>
<li>云形图
<ul>
<li>计算机网络中重要的图标，表示任意类型的网络</li>
<li>将网络的内部结点与使用网络的外部结点分开</li>
</ul></li>
<li>直连链路
<ul>
<li>所有的结点都是直连的</li>
</ul></li>
<li>交换网络
<ul>
<li>若干结点和链路组成，主机间接连通</li>
<li>主机：支持用户运行应用程序</li>
<li>交换结点：存储和转发分组</li>
</ul></li>
<li>互联网
<ul>
<li>网络的网络，路由器将网络和网络互连</li>
<li>网络可以由网络的嵌套组成
<ul>
<li>通过将云互联成更大的云，递归构建任意大的网络</li>
</ul></li>
</ul></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://blog.jamesyuuu.me/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/WAFL%E4%B8%8E%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="JamesYu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JamesYu's Hut">
      <meta itemprop="description" content="A Game and Bangumi Database For Private Use">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | JamesYu's Hut">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/WAFL%E4%B8%8E%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8/" class="post-title-link" itemprop="url">WAFL与系统安全</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-12-26 22:54:00" itemprop="dateCreated datePublished" datetime="2022-12-26T22:54:00+08:00">2022-12-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-11-01 20:48:22" itemprop="dateModified" datetime="2025-11-01T20:48:22+08:00">2025-11-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Study/" itemprop="url" rel="index"><span itemprop="name">Study</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.1k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>8 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="wafl-netapp的文件服务器">WAFL —— NetApp的文件服务器</h1>
<blockquote>
<p>WAFL：Write Anywhere File Layout —— NetApp 设计的企业级文件系统</p>
</blockquote>
<ol type="1">
<li>设计目标
<ul>
<li>请求服务速度快：吞吐率(op/s)更多，I/O带宽更高</li>
<li>支持大文件系统，且文件系统不断增长</li>
<li>高性能软件RAID</li>
<li>宕机后快速恢复</li>
</ul></li>
<li>独特之处
<ul>
<li>磁盘布局受 LFS 启发</li>
<li>引入快照</li>
<li>使用 NVRAM 记录日志（写前日志）</li>
</ul></li>
</ol>
<h2 id="inode间址块和数据块">inode、间址块和数据块</h2>
<ol type="1">
<li>WAFL 使用4KB块
<ul>
<li>inode：借鉴 UNIX FS</li>
<li>16个指针（64B）用于文件块索引</li>
</ul></li>
<li>文件大小 &lt;= 64B
<ul>
<li>文件数据直接存储在 inode中</li>
</ul></li>
<li>文件大小 &lt;= 64KB
<ul>
<li>inode存储在16个指向数据块的指针</li>
</ul></li>
<li>文件大小 &lt;= 64MB
<ul>
<li>inode存储在16个指向间址块的指针</li>
<li>每个间址块存储1024个指向数据块的指针</li>
</ul></li>
<li>文件大小 &gt; 64MB
<ul>
<li>inode存储在16个指向二级间址块的指针</li>
</ul></li>
</ol>
<h2 id="wafl的磁盘布局">WAFL的磁盘布局</h2>
<ol type="1">
<li>主要数据结构
<ul>
<li>一个根 inode：整个FS的根，位于磁盘上固定位置</li>
<li>一个inode file：包含所有inode</li>
<li>一个block map file：指示所有空闲块</li>
<li>一个i-node map file：指示所有空闲inode</li>
</ul></li>
</ol>
<h3 id="为什么将元数据存储于文件中">为什么将元数据存储于文件中？</h3>
<ol type="1">
<li>元数据块可以写在磁盘上任何位置
<ul>
<li>这是"WAFL"名字的由来，Write Anywhere File Layout</li>
</ul></li>
<li>使得动态增加文件系统的大小变得容易
<ul>
<li>增加一个磁盘会引发inode个数的增加</li>
<li>inode保存在文件，扩展inode文件大小即可</li>
</ul></li>
<li>能够通过 Copy-on-Write 来创建快照
<ul>
<li>COW：未写前共享数据，写时拷贝</li>
<li>新的数据和元数据都可以COW写到磁盘上的新位置</li>
<li>固定元数据位置无法使用COW，否则无法定位元数据</li>
</ul></li>
</ol>
<h2 id="快照snapshot">快照（snapshot）</h2>
<ol type="1">
<li>快照是文件系统的一个只读版本 – 1993 年提出
<ul>
<li>成为文件服务器必备特性</li>
</ul></li>
<li>快照用法
<ul>
<li>系统管理员配置快照的个数和频率</li>
<li>最初系统能支持 20 个快照</li>
<li>用快照可以恢复其中任何一个文件</li>
</ul></li>
</ol>
<h3 id="快照的实现">快照的实现</h3>
<blockquote>
<p>WAFL：所有的块构成一棵树</p>
</blockquote>
<ol type="1">
<li>创建快照
<ul>
<li>复制根 inode</li>
<li>新的根 inode 用于当前的 Active FS</li>
<li>旧的根 inode 指向快照</li>
</ul></li>
<li>创建快照之后
<ul>
<li>第一次写一个块: 把从它到根的数据块都复制（COW）</li>
<li>Active FS 的根 inode 指向新数据块</li>
<li>写数据块</li>
<li>后续对这些数据块的写不再触发 COW</li>
</ul></li>
<li>每个快照都是一个一致状态的只读 FS</li>
</ol>
<h3 id="快照数据结构">快照数据结构</h3>
<blockquote>
<p>Block Map File —— 每个 4KB 磁盘块对应一个 32位的表项</p>
</blockquote>
<ol type="1">
<li>表项值为0：该块为空闲块</li>
<li>第0位=1：该块属于活动文件系统</li>
<li>第1位=1：该块属于第一个快照</li>
<li>第2位=1：该块属于第二个快照</li>
</ol>
<p>...</p>
<h3 id="快照创建">快照创建</h3>
<ol type="1">
<li>问题
<ul>
<li>创建快照时，除了拷贝根inode，需要把缓存的文件块写回磁盘</li>
<li>此时，可能仍然有很多文件写请求到来</li>
<li>若这些写请求都不处理，会导致文件系统长时间挂起</li>
</ul></li>
<li>WAFL的解决方案
<ul>
<li>在创建快照前，将块缓存中的脏块标记为"in-snapshot"，表示要写回磁盘</li>
<li>所有对"in-snapshot"缓存块的修改请求被挂起</li>
<li>没有标记为"in-snapshot"的缓存数据可以修改（即处理写请求），但不能写回磁盘</li>
<li>本质：区分需要被写回的脏块和其他块，减少挂起的写请求数量</li>
<li>步骤
<ul>
<li>为所有"in-snapshot"的缓存块分配磁盘空间
<ul>
<li>包括数据、inode</li>
</ul></li>
<li>更新 block map file
<ul>
<li>对每个表项，将 Active FS位的值（即1）拷贝到新快照位</li>
</ul></li>
<li>刷回
<ul>
<li>把所有的"in-snapshot"缓存块写到它们新的磁盘位置</li>
<li>每写回一个块，重启它上面被挂起文件请求</li>
</ul></li>
<li>复制根inode</li>
</ul></li>
<li>性能较快</li>
</ul></li>
</ol>
<h3 id="快照删除">快照删除</h3>
<ol type="1">
<li>删除快照的根inode</li>
<li>清除block map file中的位
<ul>
<li>对于block map file的每一个表项，清除与该快照对应的位</li>
</ul></li>
</ol>
<h2 id="文件系统一致性">文件系统一致性</h2>
<ol type="1">
<li>定期创建一致点
<ul>
<li>一致点：存储控制器中使用 NVRAM
缓存的数据被刷回磁盘，并更新了文件系统中相应的指针</li>
<li>每10秒创建一个一致点</li>
<li>特殊的内部快照，用户不可见</li>
</ul></li>
<li>在一致点之间的多个请求
<ul>
<li>第i个一致点</li>
<li>若干写操作</li>
<li>第 i+1 个一致点（自动增长）</li>
<li>若干写操作</li>
<li>...</li>
</ul></li>
<li>宕机恢复
<ul>
<li>将文件系统恢复到最后一个一致点</li>
<li>最后一个一致点之后到宕机前的写操作：靠日志进行恢复</li>
</ul></li>
</ol>
<h2 id="非易失ramnon-volatile-ram">非易失RAM（Non-Volatile RAM）</h2>
<ol type="1">
<li>NVRAM
<ul>
<li>闪存：写比较慢 vs NVRAM</li>
<li>带电池的 DRAM：快
<ul>
<li>电池容量有限，持续时间不长</li>
<li>DRAM容量有限</li>
</ul></li>
</ul></li>
<li>日志写入 NVRAM
<ul>
<li>记录自上一个一致点以来的所有写请求</li>
<li>正常关机：先停止 NFS 服务，再创建一个快照，然后关闭 NVRAM</li>
<li>宕机恢复：用 NVRAM 中的日志来恢复从最后一个一致点以后的修改</li>
</ul></li>
<li>使用两个日志
<ul>
<li>一个日志写回磁盘时，另一个日志写入 NVRAM 中缓冲</li>
<li>可以避免写日志时，无法处理新的写请求</li>
</ul></li>
</ol>
<h1 id="安全保护">安全保护</h1>
<h2 id="安全与保护">安全与保护</h2>
<ol type="1">
<li>数据机密性：未经许可，不能看到数据
<ul>
<li>任何用户不能读写其他用户的文件</li>
</ul></li>
<li>数据完整性：未经许可，不能修改或删除数据
<ul>
<li>数据在网络传输过程中被拦截和修改，可以采用加密</li>
</ul></li>
<li>系统可用性：干扰系统使得它不可用
<ul>
<li>给一个服务器发送大量的请求</li>
</ul></li>
</ol>
<h2 id="保护策略与机制">保护：策略与机制</h2>
<ol type="1">
<li>安全策略：定义目标，即要达到的效果
<ul>
<li>通常是一组规则，定义可接受的行为和不可接受的行为</li>
<li>例子
<ul>
<li>/etc/password 文件只有 root 能写</li>
<li>每个用户最多只能用 50GB 的磁盘空间</li>
<li>任何用户都不允许读其他用户的 mail 文件</li>
</ul></li>
</ul></li>
<li>机制：用什么样的方法来达到目标</li>
</ol>
<h2 id="保护机制">保护机制</h2>
<ol type="1">
<li>Authentication（身份认证）
<ul>
<li>验明身份
<ul>
<li>UNIX：密码/口令</li>
<li>类比机场：身份证或护照</li>
</ul></li>
</ul></li>
<li>Authorization（授权）
<ul>
<li>决定"A是不是准许做某件事"</li>
<li>通常使用角色（role）定义授予的操作权限，使用简单的数据库保存角色定义</li>
</ul></li>
<li>Admission Control（访问控制）
<ul>
<li>做出“访问是否准许”的决定</li>
<li>有时和系统承载压力相关联，系统负载高时，进行访问控制</li>
</ul></li>
</ol>
<h3 id="身份认证">身份认证</h3>
<ol type="1">
<li>通常是用密码来验证
<ul>
<li>一串字符（字母 + 数字）</li>
<li>用户必须记住密码</li>
</ul></li>
<li>密码是以加密形式存储
<ul>
<li>使用一种单向的“安全Hash”算法</li>
</ul></li>
<li>缺点
<ul>
<li>每个用户都要记很多密码</li>
<li>弱密码风险，"dictionary attack"</li>
</ul></li>
</ol>
<h3 id="访问控制表acl">访问控制表（ACL）</h3>
<ol type="1">
<li>每个对象有一个 ACL 表
<ul>
<li>定义每个用户的权限</li>
<li>每个表项为 &lt;user,privilege&gt;</li>
</ul></li>
<li>简单，大多数系统都采用
<ul>
<li>UNIX 的 owner,group,other</li>
</ul></li>
<li>实现
<ul>
<li>ACL 实现在内核中</li>
<li>在登录系统时进行身份验证</li>
<li>ACL 存储在每个文件中或文件元数据中</li>
<li>打开文件时检查 ACL</li>
</ul></li>
</ol>
<h3 id="capabilities">Capabilities</h3>
<ol type="1">
<li>超级用户具有特权，可以执行高权限操作
<ul>
<li>例如passwd,chown,chmod等</li>
</ul></li>
<li>权能：将超级用户特权细分，分成不同的、细粒度权限
<ul>
<li>CAP_CHOWN: 对文件 UIDs 和 GIDs 做修改</li>
<li>CAP_KILL: 绕过发送信号时的权限检查</li>
<li>CAP_NET_ADMIN: 执行多种网络有关的操作</li>
</ul></li>
<li>可以为每个线程独立设置权能</li>
<li>实现
<ul>
<li>权能表保存在内核</li>
</ul></li>
</ol>
<h3 id="访问控制">访问控制</h3>
<ol type="1">
<li>需要一个可信权威
<ul>
<li>进行访问控制</li>
<li>ACL或权能表都需要保护</li>
</ul></li>
<li>内核是一个可信权威
<ul>
<li>内核什么事可以做</li>
<li>如果有 bug ，整个系统都可能被破坏</li>
<li>它越小、越简单越好</li>
</ul></li>
<li>安全的强度由保护系统链上最薄弱的环节决定</li>
</ol>
<h3 id="一些简单的攻击">一些简单的攻击</h3>
<ol type="1">
<li>滥用合法权利
<ul>
<li>UNIX: root能做任何事情
<ul>
<li>例如：读你的 mail 文件, 以你的身份发送email, 把你的邮箱删除,
...</li>
</ul></li>
</ul></li>
<li>拒绝服务（DoS）
<ul>
<li>耗尽系统所有资源</li>
<li>例如
<ul>
<li>运行一个 shell
脚本：<code>while (1) &#123;mkdir foo; cd foo;&#125;</code></li>
<li>运行一个 C
程序：<code>while (1) &#123;fork(); malloc(1000)[40]=1;&#125;</code></li>
</ul></li>
</ul></li>
<li>偷听
<ul>
<li>侦听网络上传输的包</li>
</ul></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://blog.jamesyuuu.me/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%8F%AF%E9%9D%A0%E6%80%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="JamesYu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JamesYu's Hut">
      <meta itemprop="description" content="A Game and Bangumi Database For Private Use">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | JamesYu's Hut">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%8F%AF%E9%9D%A0%E6%80%A7/" class="post-title-link" itemprop="url">文件系统可靠性</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-12-26 20:57:00" itemprop="dateCreated datePublished" datetime="2022-12-26T20:57:00+08:00">2022-12-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-11-01 20:48:22" itemprop="dateModified" datetime="2025-11-01T20:48:22+08:00">2025-11-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Study/" itemprop="url" rel="index"><span itemprop="name">Study</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>3.8k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>14 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="数据备份">数据备份</h1>
<ol type="1">
<li>FS要求
<ul>
<li>FS给用户提供持久化的数据存储</li>
<li>文件一直要保存完好，除非用户显式删除它们</li>
</ul></li>
<li>威胁一：设备损坏
<ul>
<li>磁盘块损坏</li>
<li>Superblock损坏：整个FS丢失</li>
<li>bitmap、inode table损坏：无法管理空间和inode</li>
<li>数据块损坏：目录、文件、间址块都无法读写</li>
</ul></li>
</ol>
<h2 id="备份与恢复">备份与恢复</h2>
<ol type="1">
<li>物理备份与恢复：设备级
<ul>
<li>将磁盘块逐一拷贝到另一个磁盘上（备份盘）</li>
<li>全复制：原始盘与备份盘在物理上一模一样</li>
<li>增量备份：只拷贝发生变化的块，与上次备份相比</li>
<li>例如：使用<code>dd</code>进行磁盘备份</li>
</ul></li>
<li>逻辑备份与恢复：文件系统级
<ul>
<li>遍历文件系统目录树，从根目录开始</li>
<li>把指定的目录和文件拷贝到备份磁盘</li>
<li>在备份过程中验证文件系统结构</li>
<li>恢复时可以将指定的文件或目录树恢复出来</li>
<li>也有两种方式
<ul>
<li>全备份：备份整个文件系统</li>
<li>增量备份：只备份发生变化的文件/目录</li>
</ul></li>
</ul></li>
</ol>
<h3 id="物理备份-vs-逻辑备份">物理备份 vs 逻辑备份</h3>
<ol type="1">
<li>物理备份
<ul>
<li>忽略文件和文件系统结构，处理过程简洁，备份性能高</li>
<li>文件修改时只用备份修改的数据块，不用备份整个文件</li>
<li>不受文件系统限制</li>
</ul></li>
<li>逻辑备份
<ul>
<li>备份文件时，文件块可能分散在磁盘上，备份性能受影响</li>
<li>文件修改时需要备份整个文件</li>
<li>受文件系统限制，按文件粒度备份，保证完整性</li>
</ul></li>
</ol>
<h1 id="宕机一致性保证">宕机一致性保证</h1>
<ol type="1">
<li>威胁二：宕机或掉电
<ul>
<li>硬件掉电</li>
<li>软件bugs导致宕机：驱动或文件系统bug</li>
<li>导致文件缓存中的脏数据没有写回磁盘：目录块、inode
、间址块、数据块</li>
</ul></li>
<li>挑战
<ul>
<li>宕机可能发生在任意时刻</li>
<li>在性能与可靠性之间进行取舍
<ul>
<li>宕机使得内存中的数据全部丢失</li>
<li>缓存越多的数据 -&gt; 性能越好</li>
<li>缓存越多的数据 -&gt; 宕机时丢失的数据越多</li>
</ul></li>
<li>一个文件写操作往往修改多个块
<ul>
<li>磁盘只能保证原子写一个扇区</li>
<li>如何保证修改多个块的原子性？</li>
</ul></li>
</ul></li>
</ol>
<h2 id="宕机的影响">宕机的影响</h2>
<ol type="1">
<li>创建文件：在当前目录 /home/xj 下创建文件 testfile
<ul>
<li>需写回4个块，在磁盘不同位置
<ul>
<li>inode bitmap</li>
<li>文件inode</li>
<li>目录块：含目录项&lt;"testfile", ino&gt;</li>
<li>目录inode：修改size，mtime等</li>
</ul></li>
<li>宕机时，没有全部写回 -&gt; FS不一致
<ul>
<li>写回顺序可能是任意的</li>
<li>目录块没写回：有inode，没目录项</li>
<li>文件inode没写回：有目录项，没inode</li>
</ul></li>
</ul></li>
<li>写文件：在 /home/xj/testfile 末尾写入一个数据块（Append）
<ul>
<li>需写回3个块，在磁盘的不同位置
<ul>
<li>文件inode：修改size，mtime等</li>
<li>data-block bitmap</li>
<li>数据块本身</li>
</ul></li>
<li>宕机时，没有全部写回 -&gt; FS不一致 &amp; 数据与元数据不一致
<ul>
<li>写回顺序可能是任意的</li>
<li>FS不一致：文件inode 和 data-block bitmap 中有一个没写回</li>
<li>数据与元数据不一致：文件inode 和 数据块没有都写回</li>
</ul></li>
</ul></li>
<li>写回方案一：先写元数据、后写数据（同上例）
<ul>
<li>路径解析"/home/xj/testfile" || 宕机 -&gt; 数据与元数据一致</li>
<li>分配数据块，写bitmap || 宕机 -&gt;
数据与元数据一致（FS不一致，有垃圾块）</li>
<li>写inode（直接指针、大小等） || 宕机 -&gt; 数据与元数据不一致</li>
<li>写数据块 || 宕机 -&gt; 数据与元数据一致</li>
</ul></li>
</ol>
<blockquote>
<p>先写元数据，宕机后可能出现数据与元数据不一致</p>
</blockquote>
<ol start="4" type="1">
<li>写回方案二：先写数据、后写元数据（同上例）
<ul>
<li>路径解析"/home/xj/testfile" || 宕机 -&gt; 数据与元数据一致</li>
<li>分配数据块，写bitmap || 宕机 -&gt;
数据与元数据一致（FS不一致，有垃圾块）</li>
<li>写数据块 || 宕机 -&gt; 数据与元数据一致</li>
<li>写inode（直接指针、大小等） || 宕机 -&gt; 数据与元数据一致</li>
</ul></li>
</ol>
<blockquote>
<p>先写数据，宕机后可能i-node指向旧版本，但数据与元数据是一致的</p>
</blockquote>
<h2 id="宕机一致性保证-1">宕机一致性保证</h2>
<h3 id="宕机一致性的分类">宕机一致性的分类</h3>
<ol type="1">
<li>FS一致性
<ul>
<li>文件系统自身的数据结构（称为FS元数据）一致
<ul>
<li>Superblock,bitmap(inode和data)，inode，目录项</li>
<li>可能导致FS不一致：修改多个元数据的操作
<ul>
<li>创建/删除文件、创建/删除目录、重命名、硬链接、符号链接、...</li>
<li>写文件</li>
</ul></li>
</ul></li>
</ul></li>
<li>数据与元数据一致性
<ul>
<li>文件元数据（inode和间址块）和文件块一致</li>
<li>数据与元数据不一致：写文件</li>
</ul></li>
<li>数据一致性
<ul>
<li>一次写多个数据块</li>
<li>数据不一致：写文件</li>
</ul></li>
<li>宕机一致性保证
<ul>
<li>一个操作包含多个修改：要么全部写到磁盘，要么都没写到磁盘</li>
</ul></li>
</ol>
<h3 id="宕机一致性的总结">宕机一致性的总结</h3>
<ol type="1">
<li>通用方法：按自底向上顺序进行修改（Ordered Write）
<ul>
<li>文件的数据块 -&gt; 文件的inode -&gt; 目录的数据块 -&gt; 目录的inode
<ul>
<li>写回所有的数据块（有文件缓存）</li>
<li>修改文件的inode，并把它写回磁盘</li>
<li>修改目录块（目录项），并把它写回磁盘</li>
<li>修改目录的inode，并把它写回磁盘</li>
<li>沿路径向上，直到无修改的目录</li>
</ul></li>
</ul></li>
<li>不足
<ul>
<li>宕机后仍然可能产生垃圾块（FS不一致），也可能有目录和文件不一致（文件修改了，目录没有改）</li>
<li>FS不一致可以通过运行一致性检查工具（例如fsck）清理垃圾块</li>
</ul></li>
<li>理想情况
<ul>
<li>保证一致性的修改，而且不留下垃圾块</li>
<li>三个一致性保证</li>
</ul></li>
</ol>
<h3 id="fsckunix-fs一致性检查工具">fsck：Unix FS一致性检查工具</h3>
<ol type="1">
<li>检查并试图恢复FS的一致性
<ul>
<li>不能解决所有问题，比如数据与元数据不一致</li>
</ul></li>
<li>检查Superblock
<ul>
<li>如果fs size &lt; 已分配块，认为它损坏，切换到另一个 Superblock
副本</li>
</ul></li>
<li>检查块位图
<ul>
<li>重构已使用块信息：扫描磁盘上所有的 inode 和间址块</li>
</ul></li>
<li>检查 inode 位图
<ul>
<li>重构已使用 inode 信息：扫描磁盘上所有目录的目录项</li>
</ul></li>
<li>检查 inode
<ul>
<li>通过 type 域的值（普通文件，目录，符号链接）来判断 inode
是否损坏</li>
<li>如果损坏，则清除该 inode 及它对应的 bitmap 位</li>
</ul></li>
<li>检查 nlink 域
<ul>
<li>遍历 FS
的整个目录树，重新计算每个文件的链接数（即指向它的目录项个数）</li>
<li>没有目录项指向的 inode ，放到 lost+found 目录下</li>
</ul></li>
<li>检查数据块冲突
<ul>
<li>是否有两个(或更多)的 inode 指向同一数据块</li>
<li>如果有 inode 损坏，则清理 inode，否则把该数据块复制一份</li>
</ul></li>
<li>检查数据块指针
<ul>
<li>指针是否越界(&gt; 磁盘分区大小)</li>
<li>删除该指针</li>
</ul></li>
<li>不足
<ul>
<li>恢复时间与 FS 大小成正比
<ul>
<li>即使只修复几个块，也需要扫描整个磁盘和遍历 FS 目录树</li>
<li>会导致丢数据：inode 损坏、数据块或间址块损坏</li>
</ul></li>
</ul></li>
</ol>
<h1 id="事务和日志文件系统">事务和日志文件系统</h1>
<blockquote>
<p>事务：一组操作，需要具有原子性 ——
要么所有操作都成功完成，要么一个操作也不曾执行过</p>
</blockquote>
<h2 id="事务的应用-write-ahead-log写前日志">事务的应用 —— Write-Ahead
Log（写前日志）</h2>
<ol type="1">
<li>写前日志
<ul>
<li>在实际进行写操作前，先把写操作记日志</li>
<li>记录日志时使用事务</li>
</ul></li>
<li>前提
<ul>
<li>日志中记录的所有修改必须是幂等的</li>
<li>每个事务有唯一的编号 TID</li>
<li>必须有办法确认写磁盘完成
<ul>
<li>TxB 和 日志记录可以同时发给磁盘，TxE最后发送，使用 Write
Barrier</li>
<li>使用 fsync 保证写盘完成</li>
</ul></li>
</ul></li>
</ol>
<h3 id="具体步骤">具体步骤</h3>
<ol type="1">
<li>Begin Transaction（开始事务）
<ul>
<li>开始一条日志项，写一个日志开始标记 TxB，标明一个事务开始</li>
</ul></li>
<li>事务中的修改
<ul>
<li>所有修改都写日志</li>
<li>事务日志中需要标明事务编号 TID</li>
</ul></li>
<li>Commit（提交事务）
<ul>
<li>写一个日志结束标记 TxE，标明一个事务成功完成</li>
</ul></li>
<li>Checkpoint（检查点）
<ul>
<li>Commit 之后，把该事务中的修改全部写到磁盘上</li>
</ul></li>
<li>清除日志
<ul>
<li>Checkpoint 写完后，清除相应的日志项</li>
</ul></li>
</ol>
<h3 id="宕机恢复replay">宕机恢复（Replay）</h3>
<ol type="1">
<li>宕机后扫描写前日志中的日志项，对于每条日志项
<ul>
<li>如果磁盘上只有日志开始标记 TxB，没有结束日志 TxE，则什么也不做</li>
<li>如果日志项是完整的（同时有 TxB 和 TxE），则按日志重做（Redo
Log），然后再清除日志</li>
</ul></li>
<li>前提假设
<ul>
<li>写到磁盘上的日志数据都是正确的</li>
<li>宕机后没有磁盘损坏</li>
</ul></li>
</ol>
<h2 id="日志文件系统journaling-file-system">日志文件系统（Journaling
File System）</h2>
<ol type="1">
<li><p>用写前日志来记录所有写操作</p>
<ul>
<li>创建/删除文件、创建/删除目录、重命名、硬链接、符号链接...</li>
<li>写文件</li>
</ul></li>
<li><p>第一个日志文件系统：Cedar FS[1987]</p></li>
<li><p>很多商用文件系统都使用写前日志：NTFS、JFS、XFS、Linux
ex2/3/4...</p></li>
<li><p>宕机恢复</p>
<ul>
<li>按日志重做一遍</li>
<li>简单、高效
<ul>
<li>恢复时间与日志大小成正比</li>
</ul></li>
<li>日志必须是等幂的</li>
</ul></li>
</ol>
<h3
id="日志文件系统数据日志data-journaling">日志文件系统：数据日志（data
journaling）</h3>
<ol type="1">
<li>记录所有修改的日志：数据 &amp; 元数据</li>
<li>例如：在一个文件末尾追加一个数据块
<ul>
<li>修改文件的inode，修改bitmap，写数据块</li>
</ul></li>
<li>流程
<ul>
<li>写日志：TxB、inode日志、bitmap日志、数据块日志</li>
<li>提交日志 commit：写 TxE</li>
<li>Checkpoint：实际修改磁盘上的inode、bitmap、数据块</li>
<li>清除日志</li>
</ul></li>
<li>日志开销
<ul>
<li>所有数据块写两次磁盘</li>
</ul></li>
</ol>
<h3
id="日志文件系统元数据日志metadata-journaling">日志文件系统：元数据日志（metadata
journaling）</h3>
<ol type="1">
<li>只记录元数据的修改的日志</li>
<li>例如：在一个文件末尾追加一个数据块
<ul>
<li>修改文件的inode，修改bitmap，写数据块</li>
</ul></li>
<li>流程
<ul>
<li>写数据块</li>
<li>写日志：TxB、inode日志、bitmap日志</li>
<li>提交日志 commit：写 TxE</li>
<li>Checkpoint：实际修改磁盘上的inode、bitmap</li>
<li>清除日志</li>
</ul></li>
<li>日志开销
<ul>
<li>只有元数据写两次磁盘，所有数据块只写一次磁盘</li>
</ul></li>
</ol>
<h3 id="日志文件系统总结">日志文件系统总结</h3>
<ol type="1">
<li>性能问题
<ul>
<li>增加额外的写磁盘开销：每个日志都要同步写磁盘（fsync）</li>
<li>写放大
<ul>
<li>即使只修改一个块中少量内容（十几字节），也需要写日志</li>
<li>Bitmap中一个bit修改，也要对bitmap block写日志</li>
</ul></li>
</ul></li>
<li>改进办法
<ul>
<li>批量写日志：以牺牲可靠性换取性能
<ul>
<li>宕机仍然可能丢数据，但不会损坏FS一致性</li>
<li>例如，再同一个目录下创建和写入多个文件</li>
</ul></li>
<li>用 NVRAM 来保存日志，实现快速同步写</li>
</ul></li>
<li>可靠性
<ul>
<li>无法应对硬件故障，比如磁盘扇区坏</li>
</ul></li>
<li>日志管理
<ul>
<li>需要多大的日志？
<ul>
<li>日志只在宕机恢复时需要</li>
<li>日志过小，很快占满日志空间，无法接受新日志</li>
<li>日志过大，导致恢复时间长</li>
</ul></li>
<li>方法
<ul>
<li>顺序地、Append-only 写，循环使用日志空间（Circular Log）</li>
<li>定期做 checkpoint ：把缓存里的修改内容刷回磁盘</li>
<li>checkpoint 之后，可以释放日志所占空间</li>
</ul></li>
</ul></li>
</ol>
<h1
id="日志结构文件系统lfs-log-structured-file-system">日志结构文件系统（LFS
—— Log-Structured File System）</h1>
<ol type="1">
<li>思想
<ul>
<li>想写日志那样顺序地写磁盘</li>
</ul></li>
<li>具体机制
<ul>
<li>每次写文件块写到新位置（日志末尾）：out-of-place update（vs in-place
update）</li>
<li>不需要 bitmap 来管理空闲空间</li>
<li>文件块采用多级索引（同FFS）：文件块位置记录在 inode中</li>
<li>每次写文件采用一致性修改：先写文件块，再写inode</li>
</ul></li>
<li>大粒度顺序写
<ul>
<li>起因：小粒度写不能发挥磁盘带宽</li>
<li>Segment：大粒度的内存 buffer
<ul>
<li>缓存多个写，一次把整个 Segment 写回磁盘</li>
<li>写回时仍然遵循 先写文件块，再写inode 的原则</li>
</ul></li>
</ul></li>
</ol>
<h2 id="读inode">读inode</h2>
<ol type="1">
<li>UFS 和 FFS
<ul>
<li>通过ino来计算出inode的位置</li>
</ul></li>
<li>LFS
<ul>
<li>每次写文件块，都要写 inode</li>
<li>每次会写到新的位置，即一个文件的 inode 在磁盘没有固定位置</li>
</ul></li>
</ol>
<h3 id="imap">imap</h3>
<ol type="1">
<li>记录 ino-&gt;inode 磁盘地址，只记录最新的inode地址</li>
<li>怎么存
<ul>
<li>磁盘上的固定位置</li>
<li>每次写文件，都要修改 imap</li>
<li>写日志与写imap需要长距离寻道，性能比 FFS 还差</li>
</ul></li>
<li>LFS的改进方法
<ul>
<li>imap块随文件块和i-node一起写到日志中</li>
<li>CR(Change Region)：记录每个imap块的最新磁盘地址</li>
<li>CR位于磁盘上固定位置：有两个CR，分别位于磁盘的头和尾</li>
</ul></li>
</ol>
<blockquote>
<p>关于目录：目录采用与文件一样的方式来写</p>
</blockquote>
<h2 id="读文件">读文件</h2>
<ol type="1">
<li>假设 LFS 刚挂载，内存里什么也没有
<ul>
<li>先读 CR，把 CR 缓存在内存，以后就不用读了</li>
<li>根据 ino ，知道它所在的磁盘块</li>
<li>查 CR 得到 imp 块的磁盘地址</li>
<li>读 imap 块，得到 ino 对应的 inode 的磁盘地址</li>
<li>读 inode，查文件块索引，得到文件块的磁盘地址</li>
<li>读文件块</li>
</ul></li>
</ol>
<h2 id="修改文件">修改文件</h2>
<ol type="1">
<li>修改 /home/os/foo 的第一块
<ul>
<li>原来的数据块变为无效 -&gt; 垃圾</li>
</ul></li>
<li>在 /home/os/foo 末尾追加写一块
<ul>
<li>原来的inode变为无效 -&gt; 垃圾</li>
</ul></li>
</ol>
<h3 id="垃圾回收">垃圾回收</h3>
<ol type="1">
<li>原理
<ul>
<li>后台进程cleaner周期性地检查一定数量的segment</li>
<li>把每个segment中的活块拷贝到新的segment中
<ul>
<li>如何判断活块？
<ul>
<li>segment summary block
<ul>
<li>记录每个数据块的ino和文件内偏移</li>
<li>位于 segment 的头部</li>
</ul></li>
<li>通过查segment summary block、imap和文件索引可以得到当前块的地址</li>
</ul></li>
</ul></li>
<li>M个segment的活块占据N个新的segment</li>
</ul></li>
<li>何时回收
<ul>
<li>周期性回收</li>
<li>空闲时：无访问或访问少</li>
<li>磁盘快满的时候</li>
</ul></li>
<li>回收什么样的segment
<ul>
<li>热segment：块频繁被重写</li>
<li>冷segment：部分死块、部分稳定块（不重写）</li>
<li>优先回收冷segment，推迟回收热segment（直至该segment里的数据块都被重写过）</li>
</ul></li>
</ol>
<h2 id="宕机恢复">宕机恢复</h2>
<ol type="1">
<li>LFS的最新修改在日志末尾</li>
<li>CR记录第一个 segment 和最后一个 segment 的磁盘地址
<ul>
<li>每个segment指向下一个segment</li>
</ul></li>
<li>CR更新
<ul>
<li>写CR的第一个块，带时间戳</li>
<li>写CR本身内容</li>
<li>写CR最后一个块，带时间戳</li>
<li>周期性地将CR刷盘（30s）</li>
<li>两个CR（磁盘头和尾）交替写，减少CR更新时宕机的影响</li>
</ul></li>
<li>CR一致性保证
<ul>
<li>第一个块和最后一个块的时间戳一致</li>
</ul></li>
<li>恢复方式
<ul>
<li>使用最后一次且一致的 Checkpoint Region
<ul>
<li>时间戳最新的 &amp; 完整的CR</li>
<li>可以获得最后一次 Checkpoint 时的 CR 内容，包括 imap
等数据结构的地址</li>
</ul></li>
<li>CR 周期性刷盘，此时 CR 内容可能已过时，即最后一次 Checkpoint
后的磁盘写没有被恢复</li>
<li>恢复优化（回滚）
<ul>
<li>使用最后一次修改的 CR（不一定是一致的）重构最新的文件修改
<ul>
<li>根据 CR 找到日志末尾（有记录），检查后续写的 segment</li>
<li>将其中有效的更新恢复到文件系统，例如，将 segment summary block
中记录的 inode 更新到 imap 中</li>
</ul></li>
</ul></li>
<li>恢复快
<ul>
<li>无需fsck，无需扫描磁盘</li>
<li>秒级 vs 小时级</li>
</ul></li>
</ul></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://blog.jamesyuuu.me/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="JamesYu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JamesYu's Hut">
      <meta itemprop="description" content="A Game and Bangumi Database For Private Use">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | JamesYu's Hut">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0/" class="post-title-link" itemprop="url">文件系统实现</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-12-26 17:34:00" itemprop="dateCreated datePublished" datetime="2022-12-26T17:34:00+08:00">2022-12-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-11-01 20:48:22" itemprop="dateModified" datetime="2025-11-01T20:48:22+08:00">2025-11-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Study/" itemprop="url" rel="index"><span itemprop="name">Study</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>3.5k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>13 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="文件块索引结构">文件块索引结构</h1>
<h2 id="文件块索引连续分配">文件块索引：连续分配</h2>
<ol type="1">
<li>分配连续的磁盘块给文件
<ul>
<li>文件粒度分配</li>
<li>bitmap：找到N个连续的"0"</li>
<li>链表：找到 size&gt;=N 的区域</li>
</ul></li>
<li>文件元数据
<ul>
<li>记录第一个块的地址</li>
<li>块的个数N</li>
</ul></li>
<li>优点
<ul>
<li>顺序访问性能高</li>
<li>随机访问时定位数据块也较容易</li>
</ul></li>
<li>缺点
<ul>
<li>不知道文件最终多大，无论创建时，还是写数据块的时候</li>
<li>文件难以变大</li>
<li>外部碎片化</li>
</ul></li>
</ol>
<h2 id="文件块索引链表结构">文件块索引：链表结构</h2>
<ol type="1">
<li>分配不连续的磁盘块给文件
<ul>
<li>块粒度分配</li>
</ul></li>
<li>文件元数据
<ul>
<li>记录第一个块的地址</li>
<li>每个块指向下一个块的地址</li>
<li>最后一个块指向NULL</li>
</ul></li>
<li>优点
<ul>
<li>无外部碎片，而且文件变大很容易</li>
<li>空闲空间链表：与文件块类似</li>
</ul></li>
<li>缺点
<ul>
<li>随机方式性能极差：定位数据块需按指针顺序遍历链表</li>
<li>可靠性差：一个坏块意味着其余的数据全部丢失</li>
<li>块内要保存指向下一块的指针，有效数据大小不一定是2的幂次</li>
</ul></li>
</ol>
<h2 id="文件块索引文件分配表fat">文件块索引：文件分配表（FAT）</h2>
<ol type="1">
<li>一张有N的项的表，假设磁盘有N块
<ul>
<li>每个磁盘块有一个表项：要么为空，要么为该文件下一块的地址</li>
<li>位于磁盘分区的头部</li>
</ul></li>
<li>文件元数据
<ul>
<li>记录第一块的地址：链表头指针</li>
<li>每个磁盘块全部存数据，无指针</li>
</ul></li>
<li>优点
<ul>
<li>简单</li>
<li>文件块为2的幂次</li>
</ul></li>
<li>缺点
<ul>
<li>随机访问性能不好
<ul>
<li>定位数据需要查找FAT表</li>
</ul></li>
<li>浪费空间
<ul>
<li>需要额外的空间存储FAT表</li>
</ul></li>
</ul></li>
</ol>
<h2 id="文件块索引单机索引">文件块索引：单机索引</h2>
<ol type="1">
<li>文件元数据
<ul>
<li>用户定义文件长度上限 max size</li>
<li>file header: 一个指针数组指向每个块的磁盘地址</li>
</ul></li>
<li>优点
<ul>
<li>文件在限制内可变大</li>
<li>随机访问性能高：数据块直接定位</li>
</ul></li>
<li>缺点
<ul>
<li>不灵活，文件长度难以事先知道</li>
</ul></li>
</ol>
<h2 id="文件块索引两级索引">文件块索引：两级索引</h2>
<ol type="1">
<li>思路：
<ul>
<li>采用可变段分配</li>
<li>段内的块连续分配，段间运行不连续</li>
</ul></li>
<li>文件元数据
<ul>
<li>小文件有10个指针，指向10个可变长度段（base,size）</li>
<li>大文件有10个间接指针，每个指向可变长度的间址块</li>
</ul></li>
<li>优点
<ul>
<li>支持文件变大</li>
</ul></li>
<li>缺点
<ul>
<li>段间碎片</li>
</ul></li>
</ol>
<h2 id="文件块索引多级索引unix">文件块索引：多级索引（UNIX）</h2>
<ol type="1">
<li>块粒度分配</li>
<li>文件元数据：13个指针
<ul>
<li>10个直接指针</li>
<li>第11个指针：一级间接指针</li>
<li>第12个指针：二级间接指针</li>
<li>第13个指针：三级间接指针</li>
</ul></li>
<li>优点
<ul>
<li>小文件访问方便</li>
<li>支持文件变大</li>
</ul></li>
<li>缺点
<ul>
<li>文件有上限</li>
<li>存在大量寻道</li>
</ul></li>
</ol>
<h2 id="文件块索引extents">文件块索引：Extents</h2>
<ol type="1">
<li>Extent是若干个连续磁盘块（长度不固定）
<ul>
<li>同一Extent中的所有块：要么多少空闲块，要么都属于某个文件</li>
<li>Extent：&lt;starting block, length&gt;</li>
</ul></li>
<li>XFS提出的方法
<ul>
<li>无论文件块还是空闲块都采用Extents来组织
<ul>
<li>块大小为8KB</li>
<li>Extent的大小 &lt;= 2M个块</li>
</ul></li>
<li>文件块索引
<ul>
<li>采用B+树，中间结点记录文件块号和子节点的磁盘块地址</li>
<li>叶节点记录文件快好和其所属的Extent</li>
</ul></li>
<li>文件元数据
<ul>
<li>记录B+树的根结点地址</li>
</ul></li>
</ul></li>
</ol>
<h1 id="目录项的组织结构">目录项的组织结构</h1>
<h2 id="目录访问">目录访问</h2>
<ol type="1">
<li>路径解析
<ul>
<li>在目录里查找指定目录项：文件名</li>
</ul></li>
<li>修改目录
<ul>
<li>创建/删除目录、创建/删除文件、硬链接、符号链接、重命名</li>
<li>在目录里添加/删除目录项</li>
</ul></li>
<li>读目录
<ul>
<li>扫描目录内容</li>
</ul></li>
</ol>
<h3 id="目录项的组织结构-1">目录项的组织结构</h3>
<ol type="1">
<li>线性表
<ul>
<li>原理
<ul>
<li>&lt;文件名,ino&gt; 线性存储
<ul>
<li>每一项不定长：&lt;ino,名字长度，下一项起始偏移，名字&gt;</li>
</ul></li>
<li>创建文件
<ul>
<li>先查看有没有重名文件</li>
<li>如果没有，在表末添加一个entry: &lt;ino,newfile&gt;</li>
</ul></li>
<li>删除文件
<ul>
<li>用文件名查找</li>
<li>删除匹配的entry</li>
<li>紧缩：将之后的entry都向前移动</li>
</ul></li>
</ul></li>
<li>优点
<ul>
<li>空间利用率高</li>
</ul></li>
<li>缺点
<ul>
<li>大目录性能差：线性查找，目录项数据从磁盘读取，磁盘的I/O多</li>
<li>删除时的紧缩很耗时</li>
</ul></li>
</ul></li>
<li>B+树
<ul>
<li>原理
<ul>
<li>在磁盘上使用B树索引目录的数据块</li>
<li>用B树来存储&lt;文件名,ino&gt;，以文件名排序（字典序）</li>
<li>创建/删除/查找：通过B树实现</li>
</ul></li>
<li>优点
<ul>
<li>大目录性高：B树的查找减少磁盘的I/O</li>
</ul></li>
<li>缺点
<ul>
<li>小目录不高效</li>
<li>占用更多空间</li>
<li>实现复杂</li>
</ul></li>
</ul></li>
<li>使用哈希表索引
<ul>
<li>原理
<ul>
<li>在VFS中使用哈希表索引目录项</li>
<li>用哈希表将文件名映射到ino
<ul>
<li>hash_func(filename) -&gt; hval -&gt; 哈希桶</li>
<li>在哈希桶中线性查找 filename</li>
</ul></li>
<li>创建/删除需要分配/回收空间</li>
</ul></li>
<li>优点
<ul>
<li>简单</li>
<li>查找速度快</li>
</ul></li>
<li>缺点
<ul>
<li>哈希表空间不好估计
<ul>
<li>表较大浪费空间</li>
<li>表小容易产生大量哈希冲突</li>
</ul></li>
</ul></li>
</ul></li>
</ol>
<h3 id="创建文件或目录">创建文件或目录</h3>
<blockquote>
<p>例子：创建文件<code>/home/os22/fs02.ppt</code></p>
</blockquote>
<ol type="1">
<li>解析父目录"/home/os22"，得到其ino，假设为100</li>
<li>读取其i-node，检查用户是否具有创建的权限</li>
<li>根据i-node，读取父目录的内容</li>
<li>查找是否已经存在名字为"fs02.ppt"的目录项</li>
<li>如果找到，同时flag为目录，则返回失败，否则转11</li>
<li>为"fs02.ppt"分配一个空闲的inode，假设其ino为116</li>
<li>填充inode的内容ino,size,uid,gid,ctime,mode...</li>
<li>在父目录的内容中添加一个目录项&lt;"fs02.ppt",116&gt;</li>
<li>修改父目录的inode:size,atime,mtime</li>
<li>把修改写到磁盘"fs02.ppt"的inode、父目录的inode、父目录内容</li>
<li>创建一个打开文件结构，指向"fs02.ppt"的inode</li>
<li>分配一个空闲的打开文件结构指针，指向打开文件结构</li>
<li>返回指针的数组下标</li>
</ol>
<h3 id="删除文件或目录">删除文件或目录</h3>
<blockquote>
<p>例子：删除文件<code>/home/os22/fs02.ppt</code></p>
</blockquote>
<ol type="1">
<li>路径解析父目录"/home/os22"，得到其ino为100</li>
<li>读取其i-node，检查用户是否具有删除的权限</li>
<li>根据i-node，读取父目录的内容</li>
<li>查找是否已经存在名字为"fs02.ppt"的目录项</li>
<li>如果不存在，则返回失败</li>
<li>得到"fs02.ppt"的ino为116</li>
<li>如果nlink为1，则释放inode及文件块，否则nlink-1</li>
<li>在父目录的内容中删除目录项&lt;"fs02.ppt",116&gt;</li>
<li>修改父目录的inode:size,atime,mtime</li>
<li>把修改写到磁盘：inode、父目录inode、父目录内容、空闲块</li>
<li>返回</li>
</ol>
<h1 id="文件缓存">文件缓存</h1>
<blockquote>
<p>例如：解析路径"/home/foo"，并读/写，会产生大量I/O</p>
</blockquote>
<ol type="1">
<li>读根目录的i-node和它的第一块</li>
<li>读home目录的i-node和它的第一块</li>
<li>读foo文件的i-node和它的第一块 / 创建文件foo并写其第一块</li>
</ol>
<h2 id="文件缓存file-buffer-cachepage-cache">文件缓存（File buffer
cache/page cache）</h2>
<ol type="1">
<li>使用内核空间的一部分内存来缓存磁盘块</li>
<li>读操作read()：先检查该块是否在缓存中
<ul>
<li>在：将缓冲块的内容拷贝到用户buffer</li>
<li>不在：
<ul>
<li>分配一个缓存块（可能需要替换）</li>
<li>把磁盘块读到缓冲</li>
<li>再把缓存块拷贝到用户buffer</li>
</ul></li>
</ul></li>
<li>写操作write()：先检查该块是否在缓存中
<ul>
<li>在：将用户buffer的内容拷贝到缓冲块</li>
<li>不在：
<ul>
<li>分配一个缓存块（可能需要替换）</li>
<li>把用户buffer的内容拷贝到缓存块</li>
</ul></li>
<li>将该缓存块写回磁盘（根据缓存管理策略）</li>
</ul></li>
<li>缓存设计问题
<ul>
<li>缓存什么、缓存大小、何时放进缓存、替换谁、写回策略</li>
</ul></li>
</ol>
<h3 id="缓存什么">缓存什么</h3>
<ol type="1">
<li>不同类型的块
<ul>
<li>i-nodes</li>
<li>间址块</li>
<li>目录</li>
<li>文件块</li>
</ul></li>
</ol>
<h3 id="缓存大小">缓存大小</h3>
<ol type="1">
<li>文件缓存与进程使用的虚存竞争有限的内存空间</li>
<li>两种方法
<ul>
<li>固定大小：用特权命令设置文件缓存大小</li>
<li>可变大小：
<ul>
<li>文件缓存和VM都按需申请内存：页替换</li>
<li>文件缓存大小不可控</li>
</ul></li>
</ul></li>
</ol>
<h3 id="替换谁">替换谁</h3>
<ol type="1">
<li>为什么缓存位于内核空间
<ul>
<li>DMA
<ul>
<li>DMA数据传输</li>
</ul></li>
<li>多用户进程
<ul>
<li>共享缓存</li>
</ul></li>
</ul></li>
<li>通常的替换策略
<ul>
<li>全局LRU</li>
<li>进程工作集</li>
</ul></li>
</ol>
<h3 id="何时放进缓存">何时放进缓存</h3>
<ol type="1">
<li>何时放进缓存：按需取 vs 预取</li>
<li>文件访问具有局部性
<ul>
<li>时间局部性</li>
<li>空间局部性</li>
</ul></li>
<li>最优
<ul>
<li>在要用之前搞好预取进来</li>
</ul></li>
<li>通常的策略
<ul>
<li>针对顺序访问的预取：访问第i块时，预取随后的k个块
<ul>
<li>文件块尽量分配连续的磁盘块</li>
<li>Linux采用的方法</li>
</ul></li>
<li>针对inode的预取：在读取目录项时，同时读取对应的inodes</li>
</ul></li>
<li>高级策略
<ul>
<li>预取同一目录下所有的小文件</li>
</ul></li>
</ol>
<h3 id="写回策略">写回策略</h3>
<ol type="1">
<li>写操作
<ul>
<li>数据必须写到磁盘才能持久化</li>
</ul></li>
<li>缓存中的数据何时写到磁盘上
<ul>
<li>Write Through
<ul>
<li>每个写操作，不仅更新缓存块，而且立即更新磁盘块</li>
<li>好处：简单&amp;可靠性高，最新数据都落盘</li>
<li>坏处：磁盘写没有减少</li>
</ul></li>
<li>Write Back
<ul>
<li>每个写操作，只更新缓存块，并将其标记为脏块</li>
<li>之后再将它写到磁盘</li>
<li>写操作快 &amp; 减少磁盘写：缓存吸纳多次写，批量写磁盘</li>
</ul></li>
</ul></li>
<li>写回的复杂性
<ul>
<li>丢数据
<ul>
<li>宕机时，缓存中的“脏”数据将全部丢失</li>
<li>推迟写磁盘 -&gt; 更好的性能，但损失更大</li>
</ul></li>
<li>什么时候写回磁盘
<ul>
<li>当一个块被替换出缓存时</li>
<li>当文件关闭时</li>
<li>当进程调用fsync时</li>
<li>固定的时间间隔（Unix是30s）</li>
</ul></li>
<li>问题
<ul>
<li>执行写操作的进程并不知道数据什么时候落盘了
<ul>
<li>通过fsync：用户显式写回数据</li>
</ul></li>
<li>不能保证不丢数据：宕机或掉电可能发生在任何时候</li>
</ul></li>
</ul></li>
</ol>
<h3 id="文件系统-vs-虚存">文件系统 vs 虚存</h3>
<ol type="1">
<li>相似点
<ul>
<li>位置透明性：用户不感知物理地址</li>
<li>大小无关性：固定粒度分配（块/页），不连续分配</li>
<li>保护：读/写/执行权限</li>
</ul></li>
<li>FS 比 VM 容易的地方
<ul>
<li>FS的地址转换可以慢</li>
<li>文件比较稠密（空洞少），经常是顺序访问</li>
<li>进程地址空间非常稀疏，通常是随机访问</li>
</ul></li>
<li>FS 比 VM 难的地方
<ul>
<li>路径解析可能引入多次I/O</li>
<li>文件缓存的空间（内存）总是不够的</li>
<li>文件大小差距大：很多不足10KB，有些又大于GB</li>
<li>FS的实现必须是可靠的</li>
</ul></li>
</ol>
<h4 id="虚存页表-vs-文件块索引">虚存页表 vs 文件块索引</h4>
<ol type="1">
<li>页表
<ul>
<li>维护进程地址空间与物理内存的映射关系</li>
<li>虚页号 -&gt; 物理页框号</li>
<li>查检访问权限、地址合法性</li>
<li>硬件实现地址转换，如果映射关系在TLB中，很快完成转换</li>
</ul></li>
<li>文件块索引
<ul>
<li>维护文件块与磁盘块之间的映射关系</li>
<li>文件块号 -&gt; 磁盘逻辑块号</li>
<li>查检访问权限、地址合法性</li>
<li>软件（OS）实现地址转换，可能需要多次磁盘I/O</li>
</ul></li>
</ol>
<h1 id="ffsunix文件系统">FFS（Unix文件系统）</h1>
<h2 id="最初的-unix-fs">最初的 Unix FS</h2>
<ol type="1">
<li>简单的磁盘布局
<ul>
<li>文件块大小 = 扇区大小 = 512B</li>
<li>i-node区在前，数据区灾后</li>
<li>空闲块/inode链表：Superblock中记录头指针</li>
</ul></li>
<li>文件块索引采用三级间指，目录采用线性表</li>
<li>存在的问题
<ul>
<li>带宽很低：顺序访问只有20KB/s，即2%的磁盘带宽</li>
</ul></li>
</ol>
<h3 id="导致带宽低的原因">导致带宽低的原因</h3>
<ol type="1">
<li>数据块的存储位置
<ul>
<li>数据块存储在内层的柱面</li>
<li>inode 存储在外层的柱面</li>
</ul></li>
<li>频繁长距离寻道
<ul>
<li>inode 与其数据块离得很远</li>
<li>同一目录里的文件，其inode也离得很远</li>
<li>一个文件的数据块散布在磁盘上任意位置
<ul>
<li>即使顺序读写文件 -&gt; 随机磁盘 I/O</li>
</ul></li>
</ul></li>
<li>未考虑给文件分配连续磁盘块
<ul>
<li>空闲块采用链表组织</li>
<li>链表上相邻的块，其物理地址不连续</li>
</ul></li>
<li>小粒度访问多
<ul>
<li>采用512B的小块</li>
<li>无法发挥磁盘带宽</li>
</ul></li>
</ol>
<h2 id="bsd-ffsfast-file-system">BSD FFS（Fast File System）</h2>
<ol type="1">
<li>大文件块：4KB/8KB vs 512B
<ul>
<li>数据块大小记录在Superblock中</li>
<li>空间利用率问题
<ul>
<li>小文件</li>
<li>大文件的最末一块可能非常小</li>
</ul></li>
<li>FFS的解决办法
<ul>
<li>数据块划分为若干更小的子块</li>
<li>子块为512B，每块8/16个子块</li>
</ul></li>
</ul></li>
<li>Bitmap：取代空闲块链表
<ul>
<li>尽量连续分配</li>
<li>预留 10% 的磁盘空间</li>
</ul></li>
</ol>
<h3 id="ffs的磁盘布局">FFS的磁盘布局</h3>
<ol type="1">
<li>柱面组（Cylinder Group）
<ul>
<li>柱面：所有盘片上半径相同的磁道构成一个柱面。</li>
<li>CG：每N个连续的柱面为一个CG</li>
<li>把磁盘划分为若干柱面组，将文件和目录分散存储于每个柱面组</li>
<li>每个CG类似于一个 Sub FS
<ul>
<li>包含Superblock，空闲inode bitmap，空闲块bitmap，inode表，数据块</li>
</ul></li>
</ul></li>
</ol>
<h3 id="ffs的放置策略">FFS的放置策略</h3>
<ol type="1">
<li>减少长距离寻道
<ul>
<li>原则：把相关的东西放在同一CG</li>
</ul></li>
<li>目录放置
<ul>
<li>选择CG：目录个数少 &amp; 空闲inode个数多 &amp; 空闲块多</li>
</ul></li>
<li>文件放置
<ul>
<li>文件inode选择其目录所在的CG</li>
<li>文件块选择其inode所在的CG
<ul>
<li>inode与文件块一起读的概率是只读inode的4倍</li>
</ul></li>
</ul></li>
<li>大文件处理
<ul>
<li>应避免它占满一个CG</li>
<li>inode所在CG：存放前10个磁盘块（直接指针指向）</li>
<li>每个间址块及其指向的块放在同一CG（4MB）</li>
<li>不同间址块及其指向的块放在不同CG</li>
</ul></li>
</ol>
<h3 id="ffs的效果">FFS的效果</h3>
<ol type="1">
<li>性能提升
<ul>
<li>读写性能和CPU利用率提升</li>
<li>小文件性能提升</li>
</ul></li>
<li>进一步的优化空间
<ul>
<li>块粒度分配和多级索引，大文件访问不高效
<ul>
<li>用 Extent 来描述连续的数据块</li>
</ul></li>
<li>元数据采用同步写，影响小文件性能
<ul>
<li>异步写，并保证一定的顺序</li>
<li>日志</li>
</ul></li>
</ul></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://blog.jamesyuuu.me/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="JamesYu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JamesYu's Hut">
      <meta itemprop="description" content="A Game and Bangumi Database For Private Use">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | JamesYu's Hut">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">文件系统基础</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-12-26 16:09:00" itemprop="dateCreated datePublished" datetime="2022-12-26T16:09:00+08:00">2022-12-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-11-01 20:48:22" itemprop="dateModified" datetime="2025-11-01T20:48:22+08:00">2025-11-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Study/" itemprop="url" rel="index"><span itemprop="name">Study</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>7 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="文件系统基础">文件系统基础</h1>
<ol type="1">
<li>为什么我们需要文件系统
<ul>
<li>持久化保存数据需求（Persistence）</li>
<li>进程结束、关机/关电、宕机/掉电</li>
<li>使用持久化存储设备：磁盘、SSD等</li>
</ul></li>
<li>FS 是对持久化数据存储的抽象
<ul>
<li>给用户/程序开发者提供一个逻辑上的持久化存储
<ul>
<li>文件、目录形式</li>
<li>简单、易理解、操作方便</li>
</ul></li>
<li>将复杂的、公共的管理功能从用户程序中移出
<ul>
<li>存储设备管理，例如磁盘</li>
<li>数据管理，即程序持久化数据的组织和增删改查</li>
</ul></li>
</ul></li>
<li>对FS的基本需求
<ul>
<li>能够保存大量（复杂多样）的信息 -&gt; 管理问题</li>
<li>多个进程同时访问 -&gt; 并发控制问题</li>
<li>多用户共享数据 &amp; 私有数据 -&gt; 安全保护问题</li>
</ul></li>
</ol>
<h2 id="文件系统的用户视图">文件系统的用户视图</h2>
<ol type="1">
<li>文件：数据组织的单位
<ul>
<li>文件是命名的字节数组</li>
<li>用户将数据组织成文件，根据文件名来访问对应的数据</li>
<li>FS不感知文件的内容：使用文件的进程负责解析内容</li>
</ul></li>
<li>目录：文件组织的单位
<ul>
<li>一组文件和目录的命名集合</li>
<li>父目录、子目录</li>
<li>同一目录下没有重名的</li>
</ul></li>
<li>名字空间：树形层次结构
<ul>
<li>文件系统的逻辑视图</li>
</ul></li>
</ol>
<h3 id="文件">文件</h3>
<ol type="1">
<li>文件名：由字母、数字及某些特殊字符组成的字符串
<ul>
<li>用户根据文件名来访问文件</li>
<li>文件扩展名：描述文件的用途</li>
</ul></li>
<li>文件属性
<ul>
<li>文件大小、所有者、时间戳、访问权限</li>
<li>文件逻辑地址：0..fsize-1，指示数据在文件中的位置</li>
</ul></li>
<li>文件内容：无结构
<ul>
<li>OS将文件视为无结构的字节数组</li>
<li>程序开发者可以定义任意结构的文件</li>
</ul></li>
<li>文件的类型
<ul>
<li>常规文件、目录文件、设备文件、可执行文件</li>
</ul></li>
<li>文件的访问
<ul>
<li>打开文件 &amp; 文件描述符</li>
<li>当前位置：文件内部的逻辑地址，范围是[0,fsize-1]</li>
<li>访问方式（Access Mode）：读，写，执行</li>
</ul></li>
<li>文件的访问模式（Access Pattern)
<ul>
<li>顺序访问
<ul>
<li>从头到尾依次访问每个文件块</li>
<li>顺序访问文件 不等于 磁盘上顺序访问扇区</li>
</ul></li>
<li>随机访问
<ul>
<li>每次随机访问一个文件块</li>
</ul></li>
<li>按关键字访问
<ul>
<li>查找包含关键字的文件及段落</li>
<li>文件系统本身不提供此功能，需要借助应用程序完成</li>
<li>与之相比，数据库自身可以实现按关键字查找记录</li>
</ul></li>
</ul></li>
</ol>
<h3 id="目录">目录</h3>
<ol type="1">
<li>路径
<ul>
<li>根目录 &amp; 当前工作目录</li>
<li>. : 当前目录</li>
<li>.. : 根目录</li>
<li>绝对路径 vs 相对路径</li>
</ul></li>
<li>目录：一种特殊的文件
<ul>
<li>命中 &amp; 属性</li>
<li>目录和文件用相同的数据结构（inode）
<ul>
<li>通过一个标志（i_mode）来区分文件和目录</li>
</ul></li>
<li>目录内容：描述它所包含的目录和文件集合
<ul>
<li>有结构：逻辑上是一张表</li>
<li>目录项：每个成员一项</li>
<li>不同的FS采用不同的结构</li>
<li>由FS负责维护和解析目录内容</li>
<li>访问目录 vs 访问文件：通过不同的syscall实现</li>
</ul></li>
</ul></li>
</ol>
<h3 id="链接">链接</h3>
<ol type="1">
<li>硬链接
<ul>
<li>为文件共享提供的一种手段
<ul>
<li>为文件创建一个新名字，无数据拷贝</li>
<li>多个名字可以指向同一个文件</li>
<li>一个文件可以同时拥有多个名字，甚至位于多个目录中</li>
</ul></li>
<li>限制
<ul>
<li>不能跨文件系统</li>
<li>不能链接目录</li>
</ul></li>
</ul></li>
<li>符号链接
<ul>
<li>另一种文件共享的手段
<ul>
<li>创造一个普通文件，内容为目标地址的路径（绝对路径/相对路径）</li>
</ul></li>
</ul></li>
</ol>
<h1 id="文件系统内部结构">文件系统内部结构</h1>
<h2 id="虚拟文件系统-和-物理文件系统">虚拟文件系统 和 物理文件系统</h2>
<ol type="1">
<li>虚拟文件系统
<ul>
<li>同时挂载不同类型的FS
<ul>
<li>SUNFS访问本地的磁盘</li>
<li>SUN NFS访问远端服务器的FS</li>
</ul></li>
<li>实现FS接口和通用功能</li>
</ul></li>
<li>物理文件系统
<ul>
<li>磁盘布局、数据结构、磁盘空间管理、名字空间管理等</li>
</ul></li>
<li>虚拟文件系统开关表
<ul>
<li>用于物理文件系统的挂载与卸载</li>
<li>每一种类型的文件系统有一个表项
<ul>
<li>文件系统类型的名字</li>
<li>初始化函数指针，用于 mount</li>
<li>清除函数指针，用于 umount</li>
</ul></li>
<li>例子: <code>mount -t ext4 /dev/sdb /home/os</code>
<ul>
<li>前提：
<ul>
<li>文件系统类型ext4必须事先加载进内核</li>
<li>挂载目录 /home/os 必须要已经创建好</li>
</ul></li>
<li>步骤
<ul>
<li>根据文件系统类型，查VFS开关表，找到该ext4类型FS的初始化函数，即<code>ext4_mount()</code></li>
<li>调用<code>ext4_mount</code>
<ul>
<li>读取<code>superblock</code></li>
<li>读取根目录<code>i-node</code></li>
</ul></li>
<li>初始化一些内存数据结构</li>
</ul></li>
</ul></li>
</ul></li>
</ol>
<h2 id="文件系统主要数据结构">文件系统主要数据结构</h2>
<h3 id="i-node">i-node</h3>
<blockquote>
<p>inode：描述文件/目录，也成为文件元数据</p>
</blockquote>
<ol type="1">
<li>每个文件用一个i-node来描述</li>
<li>文件元数据
<ul>
<li>mode: 文件类型和访问权限</li>
<li>size: 文件大小</li>
<li>nlinks: 硬链接数</li>
<li>uid: 所有者的user id</li>
<li>gid: 所有者的group id</li>
<li>ctime: 文件创建的时间戳</li>
<li>atime: 上一次访问文件的时间戳</li>
<li>mtime: 上一次修改文件的时间戳</li>
</ul></li>
<li>ino：inode number，即i-node的ID，唯一标识一个文件（在一个FS内）</li>
<li>文件块的索引信息：文件块的磁盘位置信息
<ul>
<li>&lt;offset,count&gt; -&gt; 磁盘上的位置 （文件块# -&gt; 磁盘逻辑块#
LBN）</li>
<li>不同的FS采取不同的索引机制</li>
</ul></li>
</ol>
<h3 id="目录项dentry">目录项（dentry）</h3>
<blockquote>
<p>dentry: 目录项，记录文件和inode的对应关系</p>
</blockquote>
<ol type="1">
<li>目录内容为它所包含的所有子目录和文件的名字及其ino
<ul>
<li>不包含子目录的内容</li>
</ul></li>
<li>逻辑上，目录是一张映射表
<ul>
<li>目录项(dentry): 文件名 -&gt; ino</li>
</ul></li>
<li>物理上，目录项是一个字节数组
<ul>
<li>文件名不等长，数组每一项不等长</li>
</ul></li>
<li>路径解析
<ul>
<li>根据路径名，获得其ino</li>
<li>逐级目录查找</li>
<li>例子: <code>/home/os/fs01.ppt</code>
<ul>
<li>从根目录开始，查找<code>/home</code>的ino</li>
<li>在<code>home</code>目录下查找<code>os</code>的ino</li>
<li>再<code>os</code>目录下查找<code>fs01.ppt</code>的ino</li>
<li>根据<code>fs01.ppt</code>的ino，找到其数据块，进行读写操作</li>
</ul></li>
</ul></li>
</ol>
<h3 id="打开文件表open-file-table">打开文件表（Open-file table）</h3>
<blockquote>
<p>打开文件表：记录进程打开的文件信息</p>
</blockquote>
<ol type="1">
<li>打开文件，通过 <code>fd = open(path,flags,mode)</code>实现</li>
<li>打开文件表: Open-file table
<ul>
<li>通过打开文件表（在内存中）把进程与文件的i-node进行关联</li>
<li>路径名解析和权限检查，得到path的ino，读出它的inode（保存在磁盘上）</li>
<li>将磁盘i-node拷贝到一个内存i-node结构中，在打开文件表中增加一项，包含以下内容
<ul>
<li>文件的Reference Count</li>
<li>当前文件的偏移量</li>
<li>文件的访问模式</li>
<li>内存inode结构的指针</li>
</ul></li>
</ul></li>
</ol>
<blockquote>
<p>文件描述符表：File Descriptor Table</p>
</blockquote>
<ol type="1">
<li>每个进程有一个文件描述符表
<ul>
<li>指针数组，每个指针指向打开文件表中的一项，表示一个打开文件</li>
<li>该指针在文件描述符表中的下表，即文件描述符fd</li>
</ul></li>
</ol>
<h3 id="超级块superblock">超级块（superblock）</h3>
<blockquote>
<p>superblock: 描述文件系统基本信息</p>
</blockquote>
<ol type="1">
<li>定义一个文件系统
<ul>
<li>数据块的大小</li>
<li>i-node的大小</li>
<li>数据块总数</li>
<li>i-node总数</li>
<li>根目录ino</li>
<li>i-node表的起始地址</li>
<li>Block Bitmap的起始地址</li>
<li>i-node Bitmap的起始地址</li>
</ul></li>
<li>当前状态
<ul>
<li>数据块的使用状态：已使用的块数、预留的块数、剩余的块数...</li>
<li>i-node的使用状态：已使用的i-node数、预留的i-node数、剩余的i-node数...</li>
</ul></li>
</ol>
<h3 id="文件系统的磁盘布局">文件系统的磁盘布局</h3>
<blockquote>
<p>Boot Block | Superblock | Block Bitmap | i-node Bitmap | I-node Array
| Data Blocks</p>
</blockquote>
<ol type="1">
<li>引导块
<ul>
<li>启动OS的代码</li>
</ul></li>
<li>Superblock：定义一个FS
<ul>
<li>FS的相关信息</li>
</ul></li>
<li>空闲空间管理相关的信息
<ul>
<li>Block Bitmap</li>
<li>i-node Bitmap</li>
</ul></li>
<li>i-node表
<ul>
<li>每个i-node描述一个文件或目录</li>
</ul></li>
<li>数据块
<ul>
<li>文件块或目录块</li>
</ul></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://blog.jamesyuuu.me/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/SSD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="JamesYu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JamesYu's Hut">
      <meta itemprop="description" content="A Game and Bangumi Database For Private Use">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | JamesYu's Hut">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/SSD/" class="post-title-link" itemprop="url">SSD</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-12-26 12:49:00" itemprop="dateCreated datePublished" datetime="2022-12-26T12:49:00+08:00">2022-12-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-11-01 20:48:22" itemprop="dateModified" datetime="2025-11-01T20:48:22+08:00">2025-11-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Study/" itemprop="url" rel="index"><span itemprop="name">Study</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>7 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="固态硬盘ssdsolid-state-drive">固态硬盘SSD（Solid State
Drive）</h1>
<h2 id="闪存组织">闪存组织</h2>
<ol type="1">
<li>闪存（Flash Memory）
<ul>
<li>1984：NOR flash</li>
<li>1987：NAND flash</li>
<li>1992：SSD</li>
</ul></li>
<li>NOR flash vs NAND flash
<ul>
<li>NOR是字节寻址，NAND是页寻址</li>
<li>NOR读延迟比NAND低100x</li>
<li>NOR擦除时间比NAND高300x</li>
<li>NOR用于取代ROM，存可执行代码</li>
<li>NAND用于大量持久化存储设备</li>
</ul></li>
<li>信息存储方式
<ul>
<li>SLC：1 bit/cell 2个值 0/1</li>
<li>MLC：2 bit/cell 4个值 00/01/10/11</li>
<li>TLC：3 bit/cell 8个值</li>
<li>QLC：4 bit/cell 16个值</li>
</ul></li>
</ol>
<h3 id="nand闪存组织">NAND闪存组织</h3>
<ol type="1">
<li>Flash package
<ul>
<li>多个 die</li>
</ul></li>
<li>Die
<ul>
<li>多个 Plane/Bank</li>
</ul></li>
<li>Plane/Bank
<ul>
<li>很多块（擦除块）</li>
<li>一些寄存器</li>
</ul></li>
<li>块（Block/Erase Block）
<ul>
<li>很多页</li>
</ul></li>
<li>页（Page）
<ul>
<li>由数据区与OOB(Out of Band)区构成</li>
<li>数据区用于存储实际数据</li>
<li>OOB区用于记录
<ul>
<li>ECC</li>
<li>状态信息：Erased/Valid/Invalid</li>
<li>Logic Page Number</li>
</ul></li>
<li>页大小
<ul>
<li>SLC通常为2KB<sub>8KB，TLC通常为4KB</sub>16KB</li>
</ul></li>
<li>块大小
<ul>
<li>SLC通常为128KB、256KB...</li>
<li>TLC通常为2MB、4MB...</li>
</ul></li>
</ul></li>
</ol>
<h3 id="闪存的操作接口">闪存的操作接口</h3>
<ol type="1">
<li>读：Read a page
<ul>
<li>读的粒度是页</li>
<li>读很快，读延迟在几十微秒</li>
<li>读延迟与位置无关，也与上一次读的位置无关（和磁盘不同）</li>
</ul></li>
<li>擦除：Erase a block
<ul>
<li>把整个块写成全1</li>
<li>擦除的粒度是块，必须整块擦除</li>
<li>很慢：擦除时间为几个毫秒</li>
<li>需软件把块内有效数据拷贝到其它地方</li>
</ul></li>
<li>写：Program a page
<ul>
<li>擦除后才能写，因为写只能把1变成0</li>
<li>写的粒度是页</li>
<li>写比读慢，比擦除快，写延迟在几百微秒</li>
</ul></li>
</ol>
<h3 id="页的状态">页的状态</h3>
<ol type="1">
<li>初始状态为Invalid</li>
<li>读时，不改变页的状态</li>
<li>擦除时，块内所有页的状态变为Erased</li>
<li>写时，只能写状态为Erased的页，写后页状态变为Valid</li>
</ol>
<h3 id="闪存的性能和可靠性">闪存的性能和可靠性</h3>
<ol type="1">
<li>性能
<ul>
<li>写延迟比读高10倍以上</li>
<li>写延迟波动幅度大</li>
<li>擦除很慢：约为磁盘定位延迟</li>
<li>延迟随密度增加而增长</li>
</ul></li>
<li>可靠性
<ul>
<li>磨损：擦写次数有上限，随密度增加而减少</li>
<li>干扰：读写一个页，相邻页中一些位的值发生翻转</li>
</ul></li>
<li>闪存特性
<ul>
<li>读延迟很低：随机读的性能远优于磁盘</li>
<li>写慢：必须先擦除再写，约为磁盘写（ms级）</li>
<li>磨损：每个块擦写次数有上限</li>
</ul></li>
</ol>
<h3 id="基于闪存的ssd">基于闪存的SSD</h3>
<ol type="1">
<li>用很多闪存芯片来构成一个持久化存储设备SSD</li>
<li>多个闪存芯片：并行I/O，提高I/O性能</li>
<li>与主机的接口：提供标准块设备接口</li>
<li>数据缓存和缓冲：SRAM/DRAM</li>
<li>闪存控制器（硬件）和FTL（固件）：控制逻辑
<ul>
<li>主机命令转换成闪存命令（Read/Erase/Program）</li>
<li>逻辑块地址转换成闪存的物理地址（页/块）</li>
<li>缓存替换</li>
</ul></li>
</ol>
<h2 id="ftl">FTL</h2>
<h3 id="最简单的ftl直接映射">最简单的FTL：直接映射</h3>
<ol type="1">
<li>Direct Mapping
<ul>
<li>逻辑块的第N块直接映射到物理的第N页(假设逻辑块与物理页都为4KB）</li>
</ul></li>
<li>读操作容易：读逻辑第k页
<ul>
<li>读物理第k页</li>
</ul></li>
<li>写操作麻烦：写逻辑第k页
<ul>
<li>第k页所在闪存块（记为B0）</li>
<li>把B0整个块读出来</li>
<li>把B0整个块擦除</li>
<li>B0中的旧页和新的第k页：以顺序方式一页一页再写入B0</li>
</ul></li>
<li>缺陷：写性能极差
<ul>
<li>每写一个页，要读整个块、擦除整个块、写整个块</li>
<li>写放大</li>
</ul></li>
</ol>
<h4 id="ftl改进异地更新">FTL改进：异地更新</h4>
<ol type="1">
<li>核心思想：异地更新（out-of-place update）
<ul>
<li>不再执行原地更新</li>
<li>每次写页，写到一个新位置（新的物理页地址）</li>
</ul></li>
<li>页级映射
<ul>
<li>页级映射表：LPN -&gt; 物理页地址PPN
<ul>
<li>整个放在内存中</li>
<li>持久化：利用页的OOB区来保存映射表</li>
<li>随着写页而被写到闪存</li>
<li>掉电或重启，扫描OOB区来恢复映射表</li>
</ul></li>
<li>优点：
<ul>
<li>性能好：减少写放大</li>
<li>可靠性好：映射关系被自动写入闪存</li>
</ul></li>
<li>问题：
<ul>
<li>重写产生垃圾页
<ul>
<li>每次写到新位置，导致原先页的内容无效</li>
</ul></li>
<li>内存开销大
<ul>
<li>映射表全部放内存</li>
<li>映射表的大小与SSD容量成正比</li>
</ul></li>
</ul></li>
</ul></li>
<li>写一个逻辑页k
<ul>
<li>寻找一个空闲页p（例如当前擦除块中下一个空闲页p）</li>
<li>在映射表中记录：逻辑页k -&gt; 物理页p</li>
</ul></li>
<li>读一个逻辑页k
<ul>
<li>查映射表，获得逻辑页k对应的物理页地址p</li>
<li>读物理页p</li>
</ul></li>
</ol>
<h4 id="垃圾回收">垃圾回收</h4>
<ol type="1">
<li>思想
<ul>
<li>选择一个含垃圾页的块</li>
<li>把其中的有效页拷贝到其他块中（先读再重写）</li>
<li>回收整个块，并把它擦除</li>
</ul></li>
<li>如何判断有效页？
<ul>
<li>每个物理页记录它对应的逻辑页地址（OOB区）</li>
<li>查映射表，如果映射表记录的 PPN=该页，是有效页</li>
</ul></li>
<li>问题：开销非常大
<ul>
<li>有效页需要拷贝：先读再重写</li>
<li>开销与有效页所占的比例成正比</li>
</ul></li>
<li>解决办法：超配（over-provisioning）
<ul>
<li>实际物理空间比用户所见空间更大：多15%~45%
<ul>
<li>例如，用户看到100GB的SSD，实际上内部是120GB</li>
<li>GC时将数据写入 over-provisioning space，减少对性能的影响</li>
</ul></li>
<li>GC一般在SSD后台执行，尽量再设备不忙时执行，但是受限于空闲页的数量
<ul>
<li>空闲页不足的时候，即使设备忙也需要开始执行GC</li>
</ul></li>
</ul></li>
</ol>
<h3 id="块级映射block-level-mapping">块级映射（Block-Level
Mapping）</h3>
<ol type="1">
<li>块级映射
<ul>
<li>逻辑地址空间划分为chunk，chunk size = 擦除块（物理块）size</li>
<li>映射表：chunk# -&gt; 擦除块（物理块）地址 PBN</li>
</ul></li>
<li>读一个逻辑页
<ul>
<li>逻辑页地址 = chunk# || 偏移</li>
<li>用chunk#查映射表，获得相应的擦除块地址PBN</li>
<li>物理页地址 = PBN || 偏移</li>
</ul></li>
<li>问题：小规模写性能差
<ul>
<li>写粒度小于擦除块：拷贝有效页（读 &amp; 写），导致写放大</li>
<li>小写很常见：擦除块通常较大（大于256KB）</li>
</ul></li>
</ol>
<h3 id="混合映射hybrid-mapping">混合映射（Hybrid Mapping）</h3>
<ol type="1">
<li>思想
<ul>
<li>将擦除块（物理块）划分为两类：数据块和日志块</li>
<li>写逻辑页时都写入日志块</li>
<li>数据块采用块级映射，数据映射表</li>
<li>日志块采用页级映射，日志映射表</li>
<li>适当的时候把日志块合并为数据块</li>
</ul></li>
<li>读一个逻辑页
<ul>
<li>先查日志映射表，按页级映射的方法</li>
<li>如果没找到，再查数据映射表，按块级映射的方法</li>
</ul></li>
</ol>
<h4 id="合并方式">合并方式</h4>
<ol type="1">
<li>Switch Merge
<ul>
<li>直接把日志块转成数据块：前提是整个日志块的页序与原数据块中的页序一致</li>
<li>把原来的数据块回收擦除</li>
<li>优点：开销低，只修改映射表信息，无数据拷贝</li>
</ul></li>
<li>Partial Merge
<ul>
<li>把数据块中有效页拷贝到日志块：日志块中页序与原数据块中的页序一致</li>
<li>把日志块转成数据块，把原来的数据块回收擦除</li>
<li>有数据拷贝开销</li>
</ul></li>
<li>Full Merge
<ul>
<li>分配一个新的日志块，从数据块和日志块分别拷贝有效页到新日志块</li>
<li>把新日志块转成数据块</li>
<li>把原来的数据块和日志块都回收擦除</li>
<li>开销很大：需要拷贝整个物理块的数据（读 &amp; 写）</li>
</ul></li>
</ol>
<h3 id="磨损均衡">磨损均衡</h3>
<ol type="1">
<li>目标
<ul>
<li>让所有块被擦除的次数近似</li>
</ul></li>
<li>动态磨损均衡
<ul>
<li>每次写时，选择擦除次数较少或最少的空闲块</li>
<li>局限性：不同数据的修改频率不同
<ul>
<li>例子：只写一次的数据（static data），很少写的数据（cold data）</li>
</ul></li>
</ul></li>
<li>静态磨损均衡
<ul>
<li>动态磨损均衡不考虑不会被回收的物理块，例如长时间不被修改的物理块（写冷块）</li>
<li>不再被写，不再有磨损</li>
<li>解决办法：FTL定期重写冷块，将其写入磨损较多的块</li>
</ul></li>
</ol>
<h3 id="总结">总结</h3>
<ol type="1">
<li>SSD FTL的主要功能
<ul>
<li>地址映射</li>
<li>垃圾回收</li>
<li>磨损均衡</li>
<li>请求调度</li>
<li>缓存管理</li>
<li>坏块管理</li>
</ul></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://blog.jamesyuuu.me/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%A3%81%E7%9B%98%E5%92%8CRAID/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="JamesYu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JamesYu's Hut">
      <meta itemprop="description" content="A Game and Bangumi Database For Private Use">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | JamesYu's Hut">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%A3%81%E7%9B%98%E5%92%8CRAID/" class="post-title-link" itemprop="url">磁盘和RAID</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-12-26 10:38:00" itemprop="dateCreated datePublished" datetime="2022-12-26T10:38:00+08:00">2022-12-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-11-01 20:48:22" itemprop="dateModified" datetime="2025-11-01T20:48:22+08:00">2025-11-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Study/" itemprop="url" rel="index"><span itemprop="name">Study</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.2k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>8 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="磁盘">磁盘</h1>
<ol type="1">
<li>持久化的、大容量的、低成本的存储设备：机械、速度慢
<ul>
<li>多种尺寸：3.5",2.5"</li>
<li>多种容量：100GB ~ 14TB</li>
<li>多种接口</li>
</ul></li>
<li>典型的磁盘控制器
<ul>
<li>与主机的接口
<ul>
<li>SATA,ATA: 面向对延迟、吞吐率要求不高，大容量的场景</li>
<li>SAS,SCSI/Ultra-SCSI: 面向低延迟，高吞吐率，高可靠场景</li>
<li>FC: Fiber Channel</li>
</ul></li>
<li>缓冲：缓冲数据</li>
<li>控制逻辑
<ul>
<li>读写请求</li>
<li>请求调度</li>
<li>缓存替换</li>
<li>坏块检测和重映射</li>
</ul></li>
</ul></li>
<li>磁盘的结构
<ul>
<li>盘片：一组
<ul>
<li>按固定速率旋转</li>
</ul></li>
<li>磁道（Track）
<ul>
<li>位于盘片表面的同心圆</li>
<li>用于记录数据的磁介质</li>
<li>bit沿着每条磁道顺序排列</li>
</ul></li>
<li>扇区（Sector）
<ul>
<li>磁道划分为固定大小的单元，一般为512字节</li>
</ul></li>
<li>磁头：一组
<ul>
<li>用于读写磁道上的数据</li>
</ul></li>
<li>磁臂：一组
<ul>
<li>用于移动磁头（多个）</li>
</ul></li>
<li>柱面（Cylinder）
<ul>
<li>由所有盘片上半径相同的磁道组成</li>
</ul></li>
<li>Zone
<ul>
<li>不同磁道的扇区个数不同：外道多，内道少</li>
<li>所有柱面划分为Zone，同一个Zone中每条磁道的扇区数相同</li>
<li>1000-5000个柱面/Zone，其中几个为备用柱面（Spare Cylinder）</li>
</ul></li>
</ul></li>
</ol>
<h2 id="磁盘扇区sector">磁盘扇区（Sector）</h2>
<ol type="1">
<li>扇区的创建
<ul>
<li>磁盘格式化</li>
<li>逻辑块地址映射到物理块地址</li>
</ul></li>
<li>扇区的格式
<ul>
<li>头部：ID，损坏标志位，...</li>
<li>数据区：实际用于存储数据的区域，典型大小为 512B</li>
<li>尾部：ECC校验码</li>
</ul></li>
<li>坏扇区
<ul>
<li>发现坏扇区 -&gt; 先用ECC纠错</li>
<li>如果不能纠错，用备用扇区替代</li>
<li>坏的扇区不再使用</li>
</ul></li>
<li>磁盘容量
<ul>
<li>格式化损耗20%左右：每个扇区的头部和尾部 + 坏扇区</li>
</ul></li>
<li>读写操作（读写某个柱面的某个扇区）
<ul>
<li>定位柱面，移动磁臂使磁头对准柱面 -&gt; 寻道seek</li>
<li>等待扇区旋转到磁头下方 -&gt; 旋转 rotation</li>
<li>进行数据读写 -&gt; 数据传输 transfer</li>
</ul></li>
</ol>
<h2 id="磁盘性能">磁盘性能</h2>
<ol type="1">
<li><p>有效带宽 = 数据量 / 耗时</p></li>
<li><p>耗时</p>
<ul>
<li>寻道时间（Seek Time）
<ul>
<li>把磁头移动到目标柱面的时间</li>
<li>典型：3.5 ~ 9.5ms</li>
</ul></li>
<li>旋转延迟（Rotation Delay）
<ul>
<li>等待目标扇区旋转到磁头下方的时间</li>
<li>典型：7200 ~ 15000 RPM</li>
</ul></li>
<li>数据传输时间（Data Transfer Time）
<ul>
<li>典型传输带宽：70~250 MB/Sec</li>
</ul></li>
</ul></li>
<li><p>例如：假设磁盘的 BW = 100MB/s,seek=5ms,rotation=4ms</p>
<ul>
<li>访问 1KB 数据的总时间 = 5ms + 4ms + 1KB/(100MB/s) = 9.01ms</li>
<li>有效带宽 = 1KB / 9.01ms 远小于 100MB/s</li>
<li>一次传输多少数据有效带宽才能达到磁盘带宽的90%
<ul>
<li>size = BW<em>(rotation + seek)</em>0.9/(1-0.9) = 8.1MB</li>
</ul></li>
<li>对于小粒度的访问，时间主要花在寻道时间和旋转时间上
<ul>
<li>磁盘的传输带宽被浪费</li>
<li>缓存：每次读写邻近的多个扇区，而不是一个扇区</li>
<li>调度算法：减少寻道开销</li>
</ul></li>
</ul></li>
<li><p>磁盘缓存</p>
<ul>
<li>磁盘内通过少量 DRAM 来缓存最近访问的块
<ul>
<li>典型大小为 64~256MB</li>
</ul></li>
<li>由控制器管理，OS无法控制</li>
<li>块替换策略：LRU</li>
<li>优点：如果访问具有局部性，则读性能受益</li>
<li>缺点：需要额外的机制来保障写的可靠性</li>
</ul></li>
</ol>
<h2 id="磁盘调度算法">磁盘调度算法</h2>
<h3 id="磁盘寻道算法fifofcfs">磁盘寻道算法FIFO(FCFS)</h3>
<ol type="1">
<li>例子
<ul>
<li>请求到达顺序：11 -&gt; 1 -&gt; 36 -&gt; 16 -&gt; 34 -&gt; 9 -&gt;
12</li>
<li>FIFO服务顺序：11 -&gt; 1 -&gt; 36 -&gt; 16 -&gt; 34 -&gt; 9 -&gt;
12</li>
<li>FIFO寻道总距离：10 + 35 + 20 + 18 + 25 + 3 = 111</li>
</ul></li>
<li>好处
<ul>
<li>公平性</li>
<li>磁盘请求的服务顺序是应用可以续期的</li>
</ul></li>
<li>坏处
<ul>
<li>请求到来的随机性，经常长距离地寻道</li>
<li>可能发送极端情况，比如需要横扫整个磁盘</li>
</ul></li>
</ol>
<h3 id="磁盘寻道算法ssfshortest-seek-first">磁盘寻道算法SSF(Shortest
Seek First)</h3>
<ol type="1">
<li>方法
<ul>
<li>选择磁头移动距离最短的请求（需要缓冲一部分请求）</li>
<li>计入旋转时间</li>
</ul></li>
<li>例子
<ul>
<li>请求到达顺序：11 -&gt; 1 -&gt; 36 -&gt; 16 -&gt; 34 -&gt; 9 -&gt;
12</li>
<li>SSF服务顺序：11 -&gt; 12 -&gt; 9 -&gt; 16 -&gt; 1 -&gt; 34 -&gt;
36</li>
<li>SSF寻道总距离：1 + 3 + 7 + 15 + 33 + 2 = 61</li>
</ul></li>
<li>好处
<ul>
<li>减少寻道时间</li>
</ul></li>
<li>坏处
<ul>
<li>可能产生饥饿</li>
</ul></li>
</ol>
<h3 id="电梯调度scanlook">电梯调度(SCAN/LOOK)</h3>
<ol type="1">
<li>方法
<ul>
<li>磁头按一个方向到另一端，再折回，按反方向回到这端，不断往返</li>
<li>只服务当前移动方向上寻道距离最近的请求</li>
<li>LOOK：如果磁盘移动方向上没有请求，就折回</li>
</ul></li>
<li>例子
<ul>
<li>请求到达顺序：11 -&gt; 1 -&gt; 36 -&gt; 16 -&gt; 34 -&gt; 9 -&gt;
12</li>
<li>SCAN服务顺序：11 -&gt; 12 -&gt; 16 -&gt; 34 -&gt; 36 -&gt; 9 -&gt;
1</li>
<li>SCAN寻道总距离：1 + 4 + 18 + 2 + 27 + 8 = 60</li>
</ul></li>
<li>好处
<ul>
<li>消除饥饿、请求的服务时间有上限</li>
</ul></li>
<li>坏处
<ul>
<li>反方向的请求需等到更长时间</li>
</ul></li>
</ol>
<h3 id="环路电梯调度c-scanc-look">环路电梯调度(C-SCAN/C-LOOK)</h3>
<ol type="1">
<li>方法
<ul>
<li>将SCAN改为折回时不服务请求，立即回到磁盘最外层重新向内扫描</li>
<li>寻道类似连起来成一个环</li>
</ul></li>
<li>好处
<ul>
<li>服务时间趋于一致</li>
</ul></li>
<li>坏处
<ul>
<li>折回时不干事</li>
</ul></li>
</ol>
<h2 id="磁盘调度算法对比">磁盘调度算法对比</h2>
<ol type="1">
<li>调度算法
<ul>
<li>FIFO：实现简单，但寻道时间长</li>
<li>SSF：贪心算法，可能造成饥饿现象（距离初始磁头位置较远的请求长期得不到服务）</li>
<li>SCAN/LOOK：减少饥饿</li>
<li>C-SCAN/C-LOOK：减少SCAN算法返回时的扫描开销</li>
</ul></li>
<li>磁盘I/O请求缓冲
<ul>
<li>把请求缓冲在控制器缓冲区</li>
<li>缓冲时间取决于缓冲区大小</li>
</ul></li>
<li>进一步的优化
<ul>
<li>既寻道最短，又旋转延迟最短</li>
</ul></li>
</ol>
<h1 id="raidredundant-array-of-independent-disks">RAID(Redundant Array
of Independent Disks)</h1>
<ol type="1">
<li>主要思想
<ul>
<li>由多个磁盘构成一个存储设备</li>
</ul></li>
<li>好处
<ul>
<li>提高性能：多个磁盘并行工作</li>
<li>增加容量：聚合多个磁盘的空间</li>
<li>提高可靠性：数据冗余，有磁盘损坏时，数据不损坏</li>
</ul></li>
<li>坏处
<ul>
<li>控制器变得复杂</li>
</ul></li>
<li>牵扯的问题
<ul>
<li>多块盘做块映射：逻辑块LBN -&gt; &lt;磁盘#,块#&gt;</li>
<li>如何通过冗余机制保护数据可靠性</li>
</ul></li>
</ol>
<h2 id="raid-0">RAID-0</h2>
<h3 id="raid-level-0">RAID Level 0</h3>
<ol type="1">
<li>以条带（Stripe）为粒度映射到N块磁盘（轮转方式），条带宽度为N，即有N个条（strip）组成</li>
<li>1个Strip=K个块，即1个条由K个块组成</li>
<li>容量
<ul>
<li>N * 单个磁盘容量（无冗余）</li>
</ul></li>
<li>可靠性
<ul>
<li>（单个磁盘可靠性）^ N</li>
</ul></li>
<li>性能：
<ul>
<li>带宽：N * 单个磁盘带宽</li>
<li>延迟：单个磁盘延迟</li>
</ul></li>
</ol>
<h3 id="raid-level-1">RAID Level 1</h3>
<ol type="1">
<li>以镜像的形式存储
<ul>
<li>镜像级别R：数据保存R份</li>
</ul></li>
<li>通常与RAID-0结合使用
<ul>
<li>RAID-01 或 RAID-10</li>
</ul></li>
<li>容量
<ul>
<li>(N * 单个磁盘容量) / R</li>
</ul></li>
<li>可靠性
<ul>
<li>容忍任何一个磁盘坏</li>
<li>特殊情况下可以容忍N/R的磁盘坏</li>
</ul></li>
<li>性能
<ul>
<li>写带宽：(N * 单个磁盘带宽) / R</li>
<li>读带宽：N * 单个磁盘带宽</li>
<li>延迟：单个磁盘延迟</li>
</ul></li>
</ol>
<h3 id="raid-level-4">RAID Level 4</h3>
<ol type="1">
<li>条带化 + 1个校验块
<ul>
<li>所有校验块在同一块磁盘上（校验盘）</li>
<li>缺点：校验盘为写性能瓶颈，易损坏</li>
</ul></li>
<li>每次写数据都需要更新校验快
<ul>
<li>方法一：读所有的数据盘
<ul>
<li>并行读所有磁盘的对应块</li>
<li>计算新校验块</li>
<li>并行写新块和新校验块</li>
</ul></li>
<li>方法二：读一个数据盘和校验盘
<ul>
<li>并行读旧块和旧校验块</li>
<li>计算新校验块
<ul>
<li>Pnew = (Bold ^ Bnew) ^ Pold</li>
</ul></li>
<li>并行写新块和新校验块</li>
</ul></li>
</ul></li>
<li>容量
<ul>
<li>(N - 1) * 单个磁盘容量</li>
</ul></li>
<li>可靠性
<ul>
<li>容忍任何一块磁盘坏</li>
<li>用XOR重构坏盘数据</li>
</ul></li>
<li>延迟
<ul>
<li>读延迟等于单个磁盘的延迟</li>
<li>写延迟约等于2倍单个磁盘的延迟</li>
</ul></li>
<li>带宽
<ul>
<li>读带宽 = (N-1)*单个磁盘带宽</li>
<li>校验盘为写瓶颈，所有校验块串行写</li>
</ul></li>
</ol>
<h3 id="raid-level-5">RAID Level 5</h3>
<ol type="1">
<li>条带粒度映射 + 1个校验块
<ul>
<li>校验块分散在不同磁盘上</li>
<li>Rebuild：复杂 &amp; 速度慢</li>
</ul></li>
<li>写带宽
<ul>
<li>写并行：校验块并行写</li>
<li>写带宽：(N*单个磁盘带宽) / 4</li>
</ul></li>
<li>读带宽
<ul>
<li>正常状态：只读数据块</li>
<li>读带宽：N*单个磁盘带宽</li>
</ul></li>
</ol>
<h2 id="其他raid级别">其他RAID级别</h2>
<ol type="1">
<li>RAID Level 2
<ul>
<li>按位为粒度映射 + ECC</li>
<li>每4位 + 3位海明码</li>
<li>所有磁盘同步读写：寻道 + 旋转</li>
</ul></li>
<li>RAID Level 3
<ul>
<li>按位为粒度映射 + Parity位</li>
<li>已知坏磁盘时，可纠错</li>
</ul></li>
<li>RAID Level 6
<ul>
<li>条带粒度映射 + 2个校验块</li>
<li>能容忍两块磁盘同时坏</li>
</ul></li>
</ol>
<h2 id="卷管理volume-manager">卷管理（Volume Manager）</h2>
<ol type="1">
<li>虚拟块设备
<ul>
<li>在多个磁盘上创建一个或多个逻辑卷</li>
<li>逻辑卷：一个虚拟块设备</li>
<li>采用RAID技术将逻辑卷的块地址映射到物理设备</li>
</ul></li>
<li>好处
<ul>
<li>提供虚拟的容量和性能</li>
<li>容错</li>
</ul></li>
<li>实现
<ul>
<li>OS内核的逻辑卷管理
<ul>
<li>Windows MacOS Linux等</li>
</ul></li>
<li>存储设备控制器（存储系统）
<ul>
<li>EMC Hitachi HP IBM NetApp</li>
<li>接口：PCIe iSCSI FC等</li>
</ul></li>
</ul></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2022 – 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">JamesYu</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">64k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">3:52</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & <span class="exturl" data-url="aHR0cHM6Ly90aGVtZS1uZXh0LmpzLm9yZw==">NexT.Gemini</span> 强力驱动
  </div>

    </div>
    <script src="https://cdn.jsdelivr.net/gh/stevenjoezhang/live2d-widget@latest/autoload.js"></script>
  </footer>

  
  <script size="300" alpha="0.6" zIndex="-1" src="https://cdn.jsdelivr.net/npm/ribbon.js@1.0.2/dist/ribbon.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script>

  <script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.1/dist/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>

  <script class="next-config" data-name="pdf" type="application/json">{"object_url":{"url":"https://cdn.jsdelivr.net/npm/pdfobject@2.2.12/pdfobject.min.js","integrity":"sha256-g2xji1rlE3KsGVClvuxTbcR0Kn2+wtQADSff2Tbb4zA="},"url":"/lib/pdf/web/viewer.html"}</script>
  <script src="/js/third-party/tags/pdf.js"></script>

  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdn.jsdelivr.net/npm/mermaid@10.5.0/dist/mermaid.min.js","integrity":"sha256-K7oJiQlDulzl24ZUFOywuYme1JqBBvQzK6m8qHjt9Gk="}}</script>
  <script src="/js/third-party/tags/mermaid.js"></script>



  <script src="/js/third-party/pace.js"></script>


  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>


<script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>

<script>
var options = {
  bottom: '64px',
  right: '32px',
  left: 'unset',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#100f2c',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script>

  <script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-needmoreshare2@1/needsharebutton.min.js"></script>
  <script>
      pbOptions = {};
        pbOptions.iconStyle = "box";
        pbOptions.boxForm = "horizontal";
        pbOptions.position = "bottomCenter";
        pbOptions.networks = "Weibo,Wechat,Douban,QQZone,Twitter,Facebook";
      new needShareButton('#needsharebutton-postbottom', pbOptions);
  </script><script src="/js/third-party/comments/livere.js"></script>

</body>
</html>
